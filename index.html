<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pinoy Pool</title>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #36454F;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #game-canvas {
            background-color: #D2B48C;
            border: 25px solid #8B4513; /* Increased border width for a wood frame */
            box-shadow: 
                /* Outer shadow for the table */
                0 10px 25px rgba(0,0,0,0.6), 
                /* Inner shadow to create the raised cushion effect */
                inset 0 0 10px rgba(0,0,0,0.7),
                /* A subtle highlight on the inner edge of the frame to give it a bevel */
                inset 2px 2px 5px rgba(255, 255, 255, 0.2),
                /* A subtle shadow on the opposite inner edge for the bevel */
                inset -2px -2px 5px rgba(0, 0, 0, 0.4);
            border-radius: 10px; /* Added rounded corners like in the image */
            cursor: crosshair;
            box-sizing: border-box; 
            max-width: 100%;
            max-height: 100%;
        }
#ghost-hand {
    display: none; /* Nakatago by default */
    position: absolute; /* Para lumutang at masunod ang cursor */
    width: 80px; /* Sukat ng kamay, pwede mong baguhin */
    height: auto;
    opacity: 0.7; /* Para magmukha siyang "ghost" (70% solid) */
    z-index: 50; /* Para siguradong nasa ibabaw siya ng canvas */
    pointer-events: none; /* SUPER IMPORTANTE: Para hindi niya harangan ang pag-click */
    transform: translate(-25px, -15px); /* Ina-adjust ang pwesto para ang daliri ang nasa cursor */
}

        
        /* UI Containers */
        #non-interactive-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2em;
            display: none;
            text-align: center;
        }
        .info-box {
            position: absolute;
            color: white;
            background-color: rgba(255, 256, 255, 0.2); 
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px 7px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        #player-info { top: 0px; left: 70px; }
        #opponent-info { top: 0px; right: 70px; }
        
        .ui-button {
            position: absolute;
            padding: 10px 15px;
            font-size: 1em;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            z-index: 10;
        }

        #exit-button {
            bottom: 0px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 53, 69, 0.5);
            padding: 4px 16px;
            font-size: 0.8em;
            z-index: 100;
            transition: background-color 0.2s;
        }
        #exit-button:hover {
            background-color: rgba(220, 53, 69, 0.8);
        }

        .icon-button {
            background-color: rgba(0, 0, 0, 0.6);
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        #fullscreen-button {
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
        }
        
        #card-hand-container, #poker-foul-cards {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row; 
            gap: 8px; 
            pointer-events: all;
            z-index: 10;
        }

        #poker-foul-cards {
            top: auto; 
            position: relative;
            transform: none;
            left: auto;
            margin-top: 20px;
        }


        .card {
            width: 40px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            border-radius: 4px; 
            display: flex;
            flex-direction: column; 
            justify-content: space-around; 
            align-items: center;
            font-weight: bold;
            color: white; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); 
            transition: transform 0.2s ease-in-out;
        }
         #card-hand-container .card {
            width: 20px;
            height: 35px;
        }
        .card-rank { font-size: 1.5em; }
        .card-suit { font-size: 1.2em; }
        #card-hand-container .card-rank { font-size: 1em; }
        #card-hand-container .card-suit { font-size: 0.9em; }

        .card.face-down {
            background-image: linear-gradient(135deg, #4a90e2 25%, #50e3c2 100%);
            cursor: pointer;
        }
        .card.face-down:hover {
            transform: translateY(-10px) scale(1.05);
        }

        /* Controls */
        .control-area {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            z-index: 20;
        }

        #power-control {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            flex-direction: column;
            justify-content: flex-end;
        }
        #power-bar {
            width: 100%;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
            border-radius: 8px;
            height: 0%;
        }

        #pektus-control {
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: none;
        }
        #pektus-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 0, 0, 0.8);
            border: 1px solid white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .arrow-button {
            position: absolute;
            bottom: 0px;
            width: 70px;
            height: 33px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        #left-arrow {
            right: 50%;
            transform: translateX(-120px);
        }
        #right-arrow {
            left: 50%;
            transform: translateX(120px);
        }


        /* Modals and Overlays */
        .modal-overlay {
            display: none; 
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            flex-direction: column;
            z-index: 200;
        }
        #confirm-exit-modal {
            z-index: 300; /* Ensure this is on top of all other modals */
        }
        #game-mode-select {
            display: flex; 
        }
        .modal-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
        }
        .menu-button {
            font-size: 1.2em;
            padding: 15px 20px;
            margin: 8px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(76, 175, 80, 0.5);
            color: white;
            cursor: pointer;
            width: 300px;
            pointer-events: all;
            transition: background-color 0.3s, opacity 0.3s;
        }
        .menu-button:disabled {
            background-color: rgba(108, 117, 125, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
            opacity: 0.6;
            cursor: not-allowed;
        }
        .back-button {
            background-color: rgba(108, 117, 125, 0.5);
            margin-top: 20px;
        }
        
        #winner-modal h2 {
            margin-bottom: 0;
        }
        #winner-modal #play-again-button {
            font-size: 1.2em;
            padding: 10px 20px;
            margin-top: 30px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
        }

        #online-menu input {
            font-size: 1em;
            padding: 10px;
            margin: 10px;
            width: 250px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #opponent-hand-reveal {
            margin-top: 20px;
        }
        #opponent-hand-reveal .card {
            transform: scale(0.8);
        }

        /* Instruction Modal Styles */
        .instruction-modal .content, #leaderboard-modal .content {
            background-color: rgba(40, 40, 90, 0.85);
            padding: 20px 30px;
            border-radius: 15px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .instruction-modal .play-button-container {
            margin-bottom: 20px;
        }
        .instruction-modal p {
            font-style: italic;
            line-height: 1.6;
            font-size: 1.1em;
            text-align: left;
            transform: skewX(-8deg);
        }
        .instruction-modal h2 {
            transform: skewX(-8deg);
        }

        /* Guide Text Style */
        .guide-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 0, 0.8);
            color: black;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            display: none; 
            text-align: center;
        }
        
        /* Waiting Room Style */
        #waiting-room p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        #waiting-room #game-id-display {
            background-color: rgba(0,0,0,0.4);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 2.5em;
            font-weight: bold;
            letter-spacing: 5px;
            border: 1px solid rgba(255,255,255,0.3);
            margin-bottom: 20px;
            cursor: pointer;
        }

        /* Confirmation Modal Styles */
        #confirm-exit-modal .button-group {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #confirm-exit-modal .confirm-button {
            width: 120px;
            pointer-events: all;
        }
        #confirm-exit-yes {
            background-color: rgba(220, 53, 69, 0.7);
        }
        #confirm-exit-cancel {
            background-color: rgba(108, 117, 125, 0.7);
        }

        /* Leaderboard Style */
        #leaderboard-modal .content {
              width: 80%; 
              max-width: 500px;
        }
        #leaderboard-modal table {
            width: 100%; 
            text-align: left; 
            border-collapse: collapse;
        }
        #leaderboard-modal th, #leaderboard-modal td {
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
        }

    </style>
</head>
    <body>
        <div id="game-wrapper">
            <canvas id="game-canvas"></canvas>
            
          <img id="ghost-hand" src="https://i.imgur.com/ZPG3GhI.png">



            
                    <div id="non-interactive-overlay">
            <div id="player-info" class="info-box">You: ?</div>
            <div id="opponent-info" class="info-box">Opponent: ?</div>
            <div id="message-box"></div>
            <div id="cue-ball-guide" class="guide-text"></div>

            <div id="drag-guide-text" class="guide-text">Place the cue ball</div>
        </div>

        
        <!-- Interactive UI elements -->
        <button id="exit-button" class="ui-button">Exit</button>
        <div id="card-hand-container"></div>
        <button id="fullscreen-button" class="ui-button icon-button" title="Toggle Fullscreen">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;">
                <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
            </svg>
        </button>
        
        <!-- Controls -->
        <div id="power-control" class="control-area">
            <div id="power-bar"></div>
        </div>
        <div id="pektus-control" class="control-area">
            <div id="pektus-dot"></div>
        </div>
        <div id="left-arrow" class="arrow-button control-area">&lt;</div>
        <div id="right-arrow" class="arrow-button control-area">&gt;</div>
    </div>

    <!-- Game Mode Selection -->
    <div id="game-mode-select" class="modal-overlay">
        <h2>Select Game Mode</h2>
        <button class="menu-button" id="vs-ai-button">Player vs AI</button>
        <button class="menu-button" id="online-button">Online Multiplayer</button>
        <button class="menu-button" id="leaderboard-button" style="background-color: rgba(255, 193, 7, 0.5);">Leaderboard</button>
    </div>

    <!-- AI Sub-Menu -->
    <div id="ai-menu" class="modal-overlay">
        <h2>Player vs AI</h2>
        <button class="menu-button" id="ai-straight-ball-button">STRAIGHT BALL</button>
        <button class="menu-button" id="ai-poker-button">POKER</button>
        <button class="menu-button" id="ai-61-button">61 BALL</button>
        <button class="menu-button back-button" id="ai-back-button">Back</button>
    </div>

    <!-- Difficulty Selection Overlay -->
    <div id="difficulty-select" class="modal-overlay">
        <h2>Select Difficulty</h2>
        <button class="menu-button" data-difficulty="easy">Easy</button>
        <button class="menu-button" data-difficulty="hard">Hard</button>
        <button class="menu-button" data-difficulty="pro">Professional</button>
        <button class="menu-button back-button" id="difficulty-back-button">Back</button>
    </div>
    
    <!-- Instruction Modals -->
    <div id="straight-ball-instructions" class="modal-overlay instruction-modal">
        <div class="content">
            <div class="play-button-container">
                 <button class="menu-button" id="play-straight-ball-button">Play</button>
            </div>
            <h2>Straight Ball Rules</h2>
            <p>
                - Continue your turn by legally pocketing your balls.<br>
                - The first color legally pocketed on an 'open table' becomes yours.<br>
                - <strong>Foul:</strong> Pocketing the cue ball returns one of your pocketed balls to the table.<br>
                - <strong>Foul:</strong> Hitting an opponent's ball first returns any of your balls pocketed on that shot.<br>
                - First to pocket all their balls wins!
            </p>
        </div>
    </div>

    <div id="poker-instructions" class="modal-overlay instruction-modal">
        <div class="content">
             <div class="play-button-container">
                <button class="menu-button" id="play-poker-button">Play</button>
            </div>
            <h2>Poker Pool Rules</h2>
            <p>
                - You get 7 cards. Pocket balls matching your cards to win.<br>
                - A hand of all Kings is an automatic win.<br>
                - <strong>Cue Ball Foul:</strong> Pocketing the cue ball forces you to draw a penalty card.<br>
                - <strong>Last Ball Foul:</strong> If you scratch on your last ball, you draw a card. A King wins the game, otherwise, play continues with the new card.<br>
                - A penalty card matching a pocketed ball is discarded.
            </p>
        </div>
    </div>
    
    <div id="61-ball-instructions" class="modal-overlay instruction-modal">
        <div class="content">
             <div class="play-button-container">
                <button class="menu-button" id="play-61-ball-button">Play</button>
            </div>
            <h2>61 Ball Rules</h2>
            <p>
                - The goal is to be the first to score 61 points.<br>
                - You must always hit the lowest numbered chip on the table first.<br>
                - Your score is the sum of the numbers on the chips you legally pocket.<br>
                - <strong>Example:</strong> Hit the 1-chip first, and the 15-chip is pocketed. You get 15 points.<br>
                - Your turn continues as long as you legally pocket a chip.<br>
                - <strong>Foul:</strong> Hitting the wrong chip first, or scratching the cue chip, ends your turn. Your opponent gets ball-in-hand. Any chips pocketed on a foul shot will be returned to the table.
            </p>
        </div>
    </div>

    <!-- Poker Foul Card Pick -->
    <div id="poker-foul-card-pick-modal" class="modal-overlay">
        <h2>Foul! Pick a card.</h2>
        <div id="poker-foul-cards"></div>
    </div>

    <!-- Online Game Type Selection -->
    <div id="online-game-select" class="modal-overlay">
        <h2>Online: Select Game Type</h2>
        <button class="menu-button" id="online-poker-button">POKER POOL</button>
        <button class="menu-button" id="online-straight-ball-button">STRAIGHT BALL</button>
        <button class="menu-button" id="online-61-button">61 BALL</button>
        <button class="menu-button back-button" id="online-select-back-button">Back</button>
    </div>

    <!-- Online Multiplayer Menu -->
    <div id="online-menu" class="modal-overlay">
        <h2>Online Multiplayer</h2>
        <button class="menu-button" id="create-game-button">Create Game</button>
        <input type="text" id="game-id-input" placeholder="Enter Game ID">
        <button class="menu-button" id="join-game-button">Join Game</button>
        <button class="menu-button back-button" id="online-back-button">Back</button>
    </div>

    <!-- Waiting Room -->
    <div id="waiting-room" class="modal-overlay">
        <h2>Waiting for Opponent...</h2>
        <p>Share this Game ID with your friend:</p>
        <div id="game-id-display" title="Click to copy"></div>
        <button class="menu-button back-button" id="cancel-game-button">Cancel</button>
    </div>


    <!-- Winner Modal -->
    <div id="winner-modal" class="modal-overlay">
        <h2 id="winner-text"></h2>
        <button id="play-again-button">Play Again</button>
        <button id="rematch-button" class="menu-button" style="display: none; width: 250px; margin-top: 15px;">Rematch</button>
        <div id="opponent-hand-reveal"></div>
    </div>

    <!-- Exit Confirmation Modal -->
    <div id="confirm-exit-modal" class="modal-overlay">
        <h2>Are you sure you want to exit?</h2>
        <p>This will count as a loss if you are in an online game.</p>
        <div class="button-group">
            <button id="confirm-exit-yes" class="menu-button confirm-button">Yes</button>
            <button id="confirm-exit-cancel" class="menu-button confirm-button">Cancel</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal-overlay">
        <div class="content">
            <h2>Top Players</h2>
            <table>
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Wins</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body">
                    <!-- Data will be loaded here by JavaScript -->
                    <tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr>
                </tbody>
            </table>
            <button class="menu-button back-button" id="leaderboard-back-button">Back</button>
        </div>
    </div>

    <script type="module">
        // =========================================================================
        // FIREBASE SETUP
        // =========================================================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, deleteDoc, writeBatch, 
            serverTimestamp, increment, collection, query, orderBy, limit, getDocs 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let db, auth;
        let firebaseInitialized = false;
        let isAuthReady = false;

        // =========================================================================
        // DOM ELEMENTS
        // =========================================================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameWrapper = document.getElementById('game-wrapper');
        const messageBox = document.getElementById('message-box');
        const winnerModal = document.getElementById('winner-modal');
        const winnerText = document.getElementById('winner-text');
        const playerInfo = document.getElementById('player-info');
        const opponentInfo = document.getElementById('opponent-info');
        const powerControl = document.getElementById('power-control');
        const powerBar = document.getElementById('power-bar');
        const gameModeSelect = document.getElementById('game-mode-select');
        const difficultySelect = document.getElementById('difficulty-select');
        const onlineMenu = document.getElementById('online-menu');
        const exitButton = document.getElementById('exit-button');
        const vsAiButton = document.getElementById('vs-ai-button');
        const onlineButton = document.getElementById('online-button');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const gameIdInput = document.getElementById('game-id-input');
        const difficultyBackButton = document.getElementById('difficulty-back-button');
        const onlineBackButton = document.getElementById('online-back-button');
        const cardHandContainer = document.getElementById('card-hand-container');
        const opponentHandReveal = document.getElementById('opponent-hand-reveal');
        const playAgainButton = document.getElementById('play-again-button');
        const aiMenu = document.getElementById('ai-menu');
        const aiStraightBallButton = document.getElementById('ai-straight-ball-button');
        const aiPokerButton = document.getElementById('ai-poker-button');
        const ai61Button = document.getElementById('ai-61-button');
        const aiBackButton = document.getElementById('ai-back-button');
        const straightBallInstructions = document.getElementById('straight-ball-instructions');
        const pokerInstructions = document.getElementById('poker-instructions');
        const sixtyOneInstructions = document.getElementById('61-ball-instructions');
        const playStraightBallButton = document.getElementById('play-straight-ball-button');
        const playPokerButton = document.getElementById('play-poker-button');
        const play61BallButton = document.getElementById('play-61-ball-button');
        const cueBallGuide = document.getElementById('cue-ball-guide');
        const waitingRoom = document.getElementById('waiting-room');
        const gameIdDisplay = document.getElementById('game-id-display');
        const cancelGameButton = document.getElementById('cancel-game-button');
        const onlineGameSelect = document.getElementById('online-game-select');
        const onlinePokerButton = document.getElementById('online-poker-button');
        const onlineStraightBallButton = document.getElementById('online-straight-ball-button');
        const online61Button = document.getElementById('online-61-button');
        const onlineSelectBackButton = document.getElementById('online-select-back-button');
        const confirmExitModal = document.getElementById('confirm-exit-modal');
        const confirmExitYes = document.getElementById('confirm-exit-yes');
        const confirmExitCancel = document.getElementById('confirm-exit-cancel');
        const pektusControl = document.getElementById('pektus-control');
        const pektusDot = document.getElementById('pektus-dot');
        const leftArrow = document.getElementById('left-arrow');
        const rightArrow = document.getElementById('right-arrow');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const pokerFoulCardPickModal = document.getElementById('poker-foul-card-pick-modal');
        const pokerFoulCardsContainer = document.getElementById('poker-foul-cards');
        const leaderboardModal = document.getElementById('leaderboard-modal');
        const leaderboardButton = document.getElementById('leaderboard-button');
        const leaderboardBackButton = document.getElementById('leaderboard-back-button');
                // ... (ibang mga const declarations tulad ng leaderboardBody)
        const leaderboardBody = document.getElementById('leaderboard-body');
        
                // ... (ibang mga const declarations tulad ng ghostHand)
        const ghostHand = document.getElementById('ghost-hand');
        
        const dragGuideText = document.getElementById('drag-guide-text'); // IDAGDAG ITO


        
        // =========================================================================
        // CONSTANTS & GAME STATE
        // =========================================================================
        const TABLE_ASPECT_RATIO = 2;
        const BALL_RADIUS = 18;
        const CUE_BALL_RADIUS = 20;
        const HOLE_RADIUS = 40;
        const FRICTION = 0.98; 
        const MIN_VELOCITY = 0.05;
        const ROTATION_SPEED = 0.001;
        const TOUCH_AIM_SENSITIVITY = 0.00001;

        // --- Game State Variables ---
        let scale = 1;
        let table = { width: 0, height: 0 };
        let chips = [];
        let holes = [];
        let cueStick = { angle: 0, length: 10000, visible: true, power: 0, pullback: 0 };
        let gameState = 'menu';
        let gameMode = 'ai-classic';
        let playerTurn = true;
        let colorsAssigned = false;
        let playerChipsType = null;
        let opponentChipsType = null;
        let canMoveCueBall = false;
        let chipsMoving = false;
        let chipsPocketedInTurn = [];
        let firstChipHitInTurn = null;
        let isPoweringUp = false;
        let isAimingOnCanvas = false;
        let isDraggingCueBall = false;
        let difficulty = 'easy';
        let deck = [];
        let playerHand = [];
        let opponentHand = [];
        let originalPlayerHand = [];
        let originalOpponentHand = [];
        let selectedGameConfig = {}; 
        let isBreakShot = false;
        let pektusOffset = { x: 0, y: 0 };
        let shotPektusOffset = { x: 0, y: 0 };
        let isDraggingPektusDot = false;
        let isRotatingLeft = false;
        let isRotatingRight = false;
        let isInvalidPlacement = false;
        let player61Score = 0;
        let opponent61Score = 0;
let lowestChipNumber = 1;
let aiConsecutivePots = 0; // BAGONG DAGDAG: Para sa "killer instinct"


        // --- Online Multiplayer Variables ---
        let gameId = null;
        let localPlayerId = null;
        let localPlayerUid = null;
        let currentTurnUid = null;
        let unsubscribeGameListener;
        let isOnlineGame = false;
        let isMyTurnOnline = false;
        let isProcessingTurnEnd = false;
        let lastProcessedTurnId = -1; 
        let isSyncing = false;
        let selectedOnlineGameType = 'poker';
        let lastAimUpdateTime = 0;
        const AIM_UPDATE_INTERVAL = 50;
        let lastTurnControllerUid = null;
        
        // --- Audio State ---
        let audioInitialized = false;
        let chipCollisionSynth, pocketSynth, uiSynth, cueHitSynth, cushionSynth;
        let lastCollisionSoundTime = -1;
        let lastCushionSoundTime = -1;
        let buttonSoundPlaying = false;

        const cueStickImage = new Image();
        cueStickImage.src = 'https://i.imgur.com/FYXWKhr.png';

        // =========================================================================
        // AUDIO HANDLING
        // =========================================================================
        
        function initAudio() {
            if (audioInitialized || typeof Tone === 'undefined') {
                return Promise.resolve();
            }
            
            return Tone.start().then(() => {
                chipCollisionSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 5, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1, attackCurve: "exponential", }, }).toDestination();
                chipCollisionSynth.volume.value = -4;
                cueHitSynth = new Tone.PluckSynth({ attackNoise: 1, dampening: 2000, resonance: 0.5, }).toDestination();
                cueHitSynth.volume.value = -1;
                cushionSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
                cushionSynth.volume.value = -8;
                pocketSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.1 } }).toDestination();
                pocketSynth.volume.value = -5;
                uiSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.8 }).toDestination();
                uiSynth.volume.value = -4;
                audioInitialized = true;
            }).catch(e => {
                console.error("Could not start Tone.js audio context:", e);
                audioInitialized = false; 
            });
        }
        
        async function playButtonSound() {
            if (buttonSoundPlaying) return;
            if (!audioInitialized) await initAudio();
            if (!audioInitialized) return; 
            buttonSoundPlaying = true;
            uiSynth.triggerAttackRelease("C5", "8n");
            setTimeout(() => { buttonSoundPlaying = false; }, 50);
        }

        async function playCollisionSound(speed) {
            if (!audioInitialized) await initAudio();
            if (!audioInitialized) return;
            const now = Tone.now();
            if (now <= lastCollisionSoundTime) return;
            lastCollisionSoundTime = now + 0.04;
            const volume = -12 + Math.min(1, speed / 25) * 14;
            const note = speed > 15 ? 'C3' : (speed > 5 ? 'A2' : 'G2');
            chipCollisionSynth.volume.value = volume;
            chipCollisionSynth.triggerAttackRelease(note, "32n", now);
        }

        async function playCushionSound(speed) {
             if (!audioInitialized) await initAudio();
            if (!audioInitialized) return;
            const now = Tone.now();
            if (now <= lastCushionSoundTime) return;
            lastCushionSoundTime = now + 0.03;
            const volume = -12 + Math.min(1, speed / 15) * 8;
            const note = speed > 10 ? 'C2' : 'D1';
            cushionSynth.volume.value = volume;
            cushionSynth.triggerAttackRelease(note, '16n', now);
        }

        async function playCueHitSound(power) { 
            if (!audioInitialized) await initAudio();
            if (!audioInitialized) return;
            const now = Tone.now();
            const volume = -6 + (power * 6);
            const note = 'C4'; 
            cueHitSynth.volume.value = volume;
            cueHitSynth.triggerAttack(note, now);
        }

        async function playPocketSound() {
            if (!audioInitialized) await initAudio();
            if (!audioInitialized) return;
            pocketSynth.triggerAttackRelease("0.2");
        }

        // =========================================================================
        // GAME INITIALIZATION & MAIN LOOP
        // =========================================================================

        function init() {
            resizeCanvas();
            setupEventListeners();
            initializeFirebase(); 
            history.replaceState({ modal: 'gameModeSelect' }, 'Main Menu', '#main');
            update();
        }

        function update() {
            if (isRotatingLeft || isRotatingRight) {
                if (isRotatingLeft) cueStick.angle -= ROTATION_SPEED;
                if (isRotatingRight) cueStick.angle += ROTATION_SPEED;
                sendLiveAimData();
            }

            if (chipsMoving) {
                updateChipPositions();
            }
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTable();
            drawChips();

            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            if (isMyTurn && gameState === 'aiming') {
                drawGuidelines();
            }

            if ((gameState === 'aiming' || gameState === 'shooting_animation' || (isOnlineGame && !isMyTurnOnline)) && cueStick.visible) {
                drawCueStick();
            }
        }

        // =========================================================================
        // CANVAS & TABLE SETUP
        // =========================================================================

        function resizeCanvas() {
            const oldTableWidth = table.width;
            const oldTableHeight = table.height;
            const chipRatios = chips.map(c => ({
                x: oldTableWidth > 0 ? c.x / oldTableWidth : 0.5,
                y: oldTableHeight > 0 ? c.y / oldTableHeight : 0.5
            }));

            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const screenAspectRatio = containerWidth / containerHeight;

            if (screenAspectRatio > TABLE_ASPECT_RATIO) {
                table.height = containerHeight;
                table.width = table.height * TABLE_ASPECT_RATIO;
            } else {
                table.width = containerWidth;
                table.height = table.width / TABLE_ASPECT_RATIO;
            }
            
            scale = table.width / 1000;
            canvas.width = table.width;
            canvas.height = table.height;
            
            setupHoles();
            
            if (chips.length > 0) {
                chips.forEach((chip, i) => {
                    const radiusConstant = chip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS;
                    chip.x = chipRatios[i].x * table.width;
                    chip.y = chipRatios[i].y * table.height;
                    chip.radius = radiusConstant * scale;
                });
            }
            cueStick.length = 700 * scale;
        }

                        function setupHoles() {
            const hr = HOLE_RADIUS * scale;
            holes = [
                { x: 0, y: 0, radius: hr }, 
                { x: table.width, y: 0, radius: hr }, 
                { x: 0, y: table.height, radius: hr }, 
                { x: table.width, y: table.height, radius: hr }
            ];
        }



        function setupChips() {
            chips = [];
            const newCueChip = { 
                id: 0, value: 0, x: table.width * 0.25, y: table.height / 2, 
                vx: 0, vy: 0, radius: CUE_BALL_RADIUS * scale, inPlay: true, color: '#1a1a1a', type: 'cue',
                isPocketing: false, pocketingProgress: 0, pocketingHole: null,
                rotation: 0, rotationSpeed: 0 
            };
            chips.push(newCueChip);
        
            const objectChipRadius = BALL_RADIUS * scale;
        
            if (gameMode.includes('straight-ball') || gameMode.includes('poker')) {
                const redChipsSource = [];
                const blueChipsSource = [];
                for (let i = 1; i <= 12; i++) {
                    if (i <= 6) { 
                        redChipsSource.push({ id: i, color: '#C8102E', type: 'red', value: i }); 
                    } else { 
                        blueChipsSource.push({ id: i, color: '#0033A0', type: 'blue', value: i });
                    }
                }
                
                const startX = table.width * 0.7;
                const startY = table.height / 2;
                const colSpacing = objectChipRadius * 2.1;
                const rowSpacing = objectChipRadius * 1.8;
                
                const positions = [];
                const rows = 4;
                const cols = 3;
                
                const totalHeight = (rows - 1) * rowSpacing;
                const initialY = startY - totalHeight / 2;
    
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        positions.push({
                            x: startX + col * colSpacing,
                            y: initialY + row * rowSpacing
                        });
                    }
                }
    
                const chipDataOrder = [ ...redChipsSource, ...blueChipsSource ];
    
                for (let i = 0; i < positions.length; i++) {
                    let chipData = chipDataOrder[i];
    
                    if (chipData) {
                        const newObjectChip = {
                            id: chipData.id, value: chipData.value, x: positions[i].x, y: positions[i].y,
                            vx: 0, vy: 0, radius: objectChipRadius, inPlay: true, color: chipData.color,
                            type: chipData.type, isPocketing: false, pocketingProgress: 0, pocketingHole: null,
                            rotation: 0, rotationSpeed: 0
                        };
                        chips.push(newObjectChip);
                    }
                }
            } else if (gameMode.includes('61-ball')) {
                const chipColors = [
                    null, '#FFD700', '#0000FF', '#FF0000', '#800080', '#FFA500', 
                    '#008000', '#964B00', '#212121', '#FFC107', '#03A9F4', '#F44336', 
                    '#9C27B0', '#FF9800', '#4CAF50', '#795548'
                ];
        
                let chipIds = Array.from({length: 15}, (_, i) => i + 1);
        
                // Standard 15-ball rack setup
                const startX = table.width * 0.75;
                const startY = table.height / 2;
                const rowSpacing = objectChipRadius * 1.8;
        
                const rackPositions = [];
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col <= row; col++) {
                        rackPositions.push({
                            x: startX + row * rowSpacing,
                            y: startY + (col * objectChipRadius * 2.1) - (row * objectChipRadius * 1.05)
                        });
                    }
                }
        
                // Place chips
                for (let i = 0; i < 15; i++) {
                    const chipId = chipIds[i];
                    const newObjectChip = {
                        id: chipId, value: chipId, x: rackPositions[i].x, y: rackPositions[i].y,
                        vx: 0, vy: 0, radius: objectChipRadius, inPlay: true,
                        color: chipColors[chipId], type: 'numbered', // Unified type for drawing
                        isPocketing: false, pocketingProgress: 0, pocketingHole: null,
                        rotation: 0, rotationSpeed: 0
                    };
                    chips.push(newObjectChip);
                }
            }
        }
        
        // =========================================================================
        // DRAWING FUNCTIONS
        // =========================================================================

        function drawTable() {
            ctx.fillStyle = '#1a1a1a';
            holes.forEach(hole => {
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            if (table.width > 0) {
                const fontSize = 60 * scale;
                ctx.font = `italic bold ${fontSize}px Georgia`;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.textBaseline = 'middle';
        
                const spotX = table.width * (gameMode.includes('61-ball') ? 0.75 : 0.7);
                const spotY = table.height / 2;
                const spotRadius = BALL_RADIUS * scale;
                
                ctx.lineWidth = 3.5 * scale;
                ctx.beginPath();
                ctx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
                ctx.stroke();
        
                const textPart1 = "P";
                const textPart2 = "ker";
                const spacing = 8 * scale;
        
                ctx.textAlign = 'right';
                ctx.fillText(textPart1, spotX - spotRadius - spacing, spotY);
        
                ctx.textAlign = 'left';
                ctx.fillText(textPart2, spotX + spotRadius + spacing, spotY);
                
                const pMetrics = ctx.measureText(textPart1);
                const kerMetrics = ctx.measureText(textPart2);
                const pokerWidth = pMetrics.width + (spacing * 2) + (spotRadius * 2) + kerMetrics.width;
                const pokerCenterX = (spotX - spotRadius - spacing - pMetrics.width) + (pokerWidth / 2);
        
                ctx.font = `italic bold ${fontSize * 1.2}px Georgia`;
                ctx.textAlign = 'center';
                ctx.fillText("Pinoy Pool", pokerCenterX, spotY - fontSize * 1.3);
            }
        }
        
        function drawChips() {
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 6 * scale;
            ctx.shadowOffsetX = 3 * scale;
            ctx.shadowOffsetY = 4 * scale;
        
            chips.forEach(chip => {
                if (chip.inPlay) {
                    let displayRadius = chip.radius;
                    if (chip.isPocketing) {
                        displayRadius *= (1 - chip.pocketingProgress);
                    }
        
                    ctx.save();
                    ctx.translate(chip.x, chip.y);
                    
                    if (chip.isPocketing) {
                        ctx.rotate(chip.rotation);
                    }
        
                    if (chip.id === 0) { // Cue Chip
                        ctx.beginPath();
                        ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 2 * scale;
                        ctx.beginPath();
                        ctx.arc(0, 0, displayRadius * 0.8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, displayRadius * 0.5, 0, Math.PI * 2);
                        ctx.stroke();
                         ctx.beginPath();
                        ctx.arc(0, 0, displayRadius * 0.2, 0, Math.PI * 2);
                        ctx.fillStyle = '#000000';
                        ctx.fill();
                    } else { // Object Chips (Unified Design)
                        // Gold border
                        ctx.beginPath();
                        ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = 1 * scale;
                        ctx.stroke();

                        // Colored center
                        const innerRadius = displayRadius * 0.85;
                        ctx.beginPath();
                        ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                        ctx.fillStyle = chip.color;
                        ctx.fill();
                        
                        // Number Text (if chip has an ID)
                        if(chip.id) {
                            ctx.fillStyle = 'white';
                            ctx.font = `bold ${innerRadius * 1.5}px Arial, sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0,0,0,0.5)';
                            ctx.shadowBlur = 2 * scale;
                            ctx.shadowOffsetX = 1 * scale;
                            ctx.shadowOffsetY = 1 * scale;
                            ctx.fillText(chip.id, 0, 2 * scale);
                        }
                    }
                    
                    // Shine effect for all chips
                    const shineGradient = ctx.createLinearGradient(0, -displayRadius, 0, displayRadius);
                    shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.35)');
                    shineGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.1)');
                    shineGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = shineGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);
                    ctx.fill();
        
                    const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
                    if (chip.id === 0 && gameState === 'aiming' && isMyTurn) {
                        const dotX = pektusOffset.x * displayRadius * 0.7;
                        const dotY = pektusOffset.y * displayRadius * 0.7;
                        ctx.beginPath();
                        ctx.arc(dotX, dotY, displayRadius * 0.15, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                        ctx.lineWidth = 1 * scale;
                        ctx.fill();
                        ctx.stroke();
                    }
                    
                    if (isDraggingCueBall && chip.id === 0 && isInvalidPlacement) {
                        ctx.font = `bold ${chip.radius * 1.8}px Arial`;
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🚫', 0, 0);
                    }
        
                    ctx.restore();
                }
            });
        
            ctx.shadowColor = 'transparent';
        }


        function drawCueStick() {
            if (!cueStick.visible || !chips[0] || !chips[0].inPlay) return;
            const cueChip = chips[0];

            ctx.save();
            ctx.translate(cueChip.x, cueChip.y);
            ctx.rotate(cueStick.angle);

            const stickOffset = 15 * scale;
            const stickHeight = 200 * scale;
            const stickDrawStart = -(cueChip.radius + stickOffset + cueStick.length) - cueStick.pullback;

            if (cueStickImage.complete && cueStickImage.naturalHeight !== 0) {
                ctx.drawImage(
                    cueStickImage,
                    stickDrawStart,
                    -stickHeight / 2,
                    cueStick.length,
                    stickHeight
                );
            } else {
                ctx.beginPath();
                ctx.moveTo(stickDrawStart + cueStick.length, 0);
                ctx.lineTo(stickDrawStart, 0);
                ctx.strokeStyle = '#a0522d';
                ctx.lineWidth = 5 * scale;
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawGuidelines() {
            if (gameState !== 'aiming' || chipsMoving) return;
            
            const cueChip = chips[0];
            if (!cueChip || !cueChip.inPlay) return;

            const angle = cueStick.angle;
            const shotVector = { x: Math.cos(angle), y: Math.sin(angle) };
            let firstHit = null;
            let minCollisionDist = Infinity;

            for (const targetChip of chips) {
                if (targetChip.id === 0 || !targetChip.inPlay) continue;
                const cueToTarget = { x: targetChip.x - cueChip.x, y: targetChip.y - cueChip.y };
                const projDist = cueToTarget.x * shotVector.x + cueToTarget.y * shotVector.y;
                if (projDist <= 0) continue;
                const closestPointOnPath = { x: cueChip.x + projDist * shotVector.x, y: cueChip.y + projDist * shotVector.y };
                const perpDistSq = (closestPointOnPath.x - targetChip.x)**2 + (closestPointOnPath.y - targetChip.y)**2;
                const combinedRadiusSq = (cueChip.radius + targetChip.radius)**2;
                if (perpDistSq >= combinedRadiusSq) continue;
                const travelDist = projDist - Math.sqrt(combinedRadiusSq - perpDistSq);
                if (travelDist < minCollisionDist) {
                    minCollisionDist = travelDist;
                    firstHit = { chip: targetChip, travelDist: travelDist };
                }
            }
            
            ctx.setLineDash([5 * scale, 5 * scale]);
            ctx.lineWidth = 2.0 * scale; 

            if (firstHit) {
                const impactPoint = { x: cueChip.x + firstHit.travelDist * shotVector.x, y: cueChip.y + firstHit.travelDist * shotVector.y };
                
                // Draw line from cue ball to impact point
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.moveTo(cueChip.x, cueChip.y);
                ctx.lineTo(impactPoint.x, impactPoint.y);
                ctx.stroke();

                // Draw the ghost cue ball at the impact point
                ctx.globalAlpha = 0.5; 
                ctx.beginPath();
                ctx.arc(impactPoint.x, impactPoint.y, cueChip.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700'; 
                ctx.fill();
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2 * scale;
                ctx.setLineDash([]); 
                ctx.stroke();
                ctx.globalAlpha = 1.0; 
                
                // Draw line for the object chip's path
                const objectChip = firstHit.chip;
                const collisionNormal = { x: objectChip.x - impactPoint.x, y: objectChip.y - impactPoint.y };
                const normMag = Math.sqrt(collisionNormal.x**2 + collisionNormal.y**2);
                const unitNormal = { x: collisionNormal.x / normMag, y: collisionNormal.y / normMag };
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.setLineDash([5 * scale, 5 * scale]); 
                ctx.beginPath();
                ctx.moveTo(objectChip.x, objectChip.y);
                ctx.lineTo(objectChip.x + unitNormal.x * 41, objectChip.y + unitNormal.y * 41);
                ctx.stroke();
                
                const tangentVector = { x: -unitNormal.y, y: unitNormal.x };
                if (tangentVector.x * shotVector.x + tangentVector.y * shotVector.y < 0) {
                    tangentVector.x *= -1;
                    tangentVector.y *= -1;
                }
                const sideSpinAngle = pektusOffset.x * 1.5;
                const followFactor = 1 - (pektusOffset.y * 0.8);
                const deflectedCueVector = {
                    x: tangentVector.x * Math.cos(sideSpinAngle) - tangentVector.y * Math.sin(sideSpinAngle),
                    y: tangentVector.x * Math.sin(sideSpinAngle) + tangentVector.y * Math.cos(sideSpinAngle)
                };
                const finalCueVector = {
                    x: (deflectedCueVector.x * 0.7 + shotVector.x * 0.3) * followFactor,
                    y: (deflectedCueVector.y * 0.7 + shotVector.y * 0.3) * followFactor
                };
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.moveTo(impactPoint.x, impactPoint.y);
                ctx.lineTo(impactPoint.x + finalCueVector.x * 2000, impactPoint.y + finalCueVector.y * 2000);
                ctx.stroke();

                // --- Wrong Target Indicator ---
                let isWrongTarget = false;
                const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
                if (isMyTurn) {
                    if (gameMode.includes('straight-ball') && colorsAssigned && playerChipsType) {
                        if (firstHit.chip.type !== playerChipsType) {
                            isWrongTarget = true;
                        }
                    } else if (gameMode.includes('61-ball') && lowestChipNumber > 0) {
                        if (firstHit.chip.id !== lowestChipNumber) {
                            isWrongTarget = true;
                        }
                    }
                }

                if (isWrongTarget) {
                    ctx.save();
                    ctx.font = `bold ${firstHit.chip.radius * 2}px Arial`;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 5 * scale;
                    ctx.fillText('🚫', firstHit.chip.x, firstHit.chip.y);
                    ctx.restore();
                }
                // --- END: Wrong Target Indicator ---

            } else {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.moveTo(cueChip.x, cueChip.y);
                ctx.lineTo(cueChip.x + shotVector.x * 2000, cueChip.y + shotVector.y * 2000);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        // =========================================================================
        // PHYSICS & COLLISION
        // =========================================================================
        
        function updateChipPositions() {
            const subSteps = 8;
            for (let i = 0; i < subSteps; i++) {
                chips.forEach(chip => { if (chip.inPlay && !chip.isPocketing) { chip.x += chip.vx/subSteps; chip.y += chip.vy/subSteps; }});
                for (let j = 0; j < chips.length; j++) {
                    const chip1 = chips[j];
                    if (!chip1.inPlay || chip1.isPocketing) continue;
                    if (chip1.x + chip1.radius > table.width) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = table.width - chip1.radius; }
                    if (chip1.x - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = chip1.radius; }
                    if (chip1.y + chip1.radius > table.height) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = table.height - chip1.radius; }
                    if (chip1.y - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = chip1.radius; }
                    for (let k = j + 1; k < chips.length; k++) {
                        const chip2 = chips[k];
                        if (chip2.inPlay && !chip2.isPocketing) handleChipCollision(chip1, chip2);
                    }
                }
            }

            let stillMoving = false;
            chips.forEach(chip => {
                if (chip.inPlay) {
                    if (chip.isPocketing) {
                        chip.pocketingProgress += 0.05; chip.rotation += chip.rotationSpeed;
                        chip.x += (chip.pocketingHole.x - chip.x) * 0.1; chip.y += (chip.pocketingHole.y - chip.y) * 0.1;
                        if (chip.pocketingProgress >= 1) { chip.inPlay = false; chip.isPocketing = false; }
                    } else {
                        chip.vx *= FRICTION; chip.vy *= FRICTION;
                        if (Math.abs(chip.vx) < MIN_VELOCITY) chip.vx = 0;
                        if (Math.abs(chip.vy) < MIN_VELOCITY) chip.vy = 0;
                        holes.forEach(hole => {
                            if (Math.sqrt((hole.x - chip.x)**2 + (hole.y - chip.y)**2) < hole.radius) {
                                playPocketSound();
                                chip.isPocketing = true; chip.pocketingHole = hole; chip.rotationSpeed = (Math.random() - 0.5) * 0.2;
                                chip.vx = 0; chip.vy = 0;
                                if (!chipsPocketedInTurn.find(p => p.id === chip.id)) chipsPocketedInTurn.push(chip);
                            }
                        });
                    }
                    if (chip.vx !== 0 || chip.vy !== 0 || chip.isPocketing) stillMoving = true;
                }
            });
            
            chipsMoving = stillMoving;
            if (!chipsMoving) {
                if (gameState === 'shooting') {
                    gameState = 'evaluating';
                    if (!isOnlineGame || localPlayerUid === lastTurnControllerUid) {
                        setTimeout(handleTurnEnd, 200);
                    }
                }
            }
        }

        function handleChipCollision(chip1, chip2) {
            const dx = chip2.x - chip1.x, dy = chip2.y - chip1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const combinedRadius = chip1.radius + chip2.radius;
            if (dist < combinedRadius) {
                const impactSpeed = Math.sqrt((chip1.vx - chip2.vx)**2 + (chip1.vy - chip2.vy)**2);
                if (impactSpeed > 0.1) playCollisionSound(impactSpeed);
                if (firstChipHitInTurn === null) {
                    if (chip1.id === 0) firstChipHitInTurn = chip2;
                    else if (chip2.id === 0) firstChipHitInTurn = chip1;
                }
                const angle = Math.atan2(dy, dx), sin = Math.sin(angle), cos = Math.cos(angle);
                let vel1 = { x: chip1.vx * cos + chip1.vy * sin, y: chip1.vy * cos - chip1.vx * sin };
                let vel2 = { x: chip2.vx * cos + chip2.vy * sin, y: chip2.vy * cos - chip2.vx * sin };
                const vxTotal = vel1.x - vel2.x;
                vel1.x = ((chip1.radius - chip2.radius) * vel1.x + 2 * chip2.radius * vel2.x) / combinedRadius;
                vel2.x = vxTotal + vel1.x;
                const overlap = combinedRadius - dist;
                chip1.x -= (overlap / 2) * cos; chip1.y -= (overlap / 2) * sin;
                chip2.x += (overlap / 2) * cos; chip2.y += (overlap / 2) * sin;
                if (chip1.id === 0 || chip2.id === 0) {
                    const sideSpin = shotPektusOffset.x * 0.5;
                    vel1.y += sideSpin * Math.abs(vxTotal);
                    if (shotPektusOffset.y < 0) {
                        const followEnergy = Math.abs(vel1.x * shotPektusOffset.y * 0.2);
                        vel1.x += followEnergy; vel2.x -= followEnergy;
                    }
                }
                chip1.vx = vel1.x * cos - vel1.y * sin; chip1.vy = vel1.y * cos + vel1.x * sin;
                chip2.vx = vel2.x * cos - vel2.y * sin; 
                chip2.vy = vel2.y * cos + vel2.x * sin;
            }
        }
        
        // =========================================================================
        // GAME LOGIC
        // =========================================================================

        function showMessage(msg, duration = 2000) {
            messageBox.textContent = msg;
            messageBox.style.display = 'block';
            setTimeout(() => { if (messageBox.textContent === msg) messageBox.style.display = 'none'; }, duration);
        }

        function resetChipStateForReturn(chip) {
            if (!chip) return;
            chip.inPlay = true;
            chip.isPocketing = false;
            chip.pocketingProgress = 0;
            chip.pocketingHole = null;
            chip.vx = 0;
            chip.vy = 0;
        }

                function startGame(mode, difficultyLevel = 'easy') {
            resizeCanvas(); 
            
            const allModals = [gameModeSelect, aiMenu, difficultySelect, straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, pokerFoulCardPickModal, leaderboardModal];
            allModals.forEach(modal => modal.style.display = 'none');
            gameMode = mode; isOnlineGame = false; difficulty = difficultyLevel;
            cueBallGuide.style.display = 'none'; 
            playerTurn = Math.random() < 0.5;
            canMoveCueBall = false; chipsMoving = false; colorsAssigned = false; 
            playerChipsType = null; opponentChipsType = null;
            setupChips();
            isBreakShot = true; canMoveCueBall = true; gameState = 'moving';
            cueStick.visible = true;
            
            if (playerTurn) {
                showMessage("You break! Place the cue ball.", 3000);
                // TAMANG LOGIC PARA SA SARGO
                dragGuideText.style.display = 'block'; 
            } else { 
                showMessage("Opponent breaks!", 3000); 
                placeCueChipForAI(); 
            }

            resetPektus();
            if (gameMode.includes('poker')) { createDeck(); dealCards(); updateCardDisplay(); } 
            else if (gameMode.includes('61-ball')) {
                player61Score = 0; opponent61Score = 0; lowestChipNumber = 1;
                cardHandContainer.style.display = 'none';
            }
            else cardHandContainer.style.display = 'none';
            updateInfoBox(); history.pushState({ modal: 'game' }, 'Game', '#game');
        }


        // =========================================================================
        // TURN LOGIC - DUAL MODE
        // =========================================================================
        async function handleTurnEnd() {
            if (isOnlineGame && lastTurnControllerUid !== localPlayerUid) {
                 return;
            }
            if (isProcessingTurnEnd) return;
            isProcessingTurnEnd = true;
            if (gameMode.includes('poker')) await handlePokerTurnEnd();
            else if (gameMode.includes('straight-ball')) await handleStraightBallTurnEnd();
            else if (gameMode.includes('61-ball')) await handle61BallTurnEnd();
            isProcessingTurnEnd = false;
        }
        
        // =========================================================================
        // 61 BALL TURN LOGIC
        // =========================================================================
                                // =========================================================================
        // 61 BALL TURN LOGIC
        // =========================================================================
        async function handle61BallTurnEnd() {
            let foul = false;
            let switchTurn = true;
            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);
            const lowestChipOnTable = lowestChipNumber;
            const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0);
            const didHitWrongBallFirst = !isBreakShot && firstChipHitInTurn && firstChipHitInTurn.id !== lowestChipOnTable;
            const didNotHitAnyBall = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0);

            if (wasCueBallPocketed || didHitWrongBallFirst || didNotHitAnyBall) {
                foul = true;
            }

            if (foul) {
                switchTurn = true;
                canMoveCueBall = true;
                const nextPlayerIsHuman = (!playerTurn && switchTurn) || (playerTurn && !switchTurn);
                if (nextPlayerIsHuman) {
                    dragGuideText.style.display = 'block';
                }
                if (wasCueBallPocketed) {
                    const cueChip = chips.find(c => c.id === 0);
                    if (cueChip) {
                        resetChipStateForReturn(cueChip);
                        cueChip.x = table.width * 0.25;
                        cueChip.y = table.height / 2;
                    }
                }
                if (pocketedObjectChips.length > 0) {
                    pocketedObjectChips.forEach(chip => {
                        const chipToReturn = chips.find(c => c.id === chip.id);
                        if (chipToReturn) {
                            resetChipStateForReturn(chipToReturn);
                            placeChipOnSpot(chipToReturn);
                        }
                    });
                }
                if (isMyTurn) showMessage("Foul! Chips returned.", 2500);
            } else {
                if (pocketedObjectChips.length > 0) {
                    const pointsThisTurn = pocketedObjectChips.reduce((sum, chip) => sum + chip.value, 0);
                    if (isMyTurn) player61Score += pointsThisTurn;
                    else opponent61Score += pointsThisTurn;
                    switchTurn = false;
                } else {
                    switchTurn = true;
                }
            }

            const newRemainingChips = chips.filter(c => c.inPlay && c.id !== 0);
            lowestChipNumber = newRemainingChips.length > 0 ? Math.min(...newRemainingChips.map(c => c.id)) : 0;
            const winner = checkWinCondition();
            if (winner) {
                const winnerText = (winner === 'player') ? 'You Win!' : (winner === 'opponent' ? 'You Lose!' : "It's a Draw! 60-60");
                await endGame(winnerText);
                return;
            }
            isBreakShot = false;
            if (isOnlineGame) await updateOnlineGameState(switchTurn);
            else updateLocalGameState(switchTurn);
        }

        // =========================================================================
        // POKER TURN LOGIC
        // =========================================================================
        function waitForCardPick() {
            return new Promise(resolve => {
                pokerFoulCardPickModal.style.display = 'flex';
                pokerFoulCardsContainer.innerHTML = '';
                const cardsToDraw = [];
                for (let i = 0; i < 5; i++) if (deck.length > 0) cardsToDraw.push(deck.splice(Math.floor(Math.random() * deck.length), 1)[0]);
                if (cardsToDraw.length === 0) { pokerFoulCardPickModal.style.display = 'none'; resolve(null); return; }
                cardsToDraw.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card face-down';
                    cardDiv.onclick = () => {
                        playButtonSound();
                        cardDiv.classList.remove('face-down');
                        const color = (card.suit === '♥' || card.suit === '♦') ? '#ff5555' : 'white';
                        cardDiv.innerHTML = `<span class="card-rank" style="color: ${color};">${card.rank}</span><span class="card-suit" style="color: ${color};">${card.suit}</span>`;
                        pokerFoulCardsContainer.querySelectorAll('.card').forEach(c => { c.onclick = null; c.style.cursor = 'default'; });
                        setTimeout(() => {
                            pokerFoulCardPickModal.style.display = 'none';
                            cardsToDraw.forEach(c => { if (c !== card) deck.push(c); });
                            resolve(card);
                        }, 1500);
                    };
                    pokerFoulCardsContainer.appendChild(cardDiv);
                });
            });
        }
        
        async function handlePokerTurnEnd() {
            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            const currentHand = isMyTurn ? playerHand : opponentHand;
            const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);
            const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0);
            const didHitNothing = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0);
            const legallyPocketedOwnChips = pocketedObjectChips.filter(chip => currentHand.some(card => card.value === chip.id));
            const illegallyPocketedChips = pocketedObjectChips.filter(chip => !currentHand.some(card => card.value === chip.id));
            let switchTurn = true;
            let foul = wasCueBallPocketed || didHitNothing;

            if (legallyPocketedOwnChips.length > 0 && illegallyPocketedChips.length === 0 && !foul) {
                switchTurn = false;
            }
            
            if (pocketedObjectChips.length > 0) {
                const pocketedIds = pocketedObjectChips.map(c => c.id);
                playerHand = playerHand.filter(card => !pocketedIds.includes(card.value));
                opponentHand = opponentHand.filter(card => !pocketedIds.includes(card.value));
            }

            if (foul) {
                canMoveCueBall = true;
                const nextPlayerIsHuman = (!playerTurn && switchTurn) || (playerTurn && !switchTurn);
                if (nextPlayerIsHuman) {
                    dragGuideText.style.display = 'block';
                }
                if (wasCueBallPocketed) {
                    const cueChip = chips.find(c => c.id === 0);
                    if (cueChip) {
                        resetChipStateForReturn(cueChip);
                        cueChip.x = table.width * 0.25;
                        cueChip.y = table.height / 2;
                    }
                    if(isMyTurn) showMessage("Foul! You scratched.", 3000);
                    let newCard = isMyTurn ? await waitForCardPick() : (deck.length > 0 ? deck.splice(Math.floor(Math.random() * deck.length), 1)[0] : null);
                    if (newCard) {
                        const cardName = `${newCard.rank}${newCard.suit}`;
                        const correspondingChip = chips.find(c => c.id === newCard.value);
                        if (correspondingChip && !correspondingChip.inPlay) {
                             if (isMyTurn) showMessage(`You picked ${cardName}, but it was pocketed. Card discarded.`, 3000);
                        } else {
                            (isMyTurn ? playerHand : opponentHand).push(newCard);
                            if (isMyTurn) showMessage(`Foul! You picked ${cardName}.`, 3000);
                        }
                        if (playerHand.length === 1 && newCard.rank === 'K' && wasCueBallPocketed && legallyPocketedOwnChips.length > 0) {
                            await endGame('You Win on a Lucky Scratch!', playerHand, opponentHand);
                            return;
                        }
                    }
                }
            }
            
            const winner = checkWinCondition();
            if (winner) {
                const winnerText = (winner === 'player') ? 'You Win!' : 'You Lose!';
                await endGame(winnerText, playerHand, opponentHand);
                return;
            }
            isBreakShot = false;
            if (isOnlineGame) await updateOnlineGameState(switchTurn);
            else updateLocalGameState(switchTurn);
        }

        // =========================================================================
        // STRAIGHT BALL TURN LOGIC
        // =========================================================================
        async function handleStraightBallTurnEnd() {
            let foul = false, switchTurn = true, foulReason = "";
            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);
            const currentPlayerColor = isMyTurn ? playerChipsType : opponentChipsType;
            const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0);
            const didHitWrongBallFirst = !isBreakShot && colorsAssigned && firstChipHitInTurn && firstChipHitInTurn.type !== currentPlayerColor;
            const didNotHitAnyBall = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0);

            if (wasCueBallPocketed || didHitWrongBallFirst || didNotHitAnyBall) {
                foul = true;
            }

            if (pocketedObjectChips.length > 0) {
                if (!colorsAssigned && !foul) {
                    const firstPocketed = pocketedObjectChips[0];
                    if (isMyTurn) {
                        playerChipsType = firstPocketed.type;
                        opponentChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
                    } else {
                        opponentChipsType = firstPocketed.type;
                        playerChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
                    }
                    colorsAssigned = true;
                    if (isMyTurn) showMessage(`Colors assigned! You are ${playerChipsType}.`, 3000);
                }
                const myPocketedCount = pocketedObjectChips.filter(c => c.type === (isMyTurn ? playerChipsType : opponentChipsType)).length;
                const opponentPocketedCount = pocketedObjectChips.filter(c => c.type === (isMyTurn ? opponentChipsType : playerChipsType)).length;
                if (!foul && myPocketedCount > 0 && opponentPocketedCount === 0) {
                    switchTurn = false;
                }
            }

            if (foul) {
                switchTurn = true;
                canMoveCueBall = true;
                const nextPlayerIsHuman = (!playerTurn && switchTurn) || (playerTurn && !switchTurn);
                if (nextPlayerIsHuman) {
                    dragGuideText.style.display = 'block';
                }
                if (wasCueBallPocketed) {
                    foulReason += "Cue ball pocketed! ";
                    const cueChip = chips.find(c => c.id === 0);
                    if (cueChip) {
                        resetChipStateForReturn(cueChip);
                        cueChip.x = table.width * 0.25;
                        cueChip.y = table.height / 2;
                    }
                    const foulingPlayerColor = isMyTurn ? playerChipsType : opponentChipsType;
                    if (foulingPlayerColor) {
                        const chipToReturn = chips.find(c => c.type === foulingPlayerColor && !c.inPlay && !chipsPocketedInTurn.some(p => p.id === c.id));
                        if (chipToReturn) {
                            resetChipStateForReturn(chipToReturn);
                            placeChipOnSpot(chipToReturn);
                            foulReason += "One of your balls was returned.";
                        }
                    }
                }
                if (didHitWrongBallFirst) {
                    foulReason += "Hit opponent's ball first. ";
                    const myPocketedInFoul = pocketedObjectChips.filter(c => c.type === currentPlayerColor);
                    if (myPocketedInFoul.length > 0) {
                        foulReason += "Your pocketed balls are returned.";
                        myPocketedInFoul.forEach(pc => {
                            const foundChip = chips.find(c => c.id === pc.id);
                            if (foundChip) {
                                resetChipStateForReturn(foundChip);
                                placeChipOnSpot(foundChip);
                            }
                        });
                    }
                }
                if (didNotHitAnyBall) foulReason += "No object ball was hit. ";
            }
            
            if (foulReason && isMyTurn) showMessage("Foul! " + foulReason.trim(), 4000);
            const winner = checkWinCondition();
            if (winner) {
                await endGame((winner === 'player') ? 'You Win!' : 'You Lose!');
                return;
            }
            isBreakShot = false;
            if (isOnlineGame) await updateOnlineGameState(switchTurn);
            else updateLocalGameState(switchTurn);
        }



        async function updateOnlineGameState(switchTurn) {
            try {
                const gameDocRef = doc(db, "games", gameId);
                const docSnap = await getDoc(gameDocRef);
                if (!docSnap.exists() || docSnap.data().gameState === 'finished') return;

                let nextTurnUid = docSnap.data().currentTurnUid;
                if (switchTurn) {
                    nextTurnUid = (nextTurnUid === docSnap.data().players.player1.uid) ? docSnap.data().players.player2.uid : docSnap.data().players.player1.uid;
                }
                
                const chipsToSend = chips.map(c => ({...c, x: c.x / table.width, y: c.y / table.height }));
                const newTurnId = (docSnap.data().turnId || 0) + 1;

                const updatedData = { 
                    chips: chipsToSend, 
                    currentTurnUid: nextTurnUid, 
                    canMoveCueBall, 
                    isBreakShot: false, 
                    turnInProgress: false,
                    turnId: newTurnId, 
                    liveAimData: null 
                };

                if (gameMode.includes('poker')) {
                    const hands = (localPlayerId === 'player1') ? { player1Hand: playerHand, player2Hand: opponentHand } : { player1Hand: opponentHand, player2Hand: playerHand };
                    Object.assign(updatedData, { deck }, hands);
                } else if (gameMode.includes('straight-ball')) {
                    const types = (localPlayerId === 'player1') ? { player1ChipsType: playerChipsType, player2ChipsType: opponentChipsType } : { player1ChipsType: opponentChipsType, player2ChipsType: playerChipsType };
                    Object.assign(updatedData, { colorsAssigned }, types);
                } else if (gameMode.includes('61-ball')) {
                    const scores = (localPlayerId === 'player1') ? { player1_61Score: player61Score, player2_61Score: opponent61Score } : { player1_61Score: opponent61Score, player2_61Score: player61Score };
                    Object.assign(updatedData, { lowestChipNumber }, scores);
                }

                await updateDoc(gameDocRef, updatedData);
            } catch (error) { console.error("Error updating game state:", error); showMessage("Connection error.", 3000); }
        }

                function updateLocalGameState(switchTurn) {
            if (switchTurn) {
                playerTurn = !playerTurn;
                if (playerTurn) { // Ngayong turn na ng player, i-reset ang counter ng AI
                    aiConsecutivePots = 0;
                }
                showMessage(`${playerTurn ? 'Your' : 'Opponent'}'s turn`, 1500);
            } else {
                if (playerTurn) {
                    showMessage("You shoot again!", 1500);
                } else {
                    aiConsecutivePots++; // Naka-shoot ulit ang AI, dagdagan ang counter
                    showMessage("AI shoots again!", 1500);
                }
            }

            chipsPocketedInTurn = [];
            firstChipHitInTurn = null;
            resetPektus();
            updateCardDisplay();
            updateInfoBox();
            
            if (gameState !== 'gameover') {
                if (canMoveCueBall) {
                    gameState = 'moving';
                    if (gameMode.includes('ai') && !playerTurn) {
                        placeCueChipForAI();
                    }
                } else {
                    gameState = 'aiming';
                    cueStick.visible = true;
                    if (gameMode.includes('ai') && !playerTurn) {
                        setTimeout(aiTurn, 1000);
                    }
                }
            }
        }

        
        function checkWinCondition() {
            if (gameState === 'gameover') return null;
            let winner = null;
            if (gameMode.includes('poker')) {
                if (playerHand.length === 0 || (playerHand.length > 0 && playerHand.every(card => card.rank === 'K'))) winner = 'player';
                else if (opponentHand.length === 0 || (opponentHand.length > 0 && opponentHand.every(card => card.rank === 'K'))) winner = 'opponent';
            } else if (gameMode.includes('straight-ball') && colorsAssigned) {
                if (!chips.some(c => c.inPlay && c.type === playerChipsType) && playerChipsType) winner = 'player';
                else if (!chips.some(c => c.inPlay && c.type === opponentChipsType) && opponentChipsType) winner = 'opponent';
            } else if (gameMode.includes('61-ball')) {
                if (player61Score >= 61) winner = 'player';
                else if (opponent61Score >= 61) winner = 'opponent';
                else if (!chips.some(c => c.inPlay && c.id !== 0) && player61Score === 60 && opponent61Score === 60) winner = 'draw';
            }
            return winner;
        }

        async function shoot(shotPower) {
            if (gameState !== 'aiming' || chipsMoving) return;
        
            playCueHitSound((shotPower - 5) / 30);

            chipsPocketedInTurn = [];
            firstChipHitInTurn = null;
            shotPektusOffset = { ...pektusOffset };
            
            const shotData = { 
                uid: localPlayerUid, 
                angle: cueStick.angle, 
                power: shotPower, 
                pektus: shotPektusOffset, 
                timestamp: Date.now() 
            };
            
            cueStick.power = 0;
            powerBar.style.height = '0%';
            
            gameState = 'shooting_animation';
            let startTime = null;
            const animationDuration = 100;
            const startPullback = cueStick.pullback;
            const endPullback = -30 * scale;
            
            function animateLocalShot(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / animationDuration, 1);
                cueStick.pullback = startPullback + (endPullback - startPullback) * progress;
        
                if (progress < 1) {
                    requestAnimationFrame(animateLocalShot);
                } else {
                    cueStick.pullback = 0;
                    cueStick.visible = false;
                    if (isOnlineGame) {
                        try {
                            lastTurnControllerUid = localPlayerUid;
                            updateDoc(doc(db, "games", gameId), { lastShot: shotData, turnInProgress: true, lastTurnController: localPlayerUid });
                        } catch (error) {
                            console.error("Error sending shot data:", error);
                            gameState = 'aiming'; 
                            cueStick.visible = true;
                        }
                    } else {
                        applyShot(shotData);
                    }
                }
            }
            requestAnimationFrame(animateLocalShot);
        }
        
        function applyShot(shotData) {
            if (chipsMoving) return; 
            const cueChip = chips[0];
            if (!cueChip || !cueChip.inPlay) return;
            shotPektusOffset = shotData.pektus || { x: 0, y: 0 };
            cueChip.vx = Math.cos(shotData.angle) * shotData.power * scale;
            cueChip.vy = Math.sin(shotData.angle) * shotData.power * scale;
            chipsMoving = true; 
            gameState = 'shooting';
            if (isOnlineGame) {
                lastTurnControllerUid = shotData.uid;
            }
        }

        async function endGame(winnerTextMessage, finalPlayerHand, finalOpponentHand) {
            if (gameState === 'gameover') return;
            gameState = 'gameover';
            
            const rematchButton = document.getElementById('rematch-button');
            const playAgainButton = document.getElementById('play-again-button');

            if (isOnlineGame) {
                rematchButton.style.display = 'block';
                rematchButton.textContent = 'Rematch'; // I-reset ang text
                rematchButton.disabled = false; // I-reset ang button state
                playAgainButton.style.display = 'none';
            } else {
                rematchButton.style.display = 'none';
                playAgainButton.style.display = 'block';
            }

            const playerWonLocally = winnerTextMessage.includes('You Win');
            const pHand = finalPlayerHand || playerHand;
            const oHand = finalOpponentHand || opponentHand;

            if (isOnlineGame) {
                try {
                    const gameDocRef = doc(db, "games", gameId);
                    const docSnap = await getDoc(gameDocRef);
                    if (docSnap.exists() && docSnap.data().gameState !== 'finished') {
                        let winnerUid = null;
                        const { player1, player2 } = docSnap.data().players;
                        if (winnerTextMessage.includes('You Win')) {
                            winnerUid = localPlayerUid;
                        } else if (winnerTextMessage.includes('Lose') || winnerTextMessage.includes('Opponent')) {
                            winnerUid = localPlayerUid === player1.uid ? player2.uid : player1.uid;
                        }
                        
                        const finalPayload = {};
                        if (gameMode.includes('poker')) {
                            const hands = (localPlayerId === 'player1') 
                                ? { player1Hand: pHand, player2Hand: oHand } 
                                : { player1Hand: oHand, player2Hand: pHand };
                            Object.assign(finalPayload, hands);
                        }

                        if (winnerUid) {
                            await updateDoc(gameDocRef, { 
                                gameState: 'finished', 
                                winner: winnerUid, 
                                turnInProgress: false,
                                ...finalPayload
                            });
                        }
                        
                        if (winnerUid === localPlayerUid) await updatePlayerData(localPlayerUid, true);
                    }
                } catch (e) { console.error("Failed to process final game state:", e); }
            } else if (playerWonLocally) {
                await updatePlayerData(localPlayerUid, true);
            }

            let finalWinnerTextHTML = winnerTextMessage;
            if (gameMode.includes('61-ball')) {
                finalWinnerTextHTML += `<p style="font-size: 0.7em; color: #f0f0f0; margin-top: 20px; font-weight: normal;">Final Score<br>You: ${player61Score} - Opponent: ${opponent61Score}</p>`;
            }
            winnerText.innerHTML = finalWinnerTextHTML;

            if (gameMode.includes('poker')) {
                const opponentActualHand = oHand;
                const opponentActualOriginalHand = originalOpponentHand;

                const pocketedHandToShow = opponentActualOriginalHand.filter(oCard => 
                    !opponentActualHand.some(rCard => rCard.rank === oCard.rank && rCard.suit === oCard.suit)
                );
                
                const createCardDisplay = (title, hand) => {
                    if (!hand || hand.length === 0) return '';
                    let html = `<h3>${title}</h3><div style="display: flex; gap: 5px; justify-content: center;">`;
                    hand.forEach(card => {
                        const color = (card.suit === '♥' || card.suit === '♦') ? '#ff5555' : 'white';
                        html += `<div class="card" style="transform: scale(0.8);"><span class="card-rank" style="color: ${color};">${card.rank}</span><span class="card-suit" style="color: ${color};">${card.suit}</span></div>`;
                    });
                    return html + `</div>`;
                };
                opponentHandReveal.innerHTML = createCardDisplay("Opponent's Pocketed Cards:", pocketedHandToShow) + createCardDisplay("Opponent's Remaining Cards:", opponentActualHand);
            } else {
                opponentHandReveal.innerHTML = ''; 
            }
            
            winnerModal.style.display = 'flex';
            history.pushState({ modal: 'winner' }, 'Winner', '#winner');
        }

        async function handleRematchRequest() {
            if (!isOnlineGame || !gameId) return;

            const rematchButton = document.getElementById('rematch-button');
            rematchButton.disabled = true;
            rematchButton.textContent = 'Waiting for Opponent...';

            const gameDocRef = doc(db, "games", gameId);
            try {
                await updateDoc(gameDocRef, {
                    [`rematchRequest.${localPlayerUid}`]: true
                });
            } catch (error) {
                console.error("Error sending rematch request:", error);
                rematchButton.textContent = 'Error! Try Again';
                rematchButton.disabled = false;
            }
        }

        async function updatePlayerData(uid, didWin = false) {
            if (!uid || !didWin) return;
            const playerDocRef = doc(db, "players", uid);
            try {
                const playerDoc = await getDoc(playerDocRef);
                if (!playerDoc.exists() || !playerDoc.data().displayName) {
                    let displayName = localStorage.getItem('pinoyPoolPlayerName');
                    if (!displayName) {
                        displayName = prompt("Congratulations! Enter your name for the leaderboard:", "Player" + Math.floor(Math.random() * 1000));
                        if (!displayName || displayName.trim() === "") displayName = "Anonymous";
                        localStorage.setItem('pinoyPoolPlayerName', displayName);
                    }
                    await setDoc(playerDocRef, { 
                        displayName: displayName,
                        wins: increment(1),
                        lastPlayed: serverTimestamp() 
                    }, { merge: true });
                } else {
                    await updateDoc(playerDocRef, {
                        wins: increment(1),
                        lastPlayed: serverTimestamp()
                    });
                }
            } catch (error) { console.error("Error updating player data:", error); }
        }


        // =========================================================================
// == GOD-TIER AI v16 (KUMPLETONG BERSYON - SEPT 25, 2025) ==
// =========================================================================

/**
 * HELPER: Tinitingnan kung may bolang nakaharang sa isang linya. (VERSION 2 with SAFETY MARGIN)
 */
function isPathObstructed(startObj, endObj, ignoreChipIds = []) {
    const allObstacles = chips.filter(c => c.inPlay && !ignoreChipIds.includes(c.id));
    
    for (const obstacle of allObstacles) {
        // Kinakalkula ang distansya ng harang mula sa linya ng tira
        const dist = Math.abs((endObj.y - startObj.y) * obstacle.x - (endObj.x - startObj.x) * obstacle.y + endObj.x * startObj.y - endObj.y * startObj.x) / Math.hypot(endObj.y - startObj.y, endObj.x - startObj.x);
        
        // --- PUSO NG PAGBABAGO: ANG SAFETY MARGIN ---
        // Nagdaragdag tayo ng buffer para maging mas maingat ang AI.
        // Ituturing niyang harang ang isang bagay kahit hindi pa sila eksaktong magkadikit.
        const safetyMargin = 4 * scale; // Pwedeng taasan (e.g., 5 o 6) kung gusto mo siyang mas maging maingat pa.

        const effectiveRadius = obstacle.radius + (startObj.radius || 0) + safetyMargin;

        if (dist < effectiveRadius) {
            // Tinitingnan kung ang harang ay nasa pagitan ng bola at ng target
            const dotProduct = (obstacle.x - startObj.x) * (endObj.x - startObj.x) + (obstacle.y - startObj.y) * (endObj.y - startObj.y);
            const squaredLength = Math.pow(Math.hypot(endObj.x - startObj.x, endObj.y - startObj.y), 2);
            if (dotProduct > 0 && dotProduct < squaredLength) {
                return true; // May harang!
            }
        }
    }
    return false; // Malinis ang daan.
}

/**
 * HELPER: Tinitingnan kung mayroon bang kahit isang malinis na daan papunta sa mga legal na target.
 */
function isAnyDirectPathClear(cueChip, legalTargets) {
    if (!legalTargets || legalTargets.length === 0) return false;
    for (const target of legalTargets) {
        if (!isPathObstructed(cueChip, target, [])) return true;
    }
    return false;
}

/**
 * Sinusuri ang isang potensyal na tira at binibigyan ito ng score. (FINAL VERSION with VIRTUAL AI TARGET)
 */
function evaluateShot(cueChip, targetChip, hole, allLegalTargets, difficulty, isCombination = false) {
    let firstContactTarget = isCombination ? allLegalTargets[0] : targetChip;
    if (!firstContactTarget) return null;

    const cushionSize = 38 * scale;
    const aiTargetHole = {
        x: (hole.x < table.width / 2) ? cushionSize : table.width - cushionSize,
        y: (hole.y < table.height / 2) ? cushionSize : table.height - cushionSize
    };

    let shotAngle;
    if (isCombination) {
        const impactAngle1 = Math.atan2(aiTargetHole.y - targetChip.y, aiTargetHole.x - targetChip.x);
        const pfm = { x: targetChip.x - Math.cos(impactAngle1) * (firstContactTarget.radius + targetChip.radius), y: targetChip.y - Math.sin(impactAngle1) * (firstContactTarget.radius + targetChip.radius) };
        const impactAngle2 = Math.atan2(pfm.y - firstContactTarget.y, pfm.x - firstContactTarget.x);
        const gbfc = { x: firstContactTarget.x - Math.cos(impactAngle2) * (cueChip.radius + firstContactTarget.radius), y: firstContactTarget.y - Math.sin(impactAngle2) * (cueChip.radius + firstContactTarget.radius) };
        shotAngle = Math.atan2(gbfc.y - cueChip.y, gbfc.x - cueChip.x);
    } else {
        const targetToHoleAngle = Math.atan2(aiTargetHole.y - targetChip.y, aiTargetHole.x - targetChip.x);
        const ghostBall = {
            x: targetChip.x - Math.cos(targetToHoleAngle) * (cueChip.radius + targetChip.radius),
            y: targetChip.y - Math.sin(targetToHoleAngle) * (cueChip.radius + targetChip.radius)
        };
        shotAngle = Math.atan2(ghostBall.y - cueChip.y, ghostBall.x - cueChip.x);
    }
    
    const path1Clear = !isPathObstructed(cueChip, firstContactTarget, [targetChip.id]);
    const path2Clear = !isPathObstructed(targetChip, hole, [cueChip.id, firstContactTarget.id]);
    let path3Clear = !isCombination || !isPathObstructed(firstContactTarget, targetChip, [cueChip.id]);
    
    if (!path1Clear || !path2Clear || !path3Clear) return null;
    
    const distance = Math.hypot(firstContactTarget.x - cueChip.x, firstContactTarget.y - cueChip.y);
    const lineToTargetCenterAngle = Math.atan2(firstContactTarget.y - cueChip.y, firstContactTarget.x - cueChip.x);
    const cutAngle = shotAngle - lineToTargetCenterAngle;
    
    const anglePenalty = (Math.abs(cutAngle) / (Math.PI / 2)) * 0.7;
    const distancePenalty = (distance / table.width) * 0.5;
    let probability = 1.0 - distancePenalty - anglePenalty;
    if (isCombination) probability *= 0.6;

    let pocketingScore = 1000;
    if (gameMode.includes('61-ball')) {
        pocketingScore += targetChip.value * 20;
    }

    const power = Math.min(1.2, (distance / (table.width * 0.5)) + 0.3);
    const predictedCuePos = predictSimpleCuePos(cueChip, firstContactTarget, shotAngle, power);
    let positionalScore = calculatePositionalScore(predictedCuePos, targetChip.id, allLegalTargets);
    
    let positionalMultiplier = 1.0;
    if (difficulty === 'easy') positionalMultiplier = 0.2; 
    else if (difficulty === 'hard') positionalMultiplier = 0.6;
    
    const totalScore = (pocketingScore + (positionalScore * positionalMultiplier)) * Math.max(0, probability);
    
    return { angle: shotAngle, power, score: totalScore, probability: Math.max(0, probability), target: targetChip, hole: hole, firstContactTarget: firstContactTarget, isCombination };
}

/**
 * PANGUNAHING AI FUNCTION (REWRITTEN "Simple First" Logic)
 */
        /**
         * PANGUNAHING AI FUNCTION (FINAL VERSION with "Killer Instinct")
         */
        function aiTurn() {
            if (gameState !== 'aiming' || chipsMoving || !chips[0]?.inPlay) return;
            const cueChip = chips[0];
            let allLegalTargets = [], allPocketableChips = [];
            
            if (gameMode.includes('poker')) {
                allLegalTargets = chips.filter(c => c.inPlay && opponentHand.some(card => card.value === c.id));
                allPocketableChips = allLegalTargets;
            } else if (gameMode.includes('61-ball')) {
                const lowestChip = chips.find(c => c.id === lowestChipNumber);
                if (!lowestChip) { setTimeout(handleTurnEnd, 500); return; }
                allLegalTargets = [lowestChip];
                allPocketableChips = chips.filter(c => c.inPlay && c.id !== 0);
            } else {
                if (colorsAssigned && opponentChipsType) allLegalTargets = chips.filter(c => c.inPlay && c.type === opponentChipsType);
                else allLegalTargets = chips.filter(c => c.inPlay && (c.type === 'red' || c.type === 'blue'));
                allPocketableChips = allLegalTargets;
            }

            let simplePots = [];
            let complexShots = [];

            for (const target of allLegalTargets) {
                for (const hole of holes) {
                    const evaluation = evaluateShot(cueChip, target, hole, allLegalTargets, difficulty, false);
                    if (evaluation) simplePots.push(evaluation);
                }
            }

            if (gameMode.includes('61-ball')) {
                for (const target of allPocketableChips.filter(c => c.id !== allLegalTargets[0].id)) {
                    for (const hole of holes) {
                        const evaluation = evaluateShot(cueChip, target, hole, allLegalTargets, difficulty, true);
                        if (evaluation) complexShots.push(evaluation);
                    }
                }
            }

            const allPossibleShots = [...simplePots, ...complexShots];
            if (allPossibleShots.length === 0) {
                let bestShot = findBestDefensiveShot(cueChip, allLegalTargets);
                if (!bestShot) {
                     const finalTarget = allLegalTargets[0] || allPocketableChips[0];
                     if (finalTarget) {
                         bestShot = { angle: Math.atan2(finalTarget.y - cueChip.y, finalTarget.x - cueChip.x), power: 0.4, probability: 0.5 };
                     } else {
                         setTimeout(handleTurnEnd, 500); return;
                     }
                }
                animateAiAiming(bestShot.angle, bestShot.power);
                return;
            }

            // --- PUSO NG KILLER INSTINCT LOGIC ---
            let bestShot;

            if (difficulty === 'pro') {
                // Ang PRO AI ay laging hahanapin ang "best possible score" sa LAHAT ng tira.
                // Hindi siya maglalaro ng safe. Ito ang kanyang killer instinct para sa run-out.
                bestShot = allPossibleShots.reduce((best, current) => (current.score > best.score) ? current : best, { score: -Infinity });
            } else {
                // Ang HARD at EASY ay uunahin pa rin ang mga madaling tira.
                const HIGH_PROBABILITY_THRESHOLD = 0.80;
                const decentSimplePots = simplePots.filter(p => p.probability >= HIGH_PROBABILITY_THRESHOLD);

                if (decentSimplePots.length > 0) {
                    bestShot = decentSimplePots.reduce((best, current) => (current.score > best.score) ? current : best);
                } else {
                    bestShot = allPossibleShots.reduce((best, current) => (current.score > best.score) ? current : best);
                }
            }

            // --- DYNAMIC ERROR MARGIN LOGIC (para sa HARD AI) ---
            let errorMargin = 0;
            if (difficulty !== 'pro') {
                const shotProbability = bestShot.probability || 1.0;
                if (difficulty === 'hard') {
                    if (shotProbability < 0.75) {
                        let baseError = (1 - shotProbability) * 0.08;
                        // Habang "umiinit" ang AI (sunod-sunod ang pasok), bumababa ang kanyang error
                        const confidenceFactor = 1.0 - (aiConsecutivePots * 0.3); // 30% bawas error kada sunod na pasok
                        errorMargin = baseError * Math.max(0, confidenceFactor);
                    }
                } else if (difficulty === 'easy') {
                    if (shotProbability < 0.85) errorMargin = (1 - shotProbability) * 0.15;
                }
            }

            if (errorMargin > 0) {
                bestShot.angle += (Math.random() - 0.5) * (errorMargin * 2);
                bestShot.power *= 1 + (Math.random() - 0.5) * errorMargin;
            }
            animateAiAiming(bestShot.angle, bestShot.power);
        }


// (Mga helper functions - isama ang lahat ng ito)
function findBestKickShot(cueChip, legalTargets){let bestKickShot={score:-Infinity};const cushions=[{type:'y',val:0},{type:'y',val:table.height},{type:'x',val:0},{type:'x',val:table.width}];for(const target of legalTargets){for(const cushion of cushions){let virtualCue=(cushion.type==='y')?{x:cueChip.x,y:cushion.val*2-cueChip.y}:{x:cushion.val*2-cueChip.x,y:cueChip.y};const kickAngle=Math.atan2(target.y-virtualCue.y,target.x-virtualCue.x);const impactPoint=(cushion.type==='y')?{y:cushion.val,x:cueChip.x+(cushion.val-cueChip.y)/Math.tan(kickAngle)}:{x:cushion.val,y:cueChip.y+(cushion.val-cueChip.x)*Math.tan(kickAngle)};const pathToCushionClear=!isPathObstructed(cueChip,impactPoint,[]);const pathFromCushionClear=!isPathObstructed(impactPoint,target,[]);if(pathToCushionClear&&pathFromCushionClear){const power=0.5+Math.random()*0.2;const finalShotAngle=Math.atan2(impactPoint.y-cueChip.y,impactPoint.x-cueChip.x);const score=1000-Math.abs(finalShotAngle-kickAngle);if(score>bestKickShot.score)bestKickShot={score,angle:finalShotAngle,power,probability:0.6};}}}return bestKickShot.score>-Infinity?bestKickShot:null;}
function predictSimpleCuePos(cueChip,targetChip,shotAngle,power){const distance=Math.hypot(targetChip.x-cueChip.x,targetChip.y-cueChip.y);const followDistance=(power*power)*(distance*0.4);return{id:0,x:targetChip.x+Math.cos(shotAngle)*followDistance,y:targetChip.y+Math.sin(shotAngle)*followDistance,radius:cueChip.radius};}
function calculatePositionalScore(predictedCuePos,justPocketedId,allLegalTargets){let nextTargets=[];if(gameMode.includes('poker'))nextTargets=allLegalTargets.filter(t=>t.id!==justPocketedId);else if(gameMode.includes('61-ball')){const remaining=chips.filter(c=>c.inPlay&&c.id!==0&&c.id!==justPocketedId);if(remaining.length>0)nextTargets=[remaining.sort((a,b)=>a.id-b.id)[0]];}else nextTargets=allLegalTargets.filter(t=>t.id!==justPocketedId);if(nextTargets.length===0)return 800;const nextBestTarget=nextTargets.sort((a,b)=>Math.hypot(a.x-predictedCuePos.x,a.y-predictedCuePos.y)-Math.hypot(b.x-predictedCuePos.x,b.y-predictedCuePos.y))[0];let score=600-Math.hypot(nextBestTarget.x-predictedCuePos.x,nextBestTarget.y-predictedCuePos.y);if(isPathObstructed(predictedCuePos,nextBestTarget,[]))score-=400;let bestAngleScore=-200;for(const hole of holes){if(!isPathObstructed(nextBestTarget,hole,[predictedCuePos.id])){const angleToHole=Math.atan2(hole.y-nextBestTarget.y,hole.x-nextBestTarget.x);const shotLine=Math.atan2(nextBestTarget.y-predictedCuePos.y,nextBestTarget.x-predictedCuePos.x);const cutAngle=Math.abs(angleToHole-shotLine);const angleBonus=200*(1-cutAngle/(Math.PI/2));if(angleBonus>bestAngleScore)bestAngleScore=angleBonus;}}score+=bestAngleScore;return score;}
function findBestDefensiveShot(cueChip,legalTargets){if(!legalTargets||legalTargets.length===0)return null;let bestSafety={score:-Infinity,angle:0,power:0};const primaryTarget=legalTargets[0];const opponentNextTarget=primaryTarget;for(let i=0;i<32;i++){const angleOffset=(Math.random()-0.5)*(Math.PI/4);const shotAngle=Math.atan2(primaryTarget.y-cueChip.y,primaryTarget.x-cueChip.x)+angleOffset;const power=0.25+Math.random()*0.2;const predictedCuePos=predictSimpleCuePos(cueChip,primaryTarget,shotAngle,power);if(holes.some(h=>Math.hypot(h.x-predictedCuePos.x,h.y-predictedCuePos.y)<h.radius*1.2))continue;let safetyScore=0;safetyScore+=Math.hypot(predictedCuePos.x-opponentNextTarget.x,predictedCuePos.y-opponentNextTarget.y);const distToCushion=Math.min(predictedCuePos.x,table.width-predictedCuePos.x,predictedCuePos.y,table.height-predictedCuePos.y);if(distToCushion<cueChip.radius*3)safetyScore+=300;let blockingBallsCount=0;for(const chip of chips){if(chip.inPlay&&chip.id!==cueChip.id&&chip.id!==opponentNextTarget.id){const distToLine=Math.abs((opponentNextTarget.y-predictedCuePos.y)*chip.x-(opponentNextTarget.x-predictedCuePos.x)*chip.y+opponentNextTarget.x*predictedCuePos.y-opponentNextTarget.y*predictedCuePos.x)/Math.hypot(opponentNextTarget.y-predictedCuePos.y,opponentNextTarget.x-predictedCuePos.x);if(distToLine<chip.radius*2)blockingBallsCount++;}}safetyScore+=blockingBallsCount*400;if(safetyScore>bestSafety.score)bestSafety={score:safetyScore,angle:shotAngle,power:power,probability:0.9};}return bestSafety.score>-Infinity?bestSafety:null;}

function placeCueChipForAI() {
    cueBallGuide.style.display = 'none';
    const cueChip = chips[0];
    gameState = 'ai_placing';
    const breakLineX = table.width * 0.25;
    let bestPlacement = { score: -Infinity, x: 0, y: 0 };
    for (let i = 0; i < 40; i++) {
        const proposedX = Math.random() * (breakLineX - cueChip.radius * 2) + cueChip.radius;
        const proposedY = (table.height / 40) * i + cueChip.radius;
        if (isPositionOccupied(proposedX, proposedY, cueChip)) continue;
        const tempCueChip = { ...cueChip, x: proposedX, y: proposedY };
        let legalTargets = chips.filter(c => c.inPlay && c.id !== 0);
        let bestScoreFromPos = -Infinity;
        for (const target of legalTargets) {
            for (const hole of holes) {
                const evalShot = evaluateShot(tempCueChip, target, hole, legalTargets, 'hard');
                if (evalShot && evalShot.score > bestScoreFromPos) bestScoreFromPos = evalShot.score;
            }
        }
        if (bestScoreFromPos > bestPlacement.score) {
            bestPlacement = { score: bestScoreFromPos, x: proposedX, y: proposedY };
        }
    }
    if (bestPlacement.score > -Infinity) {
        cueChip.x = bestPlacement.x;
        cueChip.y = bestPlacement.y;
    } else {
        cueChip.x = table.width * 0.25;
        cueChip.y = table.height / 2;
    }
    
    // ITO ANG INAYOS NA LINYA para sa FREEZE: canMoveBall -> canMoveCueBall
    setTimeout(() => {
        canMoveCueBall = false;
        gameState = 'aiming';
        cueStick.visible = true;
        setTimeout(aiTurn, 500);
    }, 700);
}

function animateAiAiming(targetAngle,finalPower){const startTime=performance.now();const startAngle=cueStick.angle;const DURATION_ALIGN=800;const DURATION_FEATHER=2500;const DURATION_PAUSE=0;const FEATHER_COUNT=1.5;const FEATHER_DISTANCE=60*scale;const TOTAL_DURATION=DURATION_ALIGN+DURATION_FEATHER+DURATION_PAUSE;function animate(currentTime){const elapsedTime=currentTime-startTime;if(elapsedTime<DURATION_ALIGN){const alignProgress=elapsedTime/DURATION_ALIGN;const easeOut=1-Math.pow(1-alignProgress,4);cueStick.angle=startAngle+(targetAngle-startAngle)*easeOut;cueStick.pullback=0;}else if(elapsedTime<DURATION_ALIGN+DURATION_FEATHER){cueStick.angle=targetAngle;const featherTime=elapsedTime-DURATION_ALIGN;const featherProgress=featherTime/DURATION_FEATHER;cueStick.pullback=Math.abs(Math.sin(featherProgress*Math.PI*(FEATHER_COUNT*2)))*FEATHER_DISTANCE;}else if(elapsedTime<TOTAL_DURATION){cueStick.angle=targetAngle;cueStick.pullback=0;}else{cueStick.angle=targetAngle;shoot(finalPower*40+5);return;}requestAnimationFrame(animate);}requestAnimationFrame(animate);}
function placeChipOnSpot(chipToPlace){const spotX=table.width*(gameMode.includes('61-ball')?0.75:0.7);const spotY=table.height/2;let finalX=spotX,finalY=spotY,attempts=0;while(attempts<100){if(!chips.some(c=>c.inPlay&&c.id!==chipToPlace.id&&(finalX-c.x)**2+(finalY-c.y)**2<(c.radius+chipToPlace.radius)**2))break;const angle=attempts*0.5,radius=chipToPlace.radius*1.2*Math.sqrt(attempts+1);finalX=spotX+Math.cos(angle)*radius;finalY=spotY+Math.sin(angle)*radius;attempts++;}chipToPlace.x=finalX;chipToPlace.y=finalY;}


        // =========================================================================
        // POKER LOGIC
        // =========================================================================
        function createDeck() { deck = []; const suits = ['♥', '♦', '♣', '♠'], ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']; for (const suit of suits) for (const rank of ranks) { let value = parseInt(rank); if(rank==='A') value=1; else if(rank==='J') value=11; else if(rank==='Q') value=12; else if(rank==='K') value=13; deck.push({ suit, rank, value }); }}
        function dealCards() { playerHand = []; opponentHand = []; for (let i = deck.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [deck[i], deck[j]]=[deck[j], deck[i]]; } for (let i = 0; i < 7; i++) { if(deck.length > 0) playerHand.push(deck.pop()); if(deck.length > 0) opponentHand.push(deck.pop()); } originalPlayerHand = [...playerHand]; originalOpponentHand = [...opponentHand]; }

        // =========================================================================
        // UI, EVENT HANDLING & NAVIGATION
        // =========================================================================
        function toggleFullScreen() { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => showMessage(`Could not activate full-screen mode.`, 2000)); else if (document.exitFullscreen) document.exitFullscreen(); }
        async function resetToMenu() {
            playButtonSound();
            if (isOnlineGame) await leaveOnlineGame(false); 
            [winnerModal, gameModeSelect, aiMenu, difficultySelect, onlineMenu, onlineGameSelect, waitingRoom, straightBallInstructions, pokerInstructions, sixtyOneInstructions, confirmExitModal, leaderboardModal].forEach(m => m.style.display = 'none');
            gameModeSelect.style.display = 'flex';
            if (unsubscribeGameListener) { unsubscribeGameListener(); unsubscribeGameListener = null; }
            gameState = 'menu'; isOnlineGame = false; gameId = null; localPlayerId = null;
            updateCardDisplay(); playerInfo.innerHTML = 'You: ?'; opponentInfo.innerHTML = 'Opponent: ?';
            chips = []; draw(); history.pushState({ modal: 'gameModeSelect' }, 'Main Menu', '#main');
        }
        window.onpopstate = (event) => {
            if (gameState !== 'menu' && gameState !== 'gameover' && !Array.from(document.querySelectorAll('.modal-overlay')).some(m => m.style.display === 'flex')) {
                showExitConfirmation(); history.pushState({ modal: 'game' }, 'Game', '#game'); return;
            }
            const state = event.state || { modal: 'gameModeSelect' };
            const allModals = { gameModeSelect, aiMenu, difficultySelect, straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, leaderboardModal };
            Object.values(allModals).forEach(modal => modal.style.display = 'none');
            if (allModals[state.modal]) allModals[state.modal].style.display = 'flex';
            else if (!state.modal || state.modal === 'gameModeSelect') gameModeSelect.style.display = 'flex';
        };
        function showExitConfirmation() { 
            playButtonSound(); 
            if (gameState !== 'menu' && gameState !== 'gameover' && confirmExitModal.style.display !== 'flex') { 
                confirmExitModal.style.display = 'flex'; 
            } 
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', resizeCanvas);
            window.addEventListener('beforeunload', () => { if (isOnlineGame) leaveOnlineGame(true); });
            document.querySelectorAll('.menu-button, .ui-button, .icon-button').forEach(button => button.addEventListener('click', playButtonSound));
            fullscreenButton.addEventListener('click', toggleFullScreen);
            vsAiButton.addEventListener('click', () => { gameModeSelect.style.display = 'none'; aiMenu.style.display = 'flex'; history.pushState({ modal: 'aiMenu' }, 'AI Menu', '#ai'); });
            aiStraightBallButton.addEventListener('click', () => { selectedGameConfig.mode = 'ai-straight-ball'; aiMenu.style.display = 'none'; difficultySelect.style.display = 'flex'; history.pushState({ modal: 'difficultySelect' }, 'Difficulty', '#difficulty'); });
            aiPokerButton.addEventListener('click', () => { selectedGameConfig.mode = 'ai-poker'; aiMenu.style.display = 'none'; difficultySelect.style.display = 'flex'; history.pushState({ modal: 'difficultySelect' }, 'Difficulty', '#difficulty'); });
            ai61Button.addEventListener('click', () => { selectedGameConfig.mode = 'ai-61-ball'; aiMenu.style.display = 'none'; difficultySelect.style.display = 'flex'; history.pushState({ modal: 'difficultySelect' }, 'Difficulty', '#difficulty'); });
            difficultySelect.querySelectorAll('.menu-button[data-difficulty]').forEach(button => {
                button.addEventListener('click', (e) => {
                    selectedGameConfig.difficulty = e.target.dataset.difficulty;
                    difficultySelect.style.display = 'none';
                    if (selectedGameConfig.mode === 'ai-straight-ball') { straightBallInstructions.style.display = 'flex'; history.pushState({ modal: 'straightBallInstructions' }, 'Rules', '#rules'); } 
                    else if (selectedGameConfig.mode === 'ai-poker') { pokerInstructions.style.display = 'flex'; history.pushState({ modal: 'pokerInstructions' }, 'Rules', '#rules'); }
                    else if (selectedGameConfig.mode === 'ai-61-ball') { sixtyOneInstructions.style.display = 'flex'; history.pushState({ modal: 'sixtyOneInstructions' }, 'Rules', '#rules'); }
                });
            });
            [difficultyBackButton, aiBackButton, onlineSelectBackButton, onlineBackButton, cancelGameButton].forEach(btn => btn.addEventListener('click', () => history.back()));
            playStraightBallButton.addEventListener('click', () => startGame(selectedGameConfig.mode, selectedGameConfig.difficulty));
            playPokerButton.addEventListener('click', () => startGame(selectedGameConfig.mode, selectedGameConfig.difficulty));
            play61BallButton.addEventListener('click', () => startGame(selectedGameConfig.mode, selectedGameConfig.difficulty));
            exitButton.addEventListener('click', showExitConfirmation);
            playAgainButton.addEventListener('click', resetToMenu);
            document.getElementById('rematch-button').addEventListener('click', handleRematchRequest);
            confirmExitYes.addEventListener('click', async () => { confirmExitModal.style.display = 'none'; if (gameState === 'gameover' || gameState === 'menu') { resetToMenu(); return; } await endGame("You Forfeited. Opponent Wins!", playerHand, opponentHand); });
            confirmExitCancel.addEventListener('click', () => { playButtonSound(); confirmExitModal.style.display = 'none'; });
            onlineButton.addEventListener('click', () => {
                if (!isAuthReady) { showMessage("Connecting... Please wait.", 2000); return; }
                if (!firebaseInitialized) { showMessage("An internet connection is required for online mode.", 3000); return; }
                gameModeSelect.style.display = 'none'; onlineGameSelect.style.display = 'flex'; history.pushState({ modal: 'onlineGameSelect' }, 'Online', '#online');
            });
            onlinePokerButton.addEventListener('click', () => { selectedOnlineGameType = 'poker'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); });
            onlineStraightBallButton.addEventListener('click', () => { selectedOnlineGameType = 'straight-ball'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); });
            online61Button.addEventListener('click', () => { selectedOnlineGameType = '61-ball'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); });
            createGameButton.addEventListener('click', createOnlineGame);
            joinGameButton.addEventListener('click', joinOnlineGame);
            gameIdDisplay.addEventListener('click', () => { navigator.clipboard?.writeText(gameIdDisplay.textContent).then(() => showMessage("Game ID copied!", 1500)); });
            
            leaderboardButton.addEventListener('click', showLeaderboard);
            leaderboardBackButton.addEventListener('click', () => {
                leaderboardModal.style.display = 'none';
                gameModeSelect.style.display = 'flex';
                history.pushState({ modal: 'gameModeSelect' }, 'Main Menu', '#main');
            });

            [canvas, powerControl, pektusControl, leftArrow, rightArrow].forEach(el => { el.addEventListener('mousedown', handlePointerDown); el.addEventListener('touchstart', handlePointerDown, { passive: false }); });
            window.addEventListener('mouseup', handlePointerUp); window.addEventListener('touchend', handlePointerUp);
            window.addEventListener('mousemove', handlePointerMove); window.addEventListener('touchmove', handlePointerMove, { passive: false });
        }
                function handlePointerDown(e) {
            e.preventDefault();
            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            if (!isMyTurn || (isOnlineGame && isSyncing)) return;
            const targetId = e.currentTarget.id;
            if (gameState === 'moving' && canMoveCueBall && targetId === 'game-canvas') {
                isDraggingCueBall = true;
                cueStick.visible = false;
                ghostHand.style.display = 'block'; // ITO ANG NAGPAPALITAW SA KAMAY
                updateCueBallPosition(e);
            } else if (gameState === 'aiming') {
                if (targetId === 'game-canvas') {
                    isAimingOnCanvas = true;
                    updateAimFromCanvas(e);
                } else if (targetId === 'power-control') isPoweringUp = true;
                else if (targetId === 'pektus-control') {
                    isDraggingPektusDot = true;
                    handlePektusInput(e);
                } else if (targetId === 'left-arrow') isRotatingLeft = true;
                else if (targetId === 'right-arrow') isRotatingRight = true;
            }
        }

                function handlePointerMove(e) {
            if (isDraggingCueBall) {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                // Inililipat ang ghost hand sa eksaktong pwesto ng cursor/daliri
                ghostHand.style.left = `${clientX}px`;
                ghostHand.style.top = `${clientY}px`;
                dragGuideText.style.display = `none`;
                
                updateCueBallPosition(e);
            } else if (isPoweringUp) {
                e.preventDefault();
                updatePower(e);
            } else if (isAimingOnCanvas) {
                e.preventDefault();
                updateAimFromCanvas(e);
            } else if (isDraggingPektusDot) {
                e.preventDefault();
                handlePektusInput(e);
            }
        }

                function handlePointerUp() {
            if (isPoweringUp) {
                isPoweringUp = false;
                shoot(cueStick.power * 60 + 2);
            }
            isAimingOnCanvas = false;
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                ghostHand.style.display = 'none'; // ITO ANG NAGPAPATAGO SA KAMAY
                if (!isInvalidPlacement) {
                    canMoveCueBall = false;
                    gameState = 'aiming';
                    cueStick.visible = true;
                    cueBallGuide.style.display = 'none';
                    if (isOnlineGame) {
                        const chipsToSend = chips.map(c => ({...c, x: c.x / table.width, y: c.y / table.height }));
                        updateDoc(doc(db, "games", gameId), { canMoveCueBall: false, chips: chipsToSend, liveAimData: null, currentTurnUid: localPlayerUid });
                    }
                } else {
                    cueStick.visible = true;
                }
            }
            isDraggingPektusDot = false;
            isRotatingLeft = false;
            isRotatingRight = false;
        }

        function getEventPos(e, relativeTo) { const rect = relativeTo.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
        function updatePower(e) { const pos = getEventPos(e, powerControl); let p = pos.y / powerControl.clientHeight; cueStick.power = Math.max(0, Math.min(1, p)); powerBar.style.height = `${cueStick.power * 100}%`; cueStick.pullback = cueStick.power * (150 * scale); }
        function updateAimFromCanvas(e) { const cueChip = chips[0]; if (!cueChip || !cueChip.inPlay) return; const pos = getEventPos(e, canvas); cueStick.angle = Math.atan2(pos.y - cueChip.y, pos.x - cueChip.x); sendLiveAimData(); }
        function updateCueBallPosition(e) { const pos = getEventPos(e, canvas); const cueChip = chips[0]; const breakLineX = table.width * 0.25; let proposedX, proposedY; if (isBreakShot) { proposedX = Math.max(cueChip.radius, Math.min(breakLineX - cueChip.radius, pos.x)); proposedY = Math.max(cueChip.radius, Math.min(table.height - cueChip.radius, pos.y)); } else { proposedX = Math.max(cueChip.radius, Math.min(table.width - cueChip.radius, pos.x)); proposedY = Math.max(cueChip.radius, Math.min(table.height - cueChip.radius, pos.y)); } if (!isPositionOccupied(proposedX, proposedY, cueChip)) { cueChip.x = proposedX; cueChip.y = proposedY; isInvalidPlacement = false; sendLiveAimData(); } else isInvalidPlacement = true; }
        function handlePektusInput(e) { const rect = pektusControl.getBoundingClientRect(); const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left, y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top; const centerX = rect.width / 2, centerY = rect.height / 2; let dx = x-centerX, dy = y-centerY; const dist = Math.sqrt(dx*dx+dy*dy), maxDist = rect.width/2; if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; } pektusOffset.x = dx/maxDist; pektusOffset.y = Math.min(0, dy/maxDist); updatePektusUI(); sendLiveAimData(); }
        function isPositionOccupied(x, y, draggedChip) { for (const chip of chips) { if (chip.id === draggedChip.id || !chip.inPlay) continue; if ((x-chip.x)**2 + (y-chip.y)**2 < (draggedChip.radius + chip.radius)**2) return true; } return false; }

        // =========================================================================
        // LEADERBOARD LOGIC
        // =========================================================================
        async function showLeaderboard() {
            leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr>';
            gameModeSelect.style.display = 'none';
            leaderboardModal.style.display = 'flex';
            history.pushState({ modal: 'leaderboardModal' }, 'Leaderboard', '#leaderboard');

            try {
                const playersRef = collection(db, "players");
                const q = query(playersRef, orderBy("wins", "desc"), limit(100));
                const querySnapshot = await getDocs(q);
                
                leaderboardBody.innerHTML = '';
                if (querySnapshot.empty) {
                     leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">No players yet. Be the first!</td></tr>';
                     return;
                }

                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const playerData = doc.data();
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="padding: 8px;">#${rank}</td>
                        <td style="padding: 8px;">${playerData.displayName}</td>
                        <td style="padding: 8px;">${playerData.wins}</td>
                    `;
                    leaderboardBody.appendChild(row);
                    rank++;
                });
            } catch (error) {
                console.error("Error fetching leaderboard: ", error);
                leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Could not load leaderboard. Check console for errors.</td></tr>';
                showMessage("Error: You may need to create a Firestore index. Check the console (F12) for a link.", 5000);
            }
        }

        // =========================================================================
        // FIREBASE MULTIPLAYER LOGIC
        // =========================================================================
        function initializeFirebase() {
            try {
                onlineButton.textContent = "Connecting..."; onlineButton.disabled = true;
                const firebaseConfig = { apiKey: "AIzaSyD0gZfJxpA_4fO-SEOjX9JNs0v7IzQ0iSc", authDomain: "pinoy-pool-master.firebaseapp.com", projectId: "pinoy-pool-master", storageBucket: "pinoy-pool-master.appspot.com", messagingSenderId: "1003592334290", appId: "1:1003592334290:web:2982cdc8691e8ef7c6260b" };
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app); auth = getAuth(app);
                signInPlayer(); firebaseInitialized = true;
            } catch (error) { console.warn("Firebase failed.", error); firebaseInitialized = false; onlineButton.textContent = "Offline"; onlineButton.disabled = true; }
        }
        function signInPlayer() {
            onAuthStateChanged(auth, (user) => {
                if (user) { localPlayerUid = user.uid; isAuthReady = true; onlineButton.disabled = false; onlineButton.textContent = "Online Multiplayer"; } 
                else { signInAnonymously(auth).catch((error) => { console.error("Sign-in failed:", error); isAuthReady = false; onlineButton.textContent = "Auth Failed"; onlineButton.disabled = true; }); }
            });
        }
        async function createOnlineGame() {
            if (!isAuthReady || !localPlayerUid) { showMessage("Authenticating... Please wait."); return; }
            onlineMenu.style.display = 'none'; resizeCanvas();
            gameMode = `online-${selectedOnlineGameType}`;
            setupChips();
            gameId = Math.random().toString(36).substring(2, 7).toUpperCase(); localPlayerId = 'player1'; lastProcessedTurnId = -1; 
            const initialChipsToSend = chips.map(c => ({...c, x: c.x/table.width, y: c.y/table.height }));
            const gameData = { gameId, gameType: selectedOnlineGameType, gameState: 'waiting', turnId: 0, players: { player1: { uid: localPlayerUid, status: 'online' }, player2: null }, chips: initialChipsToSend, currentTurnUid: null, lastShot: null, liveAimData: null, turnInProgress: false, canMoveCueBall: true, isBreakShot: true, winner: null };
            
            if (selectedOnlineGameType === 'poker') {
                createDeck(); dealCards();
                Object.assign(gameData, { deck, player1Hand: playerHand, player2Hand: opponentHand, originalPlayer1Hand: originalPlayerHand, originalPlayer2Hand: originalOpponentHand });
            } else if (selectedOnlineGameType === 'straight-ball') {
                Object.assign(gameData, { colorsAssigned: false, player1ChipsType: null, player2ChipsType: null });
            } else if (selectedOnlineGameType === '61-ball') {
                Object.assign(gameData, { player1_61Score: 0, player2_61Score: 0, lowestChipNumber: 1 });
            }
            
            try {
                await setDoc(doc(db, "games", gameId), gameData);
                gameIdDisplay.textContent = gameId; 
                waitingRoom.style.display = 'flex';
                history.pushState({ modal: 'waitingRoom' }, 'Waiting Room', '#wait');
                listenToGameUpdates(gameId);
            } catch (error) { 
                showMessage("Failed to create game.", 3000); 
                console.error("Firebase setDoc error:", error); 
                onlineMenu.style.display = 'flex'; 
                history.back(); 
            }
        }
        async function joinOnlineGame() {
            if (!isAuthReady || !localPlayerUid) { showMessage("Authenticating... Please wait."); return; }
            const inputId = gameIdInput.value.trim().toUpperCase(); if (!inputId) { showMessage("Please enter a Game ID."); return; }
            const gameDocRef = doc(db, "games", inputId);
            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists()) {
                    if (docSnap.data().gameState !== 'waiting') { showMessage("Game is full."); return; }
                    onlineMenu.style.display = 'none'; showMessage("Joining game...");
                    const startingPlayerUid = Math.random() < 0.5 ? docSnap.data().players.player1.uid : localPlayerUid;
                    await updateDoc(gameDocRef, { 'players.player2': { uid: localPlayerUid, status: 'online' }, 'gameState': 'playing', 'currentTurnUid': startingPlayerUid, 'turnId': 1 });
                    gameId = inputId; localPlayerId = 'player2'; listenToGameUpdates(inputId);
                } else showMessage("Game not found.");
            } catch (error) { showMessage("Failed to join game.", 3000); }
        }
        async function cancelOnlineGame() { if (gameId) { try { await deleteDoc(doc(db, "games", gameId)); gameId = null; } catch (e) { console.error("Error cancelling", e); }} resetToMenu(); }
        async function resetOnlineGameForRematch(gameData) {
            // I-disable muna ang listener para hindi mag-loop
            if (unsubscribeGameListener) unsubscribeGameListener();

            // 1. I-reset ang local game state (para sa bagong setup)
            gameMode = `online-${gameData.gameType}`;
            setupChips(); // Gumawa ng bagong pwesto ng mga bola

            // 2. Ihanda ang data na ipapadala sa Firebase
            const newChipsState = chips.map(c => ({...c, x: c.x / table.width, y: c.y / table.height }));
            const startingPlayerUid = Math.random() < 0.5 ? gameData.players.player1.uid : gameData.players.player2.uid;
            
            const resetData = {
                gameState: 'playing',
                chips: newChipsState,
                currentTurnUid: startingPlayerUid,
                canMoveCueBall: true,
                isBreakShot: true,
                winner: null,
                rematchRequest: null, // Burahin ang request para sa susunod na laro
                turnId: (gameData.turnId || 0) + 10, // Itaas ang turnId para siguradong bago
                lastShot: null
            };

            // 3. I-reset ang game-specific data
            if (gameData.gameType === 'poker') {
                createDeck();
                dealCards();
                Object.assign(resetData, { 
                    deck, 
                    player1Hand: localPlayerId === 'player1' ? playerHand : opponentHand, 
                    player2Hand: localPlayerId === 'player1' ? opponentHand : playerHand,
                    originalPlayer1Hand: localPlayerId === 'player1' ? originalPlayerHand : originalOpponentHand,
                    originalPlayer2Hand: localPlayerId === 'player1' ? originalOpponentHand : originalPlayerHand,
                });
            } else if (gameData.gameType === '61-ball') {
                Object.assign(resetData, { 
                    player1_61Score: 0, 
                    player2_61Score: 0, 
                    lowestChipNumber: 1 
                });
            } else if (gameData.gameType === 'straight-ball') {
                 Object.assign(resetData, { 
                    colorsAssigned: false, 
                    player1ChipsType: null, 
                    player2ChipsType: null 
                });
            }

            // 4. I-update ang Firebase at i-reactivate ang listener
            try {
                await updateDoc(doc(db, "games", gameId), resetData);
            } catch (error) {
                console.error("Failed to reset game for rematch:", error);
            } finally {
                // Buhayin muli ang listener
                listenToGameUpdates(gameId);
            }
        }

        function animateAndApplyShot(shotData) {
            cueStick.angle = shotData.angle;
            cueStick.visible = true;
            gameState = 'shooting_animation';
            let startTime = null;
            const animationDuration = 100;
            const shotPowerNormalized = (shotData.power - 5) / 40;
            const startPullback = shotPowerNormalized * (150 * scale);
            const endPullback = -30 * scale;
            
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / animationDuration, 1);
                cueStick.pullback = startPullback + (endPullback - startPullback) * progress;
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    cueStick.visible = false;
                    cueStick.pullback = 0;
                    applyShot(shotData);
                }
            }
            requestAnimationFrame(animate);
        }

        function sendLiveAimData() {
            if (!isOnlineGame || !isMyTurnOnline || !gameId || table.width === 0) return;
            const now = Date.now();
            if (now - lastAimUpdateTime < AIM_UPDATE_INTERVAL) return;
            lastAimUpdateTime = now;
            const cueChip = chips.find(c => c.id === 0); if (!cueChip) return;
            const dataToSend = { 
                angle: cueStick.angle, 
                cueBallX: cueChip.x/table.width, 
                cueBallY: cueChip.y/table.height, 
                pektusX: pektusOffset.x, 
                pektusY: pektusOffset.y, 
                sender: localPlayerUid 
            };
            updateDoc(doc(db, "games", gameId), { liveAimData: dataToSend }).catch(() => {});
        }
        
        function listenToGameUpdates(gameId) {
            let lastShotTimestamp = 0;
            unsubscribeGameListener = onSnapshot(doc(db, "games", gameId), (doc) => {
                if (!doc.exists()) {
                    if (gameState !== 'menu' && gameState !== 'gameover') {
                        showMessage("Game ended by host.", 3000);
                        resetToMenu();
                    }
                    return;
                }
                const gameData = doc.data();
                if (!gameData) return;

                if (gameData.lastShot && gameData.lastShot.timestamp > lastShotTimestamp && !chipsMoving) {
                    lastShotTimestamp = gameData.lastShot.timestamp;
                    animateAndApplyShot(gameData.lastShot);
                }
                
                // --- REMATCH LOGIC START ---
                if (gameData.gameState === 'finished' && gameData.rematchRequest) {
                    const players = Object.keys(gameData.players).filter(p => gameData.players[p] !== null);
                    
                    if (players.length === 2) {
                        const playerUIDs = players.map(p => gameData.players[p].uid);
                        
                        const player1_uid = playerUIDs[0];
                        const player2_uid = playerUIDs[1];

                        const iWantRematch = gameData.rematchRequest[localPlayerUid];
                        const opponentUid = localPlayerUid === player1_uid ? player2_uid : player1_uid;
                        const opponentWantsRematch = gameData.rematchRequest[opponentUid];

                        const rematchButton = document.getElementById('rematch-button');

                        if (iWantRematch && opponentWantsRematch) {
                            if (localPlayerId === 'player2') {
                                resetOnlineGameForRematch(gameData);
                            }
                        } else if (opponentWantsRematch && !iWantRematch) {
                            rematchButton.textContent = 'Accept Rematch';
                        }
                    }
                }
                // --- REMATCH LOGIC END ---

                syncGameState(gameData);
            });
        }
        
        function syncGameState(data) {
            if (isSyncing || !data) return;
            isSyncing = true;
        
            if (data.gameState === 'playing' && gameState !== 'playing') {
                gameState = 'playing'; 
                isOnlineGame = true;
                gameMode = `online-${data.gameType}`;
                lastProcessedTurnId = 0;
                
                winnerModal.style.display = 'none';
                waitingRoom.style.display = 'none';
                onlineMenu.style.display = 'none';
                gameModeSelect.style.display = 'none';
                history.pushState({ modal: 'game' }, 'Game', '#game');
                
                if (table.width === 0) resizeCanvas();

                if (data.chips) {
                    chips = data.chips.map(remoteChip => ({
                        ...remoteChip,
                        x: remoteChip.x * table.width,
                        y: remoteChip.y * table.height,
                        radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
                    }));
                }
    
                if (data.gameType === 'poker') {
                    deck = data.deck || [];
                    playerHand = (localPlayerId === 'player1') ? data.player1Hand : data.player2Hand;
                    opponentHand = (localPlayerId === 'player1') ? data.player2Hand : data.player1Hand;
                    originalPlayerHand = (localPlayerId === 'player1') ? data.originalPlayer1Hand : data.originalPlayer2Hand;
                    originalOpponentHand = (localPlayerId === 'player1') ? data.originalPlayer2Hand : data.originalPlayer1Hand;
                } else if (data.gameType === 'straight-ball') {
                    colorsAssigned = data.colorsAssigned;
                    playerChipsType = (localPlayerId === 'player1') ? data.player1ChipsType : data.player2ChipsType;
                    opponentChipsType = (localPlayerId === 'player1') ? data.player2ChipsType : data.player1ChipsType;
                } else if (data.gameType === '61-ball') {
                    player61Score = (localPlayerId === 'player1') ? data.player1_61Score : data.player2_61Score;
                    opponent61Score = (localPlayerId === 'player1') ? data.player2_61Score : data.player1_61Score;
                    lowestChipNumber = data.lowestChipNumber;
                }
            }
        
            if (data.gameState === 'finished' && gameState !== 'gameover') {
                let finalPlayerHand, finalOpponentHand;
                if (data.gameType === 'poker' && data.player1Hand && data.player2Hand) {
                    finalPlayerHand = (localPlayerId === 'player1') ? data.player1Hand : data.player2Hand;
                    finalOpponentHand = (localPlayerId === 'player1') ? data.player2Hand : data.player1Hand;
                }
                endGame(data.winner === localPlayerUid ? 'You Win!' : 'You Lose!', finalPlayerHand, finalOpponentHand);
                isSyncing = false;
                return;
            }
        
            if (localPlayerId && data.players) {
                const opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
                if (data.players[opponentId]?.status === 'disconnected' && gameState !== 'gameover') {
                    endGame("Opponent disconnected. You Win!", playerHand, opponentHand);
                    isSyncing = false;
                    return;
                }
            }
        
            if (gameState === 'playing') {
                isMyTurnOnline = (data.currentTurnUid === localPlayerUid);

                if (!isMyTurnOnline && data.liveAimData && data.liveAimData.sender !== localPlayerUid) {
                    const liveAim = data.liveAimData;
                    const cueChip = chips.find(c => c.id === 0);
                    if (cueChip) {
                        cueChip.x = liveAim.cueBallX * table.width;
                        cueChip.y = liveAim.cueBallY * table.height;
                    }
                    cueStick.angle = liveAim.angle;
                    pektusOffset.x = liveAim.pektusX;
                    pektusOffset.y = liveAim.pektusY;
                    updatePektusUI();
                }

                if (data.turnId === lastProcessedTurnId) {
                    isSyncing = false;
                    return;
                }

                if (!data.turnInProgress) {
                    lastProcessedTurnId = data.turnId;
                    
                    if (data.chips && table.width > 0) {
                        chips = data.chips.map(remoteChip => ({
                             ...remoteChip,
                             x: remoteChip.x * table.width,
                             y: remoteChip.y * table.height,
                             radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
                        }));
                    }
                    
                    updateCardDisplay();
                    updateInfoBox();
                    
                    canMoveCueBall = data.canMoveCueBall;
                    isBreakShot = data.isBreakShot;
                    
                    if (canMoveCueBall && isMyTurnOnline) {
    gameState = 'moving';
    cueStick.visible = true;
    showMessage("Place the cue ball.", 2000);
    dragGuideText.style.display = 'block'; 

                    } else {
                        gameState = 'aiming';
                        cueStick.visible = true;
                        cueBallGuide.style.display = 'none';
                    }
                    
                    const message = data.isBreakShot ? (isMyTurnOnline ? "You break!" : "Opponent's break!") : (isMyTurnOnline ? "Your turn" : "Opponent's turn");
                    if (!canMoveCueBall) {
                       showMessage(message, 2000);
                    }
                }
            }
        
            isSyncing = false;
        }

        function updateCardDisplay() {
            if (gameMode.includes('poker')) {
                cardHandContainer.style.display = 'flex'; cardHandContainer.innerHTML = ''; let currentHand = playerHand; if (!currentHand) return;
                currentHand.forEach(card => {
                    const cardDiv = document.createElement('div'); cardDiv.className = 'card';
                    const rankSpan = document.createElement('span'); rankSpan.className = 'card-rank'; rankSpan.textContent = card.rank;
                    const suitSpan = document.createElement('span'); suitSpan.className = 'card-suit'; suitSpan.textContent = card.suit;
                    if (card.suit === '♥' || card.suit === '♦') { rankSpan.style.color = '#ff5555'; suitSpan.style.color = '#ff5555'; } 
                    else { rankSpan.style.color = 'white'; suitSpan.style.color = 'white'; }
                    cardDiv.appendChild(rankSpan); cardDiv.appendChild(suitSpan); cardHandContainer.appendChild(cardDiv);
                });
            } else cardHandContainer.style.display = 'none';
            updateInfoBox();
        }
        function updateInfoBox() {
            const player1Name = 'You', player2Name = 'Opponent';
            if (gameMode.includes('poker')) { 
                playerInfo.innerHTML = `${player1Name}: <span style="color: #ffffff;">${playerHand?.length || 0} cards</span>`; 
                opponentInfo.innerHTML = `${player2Name}: <span style="color: #ffffff;">${opponentHand?.length || 0} cards</span>`; 
            } 
            else if (gameMode.includes('straight-ball')) {
                const vibrantRed = '#ff6b6b', vibrantBlue = '#54a0ff';
                const myColorName = playerChipsType ? playerChipsType.toUpperCase() : '?', theirColorName = opponentChipsType ? opponentChipsType.toUpperCase() : '?';
                const myDisplayColor = playerChipsType === 'red' ? vibrantRed : (playerChipsType === 'blue' ? vibrantBlue : 'white');
                const theirDisplayColor = opponentChipsType === 'red' ? vibrantRed : (opponentChipsType === 'blue' ? vibrantBlue : 'white');
                playerInfo.innerHTML = `${player1Name}: <span style="color: ${myDisplayColor};">${myColorName}</span>`; 
                opponentInfo.innerHTML = `${player2Name}: <span style="color: ${theirDisplayColor};">${theirColorName}</span>`;
            }
             else if (gameMode.includes('61-ball')) {
                playerInfo.innerHTML = `${player1Name}: <span style="color: white; font-weight: bold;">${player61Score} pts</span>`;
                opponentInfo.innerHTML = `${player2Name}: <span style="color: white; font-weight: bold;">${opponent61Score} pts</span>`;
                if(lowestChipNumber > 0 && gameState === 'aiming') {
                    cueBallGuide.innerHTML = `Target: Chip #${lowestChipNumber}`;
                    cueBallGuide.style.display = 'block';
                } else {
                    cueBallGuide.style.display = 'none';
                }
            }
        }
        function resetPektus() { pektusOffset = { x: 0, y: 0 }; updatePektusUI(); }
        function updatePektusUI() { const controlSize = pektusControl.offsetWidth, dotSize = pektusDot.offsetWidth, maxOffset = (controlSize/2) - (dotSize/2); const dotX = (pektusOffset.x*maxOffset) + (controlSize/2), dotY = (pektusOffset.y*maxOffset) + (controlSize/2); pektusDot.style.left = `${dotX}px`; pektusDot.style.top = `${dotY}px`; }
        async function leaveOnlineGame(isForfeit) {
            if (!isOnlineGame || !gameId || !localPlayerId) return;
            const gameDocRef = doc(db, "games", gameId);
            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().gameState !== 'finished') {
                    const opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
                    const winnerUid = docSnap.data().players[opponentId]?.uid;
                    if (isForfeit && winnerUid) await updateDoc(gameDocRef, { gameState: 'finished', winner: winnerUid, [`players.${localPlayerId}.status`]: 'disconnected' });
                    else await updateDoc(gameDocRef, { [`players.${localPlayerId}.status`]: 'disconnected' });
                }
            } catch (error) { console.error("Error leaving/forfeiting game:", error); }
        }

        // =========================================================================
        // START THE GAME
        // =========================================================================
        init();
    </script>
</body>
</html>
