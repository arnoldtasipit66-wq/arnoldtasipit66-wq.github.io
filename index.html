<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pinoy Pool</title>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #36454F;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #game-canvas {
            background-color: #c8a078;
            border: 10px solid #4a2a00;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 15px;
            cursor: crosshair;
            box-sizing: border-box; 
            max-width: 100%;
            max-height: 100%;
        }
        
        /* UI Containers */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2em;
            display: none;
            text-align: center;
            z-index: 1000;
        }
        .info-box {
            position: absolute;
            color: white;
            background-color: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        #player-info { top: 50px; left: 3px; }
        #opponent-info { top: 50px; right: 3px; }
        
        .ui-button {
             position: absolute;
            padding: 10px 15px;
            font-size: 1em;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
        }

        #exit-button {
            bottom: 5px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 53, 69, 0.5);
            z-index: 5;
            padding: 6px 12px;
            font-size: 0.8em;
        }

        #fullscreen-button {
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            z-index: 9999;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        #card-hand-container {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row; 
            gap: 8px; 
            pointer-events: all;
        }

        .card {
            width: 20px;
            height: 35px;
            background-color: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            border-radius: 4px; 
            display: flex;
            flex-direction: column; 
            justify-content: space-around; 
            align-items: center;
            font-weight: bold;
            color: white; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); 
        }
        .card-rank {
            font-size: 1em;
        }
        .card-suit {
            font-size: 0.9em;
        }


        /* Controls */
        .control-area {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }

        #power-control {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            flex-direction: column;
            justify-content: flex-end;
        }
        #power-bar {
            width: 100%;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
            border-radius: 8px;
            height: 0%;
        }

        #pektus-control {
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: none;
        }
        #pektus-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 0, 0, 0.8);
            border: 1px solid white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .arrow-button {
            position: absolute;
            bottom: 30px;
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        #left-arrow {
            right: 50%;
            transform: translateX(-120px);
        }
        #right-arrow {
            left: 50%;
            transform: translateX(120px);
        }


        /* Modals and Overlays */
        .modal-overlay {
            display: none; 
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            flex-direction: column;
            z-index: 200;
        }
        #game-mode-select {
            display: flex; 
        }
        .modal-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
        }
        .menu-button {
            font-size: 1.2em;
            padding: 15px 20px;
            margin: 8px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(76, 175, 80, 0.5);
            color: white;
            cursor: pointer;
            width: 300px;
        }
        .back-button {
            background-color: rgba(108, 117, 125, 0.5);
            margin-top: 20px;
        }
        
        #winner-modal h2 {
            margin-bottom: 0;
        }
        #winner-modal #play-again-button {
            font-size: 1.2em;
            padding: 10px 20px;
            margin-top: 30px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
        }

        #online-menu input {
            font-size: 1em;
            padding: 10px;
            margin: 10px;
            width: 250px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #opponent-hand-reveal {
            margin-top: 20px;
        }
        #opponent-hand-reveal .card {
            transform: scale(0.8);
        }

        /* Instruction Modal Styles */
        .instruction-modal .content {
            background-color: rgba(40, 80, 150, 0.7);
            padding: 20px 30px;
            border-radius: 15px;
            max-width: 80%;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .instruction-modal p {
            font-style: italic;
            line-height: 1.6;
            font-size: 1.1em;
            text-align: left;
            transform: skewX(-8deg);
        }
        .instruction-modal h2 {
            transform: skewX(-8deg);
        }

        /* Guide Text Style */
        .guide-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 0, 0.8);
            color: black;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            display: none; 
            text-align: center;
            z-index: 10;
        }
        
        /* Waiting Room Style */
        #waiting-room p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        #waiting-room #game-id-display {
            background-color: rgba(0,0,0,0.4);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 2.5em;
            font-weight: bold;
            letter-spacing: 5px;
            border: 1px solid rgba(255,255,255,0.3);
            margin-bottom: 20px;
            cursor: pointer;
        }

        /* Confirmation Modal Styles */
        #confirm-exit-modal .button-group {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #confirm-exit-modal .confirm-button {
            width: 120px;
            pointer-events: all;
        }
        #confirm-exit-yes {
            background-color: rgba(220, 53, 69, 0.7);
        }
        #confirm-exit-cancel {
            background-color: rgba(108, 117, 125, 0.7);
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <div id="player-info" class="info-box">You: ?</div>
            <div id="opponent-info" class="info-box">Opponent: ?</div>
            <button id="exit-button" class="ui-button">Exit</button>
            <div id="message-box"></div>
            <div id="card-hand-container"></div>
            <div id="cue-ball-guide" class="guide-text"></div>
            <button id="fullscreen-button" class="ui-button" title="Toggle Fullscreen">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;">
                    <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                </svg>
            </button>
        </div>
        
        <!-- Controls -->
        <div id="power-control" class="control-area">
            <div id="power-bar"></div>
        </div>
        <div id="pektus-control" class="control-area">
            <div id="pektus-dot"></div>
        </div>
        <div id="left-arrow" class="arrow-button control-area">&lt;</div>
        <div id="right-arrow" class="arrow-button control-area">&gt;</div>
    </div>

    <!-- Game Mode Selection -->
    <div id="game-mode-select" class="modal-overlay">
        <h2>Select Game Mode</h2>
        <button class="menu-button" id="vs-ai-button">Player vs AI</button>
        <button class="menu-button" id="online-button">Online Multiplayer</button>
    </div>

    <!-- AI Sub-Menu -->
    <div id="ai-menu" class="modal-overlay">
        <h2>Player vs AI</h2>
        <button class="menu-button" id="ai-straight-ball-button">STRAIGHT BALL</button>
        <button class="menu-button" id="ai-poker-button">POKER</button>
        <button class="menu-button back-button" id="ai-back-button">Back</button>
    </div>

    <!-- Difficulty Selection Overlay -->
    <div id="difficulty-select" class="modal-overlay">
        <h2>Select Difficulty</h2>
        <button class="menu-button" data-difficulty="easy">Easy</button>
        <button class="menu-button" data-difficulty="hard">Hard</button>
        <button class="menu-button" data-difficulty="pro">Pro</button>
        <button class="menu-button back-button" id="difficulty-back-button">Back</button>
    </div>
    
    <!-- Instruction Modals -->
    <div id="straight-ball-instructions" class="modal-overlay instruction-modal">
        <div class="content">
            <h2>Straight Ball Rules</h2>
            <p>
                - The first player to pocket a ball will be assigned that color (blue or red).<br>
                - Your goal is to pocket all of your assigned balls.<br>
                - Pocketing the cue ball or your opponent's ball is a foul.<br>
                - The first to clear their balls from the table wins!
            </p>
            <button class="menu-button" id="play-straight-ball-button">Play</button>
        </div>
    </div>

    <div id="poker-instructions" class="modal-overlay instruction-modal">
        <div class="content">
            <h2>Poker Pool Rules</h2>
            <p>
                - You are dealt 7 cards. Each card corresponds to a numbered ball.<br>
                - Your goal is to pocket the balls that match your cards.<br>
                - The **King** is a bonus card! You don't need to pocket it.<br>
                - Win by clearing all non-King cards from your hand.
            </p>
            <button class="menu-button" id="play-poker-button">Play</button>
        </div>
    </div>
    
    <!-- NEW: Online Game Type Selection -->
    <div id="online-game-select" class="modal-overlay">
        <h2>Online: Select Game Type</h2>
        <button class="menu-button" id="online-poker-button">POKER POOL</button>
        <button class="menu-button" id="online-straight-ball-button">STRAIGHT BALL</button>
        <button class="menu-button back-button" id="online-select-back-button">Back</button>
    </div>

    <!-- Online Multiplayer Menu -->
    <div id="online-menu" class="modal-overlay">
        <h2>Online Multiplayer</h2>
        <button class="menu-button" id="create-game-button">Create Game</button>
        <input type="text" id="game-id-input" placeholder="Enter Game ID">
        <button class="menu-button" id="join-game-button">Join Game</button>
        <button class="menu-button back-button" id="online-back-button">Back</button>
    </div>

    <!-- Waiting Room -->
    <div id="waiting-room" class="modal-overlay">
        <h2>Waiting for Opponent...</h2>
        <p>Share this Game ID with your friend:</p>
        <div id="game-id-display" title="Click to copy"></div>
        <button class="menu-button back-button" id="cancel-game-button">Cancel</button>
    </div>


    <!-- Winner Modal -->
    <div id="winner-modal" class="modal-overlay">
        <h2 id="winner-text"></h2>
        <button id="play-again-button">Play Again</button>
        <div id="opponent-hand-reveal"></div>
    </div>

    <!-- Exit Confirmation Modal -->
    <div id="confirm-exit-modal" class="modal-overlay">
        <h2>Are you sure you want to exit?</h2>
        <p>This will count as a loss if you are in an online game.</p>
        <div class="button-group">
            <button id="confirm-exit-yes" class="menu-button confirm-button">Yes</button>
            <button id="confirm-exit-cancel" class="menu-button confirm-button">Cancel</button>
        </div>
    </div>

    <script type="module">
        // =========================================================================
        // FIREBASE SETUP
        // =========================================================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        let db, auth;
        let firebaseInitialized = false;

        // =========================================================================
        // DOM ELEMENTS
        // =========================================================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameWrapper = document.getElementById('game-wrapper');
        const messageBox = document.getElementById('message-box');
        const winnerModal = document.getElementById('winner-modal');
        const winnerText = document.getElementById('winner-text');
        const playerInfo = document.getElementById('player-info');
        const opponentInfo = document.getElementById('opponent-info');
        const powerControl = document.getElementById('power-control');
        const powerBar = document.getElementById('power-bar');
        const gameModeSelect = document.getElementById('game-mode-select');
        const difficultySelect = document.getElementById('difficulty-select');
        const onlineMenu = document.getElementById('online-menu');
        const exitButton = document.getElementById('exit-button');
        const vsAiButton = document.getElementById('vs-ai-button');
        const onlineButton = document.getElementById('online-button');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const gameIdInput = document.getElementById('game-id-input');
        const difficultyBackButton = document.getElementById('difficulty-back-button');
        const onlineBackButton = document.getElementById('online-back-button');
        const cardHandContainer = document.getElementById('card-hand-container');
        const opponentHandReveal = document.getElementById('opponent-hand-reveal');
        const playAgainButton = document.getElementById('play-again-button');
        const aiMenu = document.getElementById('ai-menu');
        const aiStraightBallButton = document.getElementById('ai-straight-ball-button');
        const aiPokerButton = document.getElementById('ai-poker-button');
        const aiBackButton = document.getElementById('ai-back-button');
        const straightBallInstructions = document.getElementById('straight-ball-instructions');
        const pokerInstructions = document.getElementById('poker-instructions');
        const playStraightBallButton = document.getElementById('play-straight-ball-button');
        const playPokerButton = document.getElementById('play-poker-button');
        const cueBallGuide = document.getElementById('cue-ball-guide');
        const waitingRoom = document.getElementById('waiting-room');
        const gameIdDisplay = document.getElementById('game-id-display');
        const cancelGameButton = document.getElementById('cancel-game-button');
        const onlineGameSelect = document.getElementById('online-game-select');
        const onlinePokerButton = document.getElementById('online-poker-button');
        const onlineStraightBallButton = document.getElementById('online-straight-ball-button');
        const onlineSelectBackButton = document.getElementById('online-select-back-button');
        const confirmExitModal = document.getElementById('confirm-exit-modal');
        const confirmExitYes = document.getElementById('confirm-exit-yes');
        const confirmExitCancel = document.getElementById('confirm-exit-cancel');
        const pektusControl = document.getElementById('pektus-control');
        const pektusDot = document.getElementById('pektus-dot');
        const leftArrow = document.getElementById('left-arrow');
        const rightArrow = document.getElementById('right-arrow');
        const fullscreenButton = document.getElementById('fullscreen-button');

        // =========================================================================
        // CONSTANTS & GAME STATE
        // =========================================================================
        const TABLE_ASPECT_RATIO = 2;
        const BALL_RADIUS = 18;
        const CUE_BALL_RADIUS = 24;
        const HOLE_RADIUS = 40;
        const FRICTION = 0.99; 
        const MIN_VELOCITY = 0.05;
        const ROTATION_SPEED = 0.001;
        
        const DEBUG_MODE = false; 

        // --- Game State Variables ---
        let scale = 1;
        let table = { width: 0, height: 0 };
        let chips = [];
        let holes = [];
        let cueStick = { angle: 0, length: 2000, visible: true, power: 0, pullback: 0 };
        let gameState = 'menu';
        let gameMode = 'ai-classic';
        let playerTurn = true;
        let colorsAssigned = false;
        let playerChipsType = null;
        let opponentChipsType = null;
        let canMoveCueBall = false;
        let chipsMoving = false;
        let chipsPocketedInTurn = [];
        let firstChipHitInTurn = null;
        let isPoweringUp = false;
        let isAimingOnCanvas = false;
        let isDraggingCueBall = false;
        let difficulty = 'easy';
        let deck = [];
        let playerHand = [];
        let opponentHand = [];
        let originalPlayerHand = [];
        let originalOpponentHand = [];
        let selectedGameConfig = {}; 
        let isBreakShot = false;
        let pektusOffset = { x: 0, y: 0 };
        let shotPektusOffset = { x: 0, y: 0 };
        let isDraggingPektusDot = false;
        let isRotatingLeft = false;
        let isRotatingRight = false;

        // --- Online Multiplayer Variables ---
        let gameId = null;
        let localPlayerId = null;
        let localPlayerUid = null;
        let currentTurnUid = null;
        let unsubscribeGameListener;
        let isOnlineGame = false;
        let isMyTurnOnline = false;
        let turnInProgress = false;
        let selectedOnlineGameType = 'poker';
        let lastAimUpdateTime = 0;
        const AIM_UPDATE_THROTTLE = 50; // milliseconds

        // --- Audio State ---
        let audioInitialized = false;
        let collisionSynth, pocketSynth;
        let lastCollisionSoundTime = -1;

        const cueStickImage = new Image();
        cueStickImage.src = 'https://i.imgur.com/FYXWKhr.png';

        // =========================================================================
        // AUDIO HANDLING
        // =========================================================================
        
        function initAudio() {
            if (audioInitialized || typeof Tone === 'undefined') return;
            
            Tone.start().then(() => {
                audioInitialized = true; 

                collisionSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 2,
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.001,
                        decay: 0.2,
                        sustain: 0.01,
                        release: 0.2,
                        attackCurve: "exponential"
                    }
                }).toDestination();
                collisionSynth.volume.value = -6;

                pocketSynth = new Tone.NoiseSynth({
                    noise: { type: 'brown' },
                    envelope: { attack: 0.005, decay: 0.15, sustain: 0.1 }
                }).toDestination();
                pocketSynth.volume.value = -8;

                console.log("Audio Initialized for Game Sounds.");
            }).catch(e => {
                console.error("Could not start Tone.js audio context:", e);
            });
        }

        function playCollisionSound(speed) {
            if (!audioInitialized) return;
            const now = Tone.now();
            if (now <= lastCollisionSoundTime) return;
            lastCollisionSoundTime = now + 0.05; 

            const volume = -12 + Math.min(1, speed / 20) * 12;
            const note = speed > 10 ? 'C2' : 'G1';
            collisionSynth.triggerAttackRelease(note, "8n", now);
            collisionSynth.volume.value = volume;
        }

        function playCushionSound(speed) {
            playCollisionSound(speed * 0.7); 
        }

        function playPocketSound() {
            if (!audioInitialized) return;
            pocketSynth.triggerAttackRelease("0.2");
        }

        // =========================================================================
        // GAME INITIALIZATION & MAIN LOOP
        // =========================================================================

        function init() {
            resizeCanvas();
            setupEventListeners();
            initializeFirebase(); 
            update();
        }

        function update() {
            const oldAngle = cueStick.angle;
            if (isRotatingLeft) {
                cueStick.angle -= ROTATION_SPEED;
            }
            if (isRotatingRight) {
                cueStick.angle += ROTATION_SPEED;
            }
            if (oldAngle !== cueStick.angle) {
                updateOnlineCueState();
            }

            if (chipsMoving) {
                updateChipPositions();
            }
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTable();
            drawChips();

            if (gameState === 'aiming' || gameState === 'shooting_animation') {
                 drawCueStick();
            }

            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            if (isMyTurn && gameState === 'aiming') {
                 drawGuidelines();
            }
        }

        // =========================================================================
        // CANVAS & TABLE SETUP
        // =========================================================================

        function resizeCanvas() {
            const oldTableWidth = table.width;
            const oldTableHeight = table.height;
            const chipRatios = chips.map(c => ({
                x: oldTableWidth > 0 ? c.x / oldTableWidth : 0.5,
                y: oldTableHeight > 0 ? c.y / oldTableHeight : 0.5
            }));

            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const screenAspectRatio = containerWidth / containerHeight;

            if (screenAspectRatio > TABLE_ASPECT_RATIO) {
                table.height = containerHeight;
                table.width = table.height * TABLE_ASPECT_RATIO;
            } else {
                table.width = containerWidth;
                table.height = table.width / TABLE_ASPECT_RATIO;
            }
            
            scale = table.width / 1000;
            canvas.width = table.width;
            canvas.height = table.height;
            
            setupHoles();
            
            if (chips.length > 0) {
                chips.forEach((chip, i) => {
                    const radiusConstant = chip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS;
                    chip.x = chipRatios[i].x * table.width;
                    chip.y = chipRatios[i].y * table.height;
                    chip.radius = radiusConstant * scale;
                });
            }
            cueStick.length = 550 * scale;
        }

        function setupHoles() {
            const hr = HOLE_RADIUS * scale;
            holes = [
                { x: 0, y: 0, radius: hr }, 
                { x: table.width, y: 0, radius: hr }, 
                { x: 0, y: table.height, radius: hr }, 
                { x: table.width, y: table.height, radius: hr }
            ];
        }

        function setupChips() {
            chips = [];
            const newChip = { 
                id: 0, x: table.width * 0.25, y: table.height / 2, 
                vx: 0, vy: 0, radius: CUE_BALL_RADIUS * scale, inPlay: true, color: 'white', type: 'cue',
                isPocketing: false, pocketingProgress: 0, pocketingHole: null
            };
            chips.push(newChip);

            const objectChipRadius = BALL_RADIUS * scale;
            
            const redChipsSource = [];
            const blueChipsSource = [];
            for (let i = 1; i <= 12; i++) {
                if (i <= 6) { 
                    blueChipsSource.push({ id: i, color: '#007BFF', type: 'blue' });
                } else { 
                    redChipsSource.push({ id: i, color: '#DC3545', type: 'red' });
                }
            }
            
            const startX = table.width * 0.7;
            const startY = table.height / 2;
            const colSpacing = objectChipRadius * 2.1;
            const rowSpacing = objectChipRadius * 1.8;
            
            const positions = [];
            const rows = 4;
            const cols = 3;
            
            const totalHeight = (rows - 1) * rowSpacing;
            const initialY = startY - totalHeight / 2;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    positions.push({
                        x: startX + col * colSpacing,
                        y: initialY + row * rowSpacing
                    });
                }
            }

            for (let i = 0; i < positions.length; i++) {
                let chipData;
                if (i % 2 === 0) {
                    chipData = redChipsSource.pop();
                } else {
                    chipData = blueChipsSource.pop();
                }

                if (chipData) {
                    const newObjectChip = {
                        id: chipData.id,
                        x: positions[i].x,
                        y: positions[i].y,
                        vx: 0, vy: 0,
                        radius: objectChipRadius,
                        inPlay: true,
                        color: chipData.color,
                        type: chipData.type,
                        isPocketing: false, pocketingProgress: 0, pocketingHole: null
                    };
                    chips.push(newObjectChip);
                }
            }
        }
        
        // =========================================================================
        // DRAWING FUNCTIONS
        // =========================================================================

        function drawTable() {
            ctx.save();
            ctx.translate(table.width / 2, table.height / 2);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `italic bold ${80 * scale}px Georgia`;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillText("Pinoy Pool Master", 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#1a1a1a';
            holes.forEach(hole => {
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawChips() {
            chips.forEach(chip => {
                if (chip.inPlay) {
                    let displayRadius = chip.radius;
                    if (chip.isPocketing) {
                        displayRadius = chip.radius * (1 - chip.pocketingProgress);
                    }

                    ctx.beginPath();
                    ctx.arc(chip.x, chip.y, displayRadius, 0, Math.PI * 2);
                    ctx.fillStyle = chip.color;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = displayRadius * 0.2;
                    ctx.stroke();

                    if (chip.id === 0) {
                        ctx.strokeStyle = '#808080';
                        ctx.lineWidth = displayRadius * 0.1;
                        ctx.beginPath();
                        ctx.arc(chip.x, chip.y, displayRadius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = '#808080';
                        ctx.beginPath();
                        ctx.arc(chip.x, chip.y, displayRadius * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = 'white';
                        ctx.font = `bold ${displayRadius * 1.2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(chip.id, chip.x, chip.y);
                    }
                }
            });
        }

        function drawCueStick() {
            if (!cueStick.visible || !chips[0] || !chips[0].inPlay) return;
            const cueChip = chips[0];

            ctx.save();
            ctx.translate(cueChip.x, cueChip.y);
            ctx.rotate(cueStick.angle);

            const stickOffset = 15 * scale;
            const stickHeight = 150 * scale;
            const stickDrawStart = -(cueChip.radius + stickOffset + cueStick.length) - cueStick.pullback;

            if (cueStickImage.complete && cueStickImage.naturalHeight !== 0) {
                ctx.drawImage(
                    cueStickImage,
                    stickDrawStart,
                    -stickHeight / 2,
                    cueStick.length,
                    stickHeight
                );
            } else {
                ctx.beginPath();
                const tipX = stickDrawStart + cueStick.length;
                const buttX = stickDrawStart;
                ctx.moveTo(tipX, 0);
                ctx.lineTo(buttX, 0);
                ctx.strokeStyle = '#a0522d';
                ctx.lineWidth = 5 * scale;
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawGuidelines() {
            if (gameState !== 'aiming' || chipsMoving) return;
            
            const cueChip = chips[0];
            if (!cueChip || !cueChip.inPlay) return;

            const angle = cueStick.angle;
            const shotVector = { x: Math.cos(angle), y: Math.sin(angle) };
            let firstHit = null;
            let minCollisionDist = Infinity;

            for (const targetChip of chips) {
                if (targetChip.id === 0 || !targetChip.inPlay) continue;
                const cueToTarget = { x: targetChip.x - cueChip.x, y: targetChip.y - cueChip.y };
                const projDist = cueToTarget.x * shotVector.x + cueToTarget.y * shotVector.y;
                if (projDist <= 0) continue;
                const closestPointOnPath = { x: cueChip.x + projDist * shotVector.x, y: cueChip.y + projDist * shotVector.y };
                const perpDistSq = (closestPointOnPath.x - targetChip.x)**2 + (closestPointOnPath.y - targetChip.y)**2;
                const combinedRadiusSq = (cueChip.radius + targetChip.radius)**2;
                if (perpDistSq >= combinedRadiusSq) continue;
                const travelDist = projDist - Math.sqrt(combinedRadiusSq - perpDistSq);
                if (travelDist < minCollisionDist) {
                    minCollisionDist = travelDist;
                    firstHit = { chip: targetChip, travelDist: travelDist };
                }
            }
            
            ctx.setLineDash([5 * scale, 5 * scale]);
            ctx.lineWidth = 2.0 * scale; 
            const guidelineLength = 1.0; 

            if (firstHit) {
                const impactPoint = { x: cueChip.x + firstHit.travelDist * shotVector.x, y: cueChip.y + firstHit.travelDist * shotVector.y };
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.moveTo(cueChip.x, cueChip.y);
                ctx.lineTo(impactPoint.x, impactPoint.y);
                ctx.stroke();
                const objectChip = firstHit.chip;
                const collisionNormal = { x: objectChip.x - impactPoint.x, y: objectChip.y - impactPoint.y };
                const normMag = Math.sqrt(collisionNormal.x**2 + collisionNormal.y**2);
                const unitNormal = { x: collisionNormal.x / normMag, y: collisionNormal.y / normMag };
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.beginPath();
                ctx.moveTo(objectChip.x, objectChip.y);
                const yellowLineLength = 40; 
                ctx.lineTo(objectChip.x + unitNormal.x * yellowLineLength * guidelineLength, objectChip.y + unitNormal.y * yellowLineLength * guidelineLength);
                ctx.stroke();
                
                const tangentVector = { x: -unitNormal.y, y: unitNormal.x };
                const dotProduct = tangentVector.x * shotVector.x + tangentVector.y * shotVector.y;
                if (dotProduct < 0) {
                    tangentVector.x *= -1;
                    tangentVector.y *= -1;
                }

                const spinEffectFactor = 1.5;
                const sideSpinAngle = pektusOffset.x * spinEffectFactor;
                const followFactor = 1 - (pektusOffset.y * 0.8);

                const deflectedCueVector = {
                    x: tangentVector.x * Math.cos(sideSpinAngle) - tangentVector.y * Math.sin(sideSpinAngle),
                    y: tangentVector.x * Math.sin(sideSpinAngle) + tangentVector.y * Math.cos(sideSpinAngle)
                };
                
                const finalCueVector = {
                    x: (deflectedCueVector.x * 0.7 + shotVector.x * 0.3) * followFactor,
                    y: (deflectedCueVector.y * 0.7 + shotVector.y * 0.3) * followFactor
                };

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.moveTo(impactPoint.x, impactPoint.y);
                ctx.lineTo(impactPoint.x + finalCueVector.x * 2000 * guidelineLength, impactPoint.y + finalCueVector.y * 2000 * guidelineLength);
                ctx.stroke();

            } else {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.moveTo(cueChip.x, cueChip.y);
                ctx.lineTo(cueChip.x + shotVector.x * 2000 * guidelineLength, cueChip.y + shotVector.y * 2000 * guidelineLength);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        // =========================================================================
        // PHYSICS & COLLISION
        // =========================================================================
        
        function updateChipPositions() {
            const subSteps = 8;
            const dt = 1.0 / subSteps;

            for (let i = 0; i < subSteps; i++) {
                chips.forEach(chip => {
                    if (chip.inPlay && !chip.isPocketing) {
                        chip.x += chip.vx * dt;
                        chip.y += chip.vy * dt;
                    }
                });

                for (let j = 0; j < chips.length; j++) {
                    const chip1 = chips[j];
                    if (!chip1.inPlay || chip1.isPocketing) continue;

                    if (chip1.x + chip1.radius > table.width) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = table.width - chip1.radius; }
                    if (chip1.x - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = chip1.radius; }
                    if (chip1.y + chip1.radius > table.height) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = table.height - chip1.radius; }
                    if (chip1.y - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = chip1.radius; }

                    for (let k = j + 1; k < chips.length; k++) {
                        const chip2 = chips[k];
                        if (chip2.inPlay && !chip2.isPocketing) {
                            handleChipCollision(chip1, chip2);
                        }
                    }
                }
            }

            let stillMoving = false;
            chips.forEach(chip => {
                if (chip.inPlay) {
                    if (chip.isPocketing) {
                        chip.pocketingProgress += 0.05;
                        const progress = chip.pocketingProgress;

                        const dx = chip.pocketingHole.x - chip.x;
                        const dy = chip.pocketingHole.y - chip.y;
                        chip.x += dx * 0.1;
                        chip.y += dy * 0.1;

                        if (progress >= 1) {
                            chip.inPlay = false;
                            chip.isPocketing = false;
                        }
                    } else {
                        chip.vx *= FRICTION;
                        chip.vy *= FRICTION;

                        if (Math.abs(chip.vx) < MIN_VELOCITY) chip.vx = 0;
                        if (Math.abs(chip.vy) < MIN_VELOCITY) chip.vy = 0;

                        holes.forEach(hole => {
                            if (Math.sqrt((hole.x - chip.x)**2 + (hole.y - chip.y)**2) < hole.radius) {
                                playPocketSound();
                                chip.isPocketing = true;
                                chip.pocketingHole = hole;
                                chip.vx = 0;
                                chip.vy = 0;
                                if (!chipsPocketedInTurn.find(p => p.id === chip.id)) {
                                    chipsPocketedInTurn.push(chip);
                                }
                            }
                        });
                    }

                    if (chip.vx !== 0 || chip.vy !== 0 || chip.isPocketing) {
                        stillMoving = true;
                    }
                }
            });
            
            chipsMoving = stillMoving;
            if (!chipsMoving) {
                if (isOnlineGame) {
                    if (isMyTurnOnline) {
                        setTimeout(handleTurnEnd, 200);
                    }
                } else {
                    setTimeout(handleTurnEnd, 200);
                }
            }
        }

        function handleChipCollision(chip1, chip2) {
            const dx = chip2.x - chip1.x, dy = chip2.y - chip1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const combinedRadius = chip1.radius + chip2.radius;

            if (dist < combinedRadius) {
                const impactSpeed = Math.sqrt((chip1.vx - chip2.vx)**2 + (chip1.vy - chip2.vy)**2);
                if (impactSpeed > 0.1) playCollisionSound(impactSpeed);

                if (firstChipHitInTurn === null) {
                    if (chip1.id === 0) firstChipHitInTurn = chip2;
                    else if (chip2.id === 0) firstChipHitInTurn = chip1;
                }

                const angle = Math.atan2(dy, dx), sin = Math.sin(angle), cos = Math.cos(angle);
                let vel1 = { x: chip1.vx * cos + chip1.vy * sin, y: chip1.vy * cos - chip1.vx * sin };
                let vel2 = { x: chip2.vx * cos + chip2.vy * sin, y: chip2.vy * cos - chip2.vx * sin };
                const vxTotal = vel1.x - vel2.x;
                vel1.x = ((chip1.radius - chip2.radius) * vel1.x + 2 * chip2.radius * vel2.x) / combinedRadius;
                vel2.x = vxTotal + vel1.x;
                
                const overlap = combinedRadius - dist;
                chip1.x -= (overlap / 2) * cos; chip1.y -= (overlap / 2) * sin;
                chip2.x += (overlap / 2) * cos; chip2.y += (overlap / 2) * sin;
                
                let cueChip;
                if (chip1.id === 0) {
                    cueChip = chip1;
                } else if (chip2.id === 0) {
                    cueChip = chip2;
                }

                if (cueChip) {
                    const spinFactor = 0.5;
                    const followFactor = 0.2;
                    
                    const sideSpin = shotPektusOffset.x * spinFactor;
                    vel1.y += sideSpin * Math.abs(vxTotal);
                    
                    if (shotPektusOffset.y < 0) {
                        const followSpin = shotPektusOffset.y * followFactor;
                        const followEnergy = Math.abs(vel1.x * followSpin);
                        vel1.x += followEnergy;
                        vel2.x -= followEnergy;
                    }
                }
                
                chip1.vx = vel1.x * cos - vel1.y * sin; chip1.vy = vel1.y * cos + vel1.x * sin;
                chip2.vx = vel2.x * cos - vel2.y * sin; chip2.vy = vel2.y * cos + vel2.x * sin;
            }
        }
        
        // =========================================================================
        // GAME LOGIC
        // =========================================================================

        function startGame(mode, difficultyLevel = 'easy') {
            gameMode = mode;
            isOnlineGame = false;
            difficulty = difficultyLevel;
            
            cueBallGuide.style.display = 'none'; 

            gameModeSelect.style.display = 'none';
            difficultySelect.style.display = 'none';
            aiMenu.style.display = 'none';
            onlineMenu.style.display = 'none';
            winnerModal.style.display = 'none';

            playerTurn = true;
            canMoveCueBall = false; 
            chipsMoving = false;
            colorsAssigned = false; 
            playerChipsType = null; 
            opponentChipsType = null;
            
            setupChips();
            
            isBreakShot = true;
            canMoveCueBall = true;
            gameState = 'moving';
            
            // BUG FIX: Ensure cue stick is visible at the start of a new game.
            cueStick.visible = true;
            
            showMessage("Place the cue ball for your break shot.", 3000);
            
            resetPektus();

            if (gameMode.includes('poker')) {
                createDeck();
                dealCards();
                updateCardDisplay();
            } else {
                cardHandContainer.style.display = 'none';
            }
            updateInfoBox();
        }

        // =========================================================================
        // TURN LOGIC - DUAL MODE
        // =========================================================================
        async function handleTurnEnd() {
            if (isOnlineGame && !turnInProgress) {
                return;
            }
            
            if (gameMode.includes('poker')) {
                await handlePokerTurnEnd();
            } else if (gameMode.includes('straight-ball')) {
                await handleStraightBallTurnEnd();
            }
        }

        async function handlePokerTurnEnd() {
            let foul = false;
            let switchTurn = true; 
            
            const currentPlayerHand = isOnlineGame ? playerHand : (playerTurn ? playerHand : opponentHand);

            if (chipsPocketedInTurn.some(c => c.id === 0)) {
                foul = true;
                showMessage(`Cue ball pocketed! Foul.`);
                const cueChip = chips.find(c => c.id === 0);
                cueChip.inPlay = true; 
                cueChip.x = table.width * 0.25; 
                cueChip.y = table.height / 2;
                cueChip.isPocketing = false;
                cueChip.pocketingProgress = 0;
            }
            
            if (!foul && firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0)) {
                foul = true;
                showMessage(`Didn't hit any ball! Foul.`);
            }

            const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);

            if (pocketedObjectChips.length > 0) {
                const pocketedIds = pocketedObjectChips.map(c => c.id);
                playerHand = playerHand.filter(card => !pocketedIds.includes(card.value));
                opponentHand = opponentHand.filter(card => !pocketedIds.includes(card.value));
            }

            if (!foul) {
                if (pocketedObjectChips.length > 0) {
                    const allPocketedAreMine = pocketedObjectChips.every(chip => 
                        currentPlayerHand.some(card => card.value === chip.id)
                    );

                    if (allPocketedAreMine) {
                        switchTurn = false;
                    } else {
                        switchTurn = true; 
                    }
                } else {
                    switchTurn = true;
                }
            }
            
            isBreakShot = false;

            if (foul) {
                switchTurn = true; 
                canMoveCueBall = true;
                cueBallGuide.textContent = `Ball in hand! Drag the cue ball to place it.`;
                if ((isOnlineGame && isMyTurnOnline) || !isOnlineGame) {
                    cueBallGuide.style.display = 'block';
                }
            }
            
            if (checkWinCondition()) return;

            if (isOnlineGame) {
                await updateOnlineGameState(switchTurn);
            } else {
                updateLocalGameState(switchTurn);
            }
        }

        async function handleStraightBallTurnEnd() {
            let foul = false;
            let switchTurn = true;
            
            const currentPlayerColor = isOnlineGame ? playerChipsType : (playerTurn ? playerChipsType : opponentChipsType);

            if (chipsPocketedInTurn.some(c => c.id === 0)) {
                foul = true;
                showMessage(`Cue ball pocketed! Foul.`);
                const cueChip = chips.find(c => c.id === 0);
                cueChip.inPlay = true; 
                cueChip.x = table.width * 0.25; 
                cueChip.y = table.height / 2;
                cueChip.isPocketing = false;
                cueChip.pocketingProgress = 0;
            }

            const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);

            if (!foul) {
                if (!colorsAssigned && pocketedObjectChips.length > 0) {
                    const firstPocketed = pocketedObjectChips[0];
                    if (isOnlineGame) {
                        if (localPlayerId === 'player1') {
                            playerChipsType = firstPocketed.type;
                            opponentChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
                        } else {
                            opponentChipsType = firstPocketed.type;
                            playerChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
                        }
                    } else {
                        if (playerTurn) {
                            playerChipsType = firstPocketed.type;
                            opponentChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
                        } else {
                            opponentChipsType = firstPocketed.type;
                            playerChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
                        }
                    }
                    colorsAssigned = true;
                    showMessage(`Colors assigned! You are ${playerChipsType}.`);
                    switchTurn = false; 
                } 
                else if (colorsAssigned) {
                    const myPocketed = pocketedObjectChips.filter(c => c.type === currentPlayerColor);
                    const opponentPocketed = pocketedObjectChips.filter(c => c.type !== currentPlayerColor && c.type !== 'cue');

                    if (myPocketed.length > 0 && opponentPocketed.length === 0) {
                        switchTurn = false; 
                    } else if (opponentPocketed.length > 0) {
                        foul = true;
                        showMessage("Foul! Pocketed opponent's ball.");
                        switchTurn = true;
                    } else {
                        switchTurn = true;
                    }
                }
            }

            if (foul) {
                switchTurn = true;
                canMoveCueBall = true;
            }
            
            isBreakShot = false;

            if (checkWinCondition()) return;

            if (isOnlineGame) {
                await updateOnlineGameState(switchTurn);
            } else {
                updateLocalGameState(switchTurn);
            }
        }

        async function updateOnlineGameState(switchTurn) {
            try {
                const gameDocRef = doc(db, "games", gameId);
                const docSnap = await getDoc(gameDocRef);
                if (!docSnap.exists()) return;
                const gameData = docSnap.data();
                
                let nextTurnUid = gameData.currentTurnUid;
                if (switchTurn) {
                    nextTurnUid = (gameData.currentTurnUid === gameData.players.player1.uid) 
                        ? gameData.players.player2.uid 
                        : gameData.players.player1.uid;
                }

                const updatedData = {
                    chips: chips.map(c => ({...c})),
                    currentTurnUid: nextTurnUid,
                    canMoveCueBall: canMoveCueBall,
                    isBreakShot: false,
                    turnInProgress: false
                };

                if (gameMode.includes('poker')) {
                    updatedData.player1Hand = localPlayerId === 'player1' ? playerHand : opponentHand;
                    updatedData.player2Hand = localPlayerId === 'player1' ? opponentHand : playerHand;
                } else if (gameMode.includes('straight-ball')) {
                    updatedData.colorsAssigned = colorsAssigned;
                    if (localPlayerId === 'player1') {
                        updatedData.player1ChipsType = playerChipsType;
                        updatedData.player2ChipsType = opponentChipsType;
                    } else {
                        updatedData.player1ChipsType = opponentChipsType;
                        updatedData.player2ChipsType = playerChipsType;
                    }
                }

                await updateDoc(gameDocRef, updatedData);
            } catch (error) {
                console.error("Error updating game state:", error);
                showMessage("Connection error. Could not update game.", 3000);
            }
        }

        function updateLocalGameState(switchTurn) {
            if (switchTurn) {
                playerTurn = !playerTurn;
                const nextPlayerName = playerTurn ? 'You' : 'Opponent';
                showMessage(`${nextPlayerName}'s turn`, 1500);
            }
            
            resetPektus();
            updateCardDisplay(); 
            updateInfoBox();

            if (gameState !== 'gameover') {
                if (canMoveCueBall) {
                    gameState = 'moving';
                    if (gameMode.includes('ai') && !playerTurn) placeCueChipForAI();
                } else {
                    gameState = 'aiming';
                    cueStick.visible = true;
                    if (gameMode.includes('ai') && !playerTurn) setTimeout(aiTurn, 1000);
                }
            }
        }


        function checkWinCondition() {
            const player1Name = isOnlineGame ? 'You' : 'You';
            const player2Name = isOnlineGame ? 'Opponent' : 'Opponent';
            let playerWon = false;
            let opponentWon = false;

            if (gameMode.includes('poker')) {
                const p1Hand = isOnlineGame ? playerHand : playerHand;
                const p2Hand = isOnlineGame ? opponentHand : opponentHand;
                playerWon = p1Hand.length === 0 || p1Hand.every(card => card.rank === 'K');
                opponentWon = p2Hand.length === 0 || p2Hand.every(card => card.rank === 'K');
            } else if (gameMode.includes('straight-ball')) {
                if (colorsAssigned) {
                    const myChipsLeft = chips.some(c => c.inPlay && c.type === playerChipsType);
                    const opponentChipsLeft = chips.some(c => c.inPlay && c.type === opponentChipsType);
                    if (!myChipsLeft) playerWon = true;
                    if (!opponentChipsLeft) opponentWon = true;
                }
            }

            if (playerWon) {
                endGame(`${player1Name} Win!`);
                return true;
            }
            if (opponentWon) {
                endGame(`${player2Name} Wins!`);
                return true;
            }
            
            return false;
        }

        async function shoot(shotPower) {
            if (gameState !== 'aiming' || chipsMoving) return;
            
            chipsPocketedInTurn = [];
            firstChipHitInTurn = null;
            shotPektusOffset = { ...pektusOffset };
            
            const shotData = {
                uid: localPlayerUid,
                angle: cueStick.angle,
                power: shotPower,
                pektus: shotPektusOffset,
                timestamp: Date.now()
            };

            gameState = 'shooting_animation';
            
            let startTime = null;
            const animationDuration = 100;
            const startPullback = cueStick.pullback;
            const endPullback = -30 * scale;

            function animateShot(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / animationDuration, 1);
                cueStick.pullback = startPullback + (endPullback - startPullback) * progress;

                if (progress < 1) {
                    requestAnimationFrame(animateShot);
                } else {
                    cueStick.visible = false;
                    cueStick.power = 0;
                    powerBar.style.height = '0%';
                    cueStick.pullback = 0;

                    if (isOnlineGame) {
                        applyShot(shotData); 
                        try {
                            const gameDocRef = doc(db, "games", gameId);
                            updateDoc(gameDocRef, { 
                                lastShot: shotData,
                                turnInProgress: true 
                            });
                        } catch (error) {
                            console.error("Error sending shot data:", error);
                        }
                    } else {
                        applyShot(shotData);
                    }
                }
            }

            requestAnimationFrame(animateShot);
        }
        
        function applyShot(shotData) {
            const cueChip = chips[0];
            if (!cueChip || !cueChip.inPlay) return;
            
            shotPektusOffset = shotData.pektus || { x: 0, y: 0 };

            cueChip.vx = Math.cos(shotData.angle) * shotData.power * scale;
            cueChip.vy = Math.sin(shotData.angle) * shotData.power * scale;
            chipsMoving = true; 
            gameState = 'shooting';
        }

        async function endGame(winnerTextMessage) {
            if (gameState === 'gameover') return;

            if (isOnlineGame && turnInProgress) {
                try {
                    const gameDocRef = doc(db, "games", gameId);
                    const docSnap = await getDoc(gameDocRef);
                    if (docSnap.exists() && docSnap.data().gameState !== 'finished') {
                        let winnerUid = null;
                        if (winnerTextMessage.includes('You Win')) {
                            winnerUid = localPlayerUid;
                        } else if (winnerTextMessage.includes('Opponent Wins')) {
                            const gameData = docSnap.data();
                            const p1_uid = gameData.players.player1.uid;
                            const p2_uid = gameData.players.player2.uid;
                            winnerUid = localPlayerUid === p1_uid ? p2_uid : p1_uid;
                        }

                        if (winnerUid) {
                             const finalUpdate = {
                                gameState: 'finished',
                                winner: winnerUid,
                                chips: chips.map(c => ({...c})),
                                player1Hand: localPlayerId === 'player1' ? playerHand : opponentHand,
                                player2Hand: localPlayerId === 'player1' ? opponentHand : playerHand,
                                turnInProgress: false,
                            };
                            await updateDoc(gameDocRef, finalUpdate);
                        }
                    }
                } catch (e) {
                    console.error("Failed to send final game state:", e);
                }
            }
            
            gameState = 'gameover';
            winnerText.textContent = winnerTextMessage;

            if (gameMode.includes('poker')) {
                const handToShow = originalOpponentHand;
                const remainingHandToShow = opponentHand;
                const playerNameToShow = "Opponent's";

                const pocketedHandToShow = handToShow.filter(originalCard => 
                    !remainingHandToShow.some(remainingCard => 
                        remainingCard.rank === originalCard.rank && remainingCard.suit === originalCard.suit
                    )
                );

                const createCardDisplay = (title, hand) => {
                    let html = `<h3>${title}</h3>`;
                    if (hand && hand.length > 0) {
                        html += `<div style="display: flex; gap: 5px; justify-content: center;">`;
                        hand.forEach(card => {
                            const color = (card.suit === '♥' || card.suit === '♦') ? '#ff5555' : 'white';
                            html += `<div class="card" style="transform: scale(0.8);">
                                        <span class="card-rank" style="color: ${color};">${card.rank}</span>
                                        <span class="card-suit" style="color: ${color};">${card.suit}</span>
                                    </div>`;
                        });
                        html += `</div>`;
                    } else {
                        html += ``;
                    }
                    return html;
                };
                
                opponentHandReveal.innerHTML = createCardDisplay(`${playerNameToShow} Pocketed Cards:`, pocketedHandToShow);
                if(remainingHandToShow.length > 0) {
                    opponentHandReveal.innerHTML += createCardDisplay(`${playerNameToShow} Remaining Cards:`, remainingHandToShow);
                }

            } else {
                opponentHandReveal.innerHTML = '';
            }
            
            winnerModal.style.display = 'flex';
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }
        }

        // =========================================================================
        // AI LOGIC
        // =========================================================================

        function aiTurn() {
            if (gameState !== 'aiming' || chipsMoving || !chips[0] || !chips[0].inPlay) return;
            const cueChip = chips[0];
            
            let targetChips;
            if (gameMode === 'ai-poker') {
                targetChips = chips.filter(c => c.inPlay && opponentHand.some(card => card.value === c.id));
                if (targetChips.length === 0) {
                     targetChips = chips.filter(c => c.inPlay && c.id !== 0);
                }
            } else {
                let targetType = opponentChipsType;
                if (!colorsAssigned) {
                    targetType = Math.random() > 0.5 ? 'blue' : 'red';
                }
                targetChips = chips.filter(c => c.inPlay && c.type === targetType);
                
                if (targetChips.length === 0 && colorsAssigned) {
                    return;
                } else if (targetChips.length === 0) {
                    targetChips = chips.filter(c => c.inPlay && c.id !== 0);
                }
            }
            
            if(targetChips.length === 0) return;


            let bestShot = { score: -Infinity };
            for (const targetChip of targetChips) {
                for (const hole of holes) {
                    const targetToHoleAngle = Math.atan2(hole.y - targetChip.y, hole.x - targetChip.x);
                    const desiredCueX = targetChip.x - Math.cos(targetToHoleAngle) * (cueChip.radius + targetChip.radius);
                    const desiredCueY = targetChip.y - Math.sin(targetToHoleAngle) * (cueChip.radius + targetChip.radius);
                    
                    let isPathClear = true;
                    for(const otherChip of chips){
                        if(otherChip.inPlay && otherChip.id !== cueChip.id && otherChip.id !== targetChip.id){
                            const distToLine = Math.abs((desiredCueY-cueChip.y)*otherChip.x - (desiredCueX-cueChip.x)*otherChip.y + desiredCueX*cueChip.y - desiredCueY*cueChip.x) / Math.sqrt((desiredCueY-cueChip.y)**2 + (desiredCueX-cueChip.x)**2);
                            if(distToLine < otherChip.radius * 2) {
                                isPathClear = false;
                                break;
                            }
                        }
                    }
                    if(!isPathClear) continue;

                    const shotAngle = Math.atan2(desiredCueY - cueChip.y, desiredCueX - cueChip.x);
                    const distanceToTarget = Math.sqrt((targetChip.x - cueChip.x)**2 + (targetChip.y - cueChip.y)**2);
                    const score = 1000 - distanceToTarget;
                    
                    if (score > bestShot.score) {
                        bestShot = { angle: shotAngle, power: Math.min(1, (distanceToTarget / (table.width * 0.6)) + 0.2), score: score };
                    }
                }
            }
            
            if (bestShot.score === -Infinity) {
                const targetChip = targetChips.sort((a, b) => (a.x - cueChip.x)**2 + (a.y - cueChip.y)**2 - ((b.x - cueChip.x)**2 + (b.y - cueChip.y)**2))[0];
                if (!targetChip) return;
                bestShot.angle = Math.atan2(targetChip.y - cueChip.y, targetChip.x - cueChip.x);
                bestShot.power = 0.5;
            }

            if (difficulty === 'pro') {
                const consistency = 0.85; 
                if (Math.random() > consistency) {
                    const angleError = (Math.random() - 0.5) * 0.06; 
                    const powerError = 1 + (Math.random() - 0.5) * 0.3; 
                    bestShot.angle += angleError;
                    bestShot.power *= powerError;
                }
            } else if (difficulty === 'easy') {
                bestShot.angle += (Math.random() - 0.5) * 0.1; 
                bestShot.power *= (0.8 + Math.random() * 0.4); 
            }

            cueStick.angle = bestShot.angle;
            
            setTimeout(() => shoot(bestShot.power * 30 + 5), 700);
        }
        
        function placeCueChipForAI() {
            cueBallGuide.style.display = 'none';
            const cueChip = chips[0];
            gameState = 'ai_placing'; 

            const startX = table.width * 0.25;
            const startY = table.height / 2;
            
            const targetX = startX;
            const targetY = startY + (Math.random() - 0.5) * (table.height * 0.4);

            cueChip.x = startX;
            cueChip.y = startY;

            let startTime = null;
            const duration = 700; 

            function animateDrag(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                cueChip.x = startX + (targetX - startX) * progress;
                cueChip.y = startY + (targetY - startY) * progress;

                if (progress < 1) {
                    requestAnimationFrame(animateDrag);
                } else {
                    canMoveCueBall = false;
                    gameState = 'aiming';
                    setTimeout(aiTurn, 500);
                }
            }

            requestAnimationFrame(animateDrag);
        }

        // =========================================================================
        // POKER LOGIC
        // =========================================================================

        function createDeck() {
            deck = [];
            const suits = ['♥', '♦', '♣', '♠'];
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            for (const suit of suits) {
                for (const rank of ranks) {
                    let value;
                    if (rank === 'A') value = 1;
                    else if (rank === 'J') value = 11;
                    else if (rank === 'Q') value = 12;
                    else if (rank === 'K') value = 13;
                    else value = parseInt(rank);
                    deck.push({ suit, rank, value });
                }
            }
        }

        function dealCards() {
            playerHand = [];
            opponentHand = [];
            for (let i = 0; i < 7; i++) {
                playerHand.push(deck.splice(Math.floor(Math.random() * deck.length), 1)[0]);
                opponentHand.push(deck.splice(Math.floor(Math.random() * deck.length), 1)[0]);
            }
            originalPlayerHand = [...playerHand];
            originalOpponentHand = [...opponentHand];
        }

        // =========================================================================
        // UI & EVENT HANDLING
        // =========================================================================

        function addClickAndTouchListener(element, handler) {
            if (!element) return;
            element.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                handler(e);
            });
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    showMessage(`Hindi ma-activate ang full-screen mode.`, 2000);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function showMessage(msg, duration = 2000) {
            messageBox.textContent = msg;
            messageBox.style.display = 'block';
            setTimeout(() => {
                if (messageBox.textContent === msg) {
                    messageBox.style.display = 'none';
                }
            }, duration);
        }

        function updateInfoBox() {
            const player1Name = 'You';
            const player2Name = 'Opponent';
            
            const vibrantRed = '#ff6b6b';
            const vibrantBlue = '#54a0ff';

            if (gameMode.includes('poker')) {
                playerInfo.innerHTML = `${player1Name}: <span style="color: #ffffff;">${playerHand.length} cards left</span>`;
                opponentInfo.innerHTML = `${player2Name}: <span style="color: #ffffff;">${opponentHand.length} cards left</span>`;
            } else if (gameMode.includes('straight-ball')) {
                const myColorName = playerChipsType ? playerChipsType.toUpperCase() : '?';
                const theirColorName = opponentChipsType ? opponentChipsType.toUpperCase() : '?';
                const myDisplayColor = playerChipsType === 'red' ? vibrantRed : (playerChipsType === 'blue' ? vibrantBlue : 'white');
                const theirDisplayColor = opponentChipsType === 'red' ? vibrantRed : (opponentChipsType === 'blue' ? vibrantBlue : 'white');

                playerInfo.innerHTML = `${player1Name}: <span style="color: ${myDisplayColor};">${myColorName}</span>`;
                opponentInfo.innerHTML = `${player2Name}: <span style="color: ${theirDisplayColor};">${theirColorName}</span>`;
            }
        }
        
        function updateCardDisplay() {
            if (gameMode.includes('poker')) {
                cardHandContainer.style.display = 'flex';
                cardHandContainer.innerHTML = '';
                let currentHand = playerHand;
                
                if (!currentHand) return;

                currentHand.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    const rankSpan = document.createElement('span');
                    rankSpan.className = 'card-rank';
                    rankSpan.textContent = card.rank;
                    const suitSpan = document.createElement('span');
                    suitSpan.className = 'card-suit';
                    suitSpan.textContent = card.suit;

                    if (card.suit === '♥' || card.suit === '♦') {
                        rankSpan.style.color = '#ff5555'; 
                        suitSpan.style.color = '#ff5555';
                    } else {
                        rankSpan.style.color = 'white';
                        suitSpan.style.color = 'white';
                    }
                    
                    cardDiv.appendChild(rankSpan);
                    cardDiv.appendChild(suitSpan);
                    cardHandContainer.appendChild(cardDiv);
                });
            } else {
                cardHandContainer.style.display = 'none';
            }
            updateInfoBox();
        }

        function resetPektus() {
            pektusOffset = { x: 0, y: 0 };
            updatePektusUI();
        }

        function updatePektusUI() {
            const controlSize = pektusControl.offsetWidth;
            const dotSize = pektusDot.offsetWidth;
            const maxOffset = (controlSize / 2) - (dotSize / 2);

            const dotX = (pektusOffset.x * maxOffset) + (controlSize / 2);
            const dotY = (pektusOffset.y * maxOffset) + (controlSize / 2);

            pektusDot.style.left = `${dotX}px`;
            pektusDot.style.top = `${dotY}px`;
        }


        async function leaveOnlineGame() {
            if (isOnlineGame && gameId && localPlayerId && gameState !== 'gameover') {
                try {
                    const gameDocRef = doc(db, "games", gameId);
                    const updatePath = `players.${localPlayerId}.status`;
                    await updateDoc(gameDocRef, { [updatePath]: 'disconnected' });
                } catch (error) {
                    console.error("Error leaving/forfeiting game:", error);
                }
            }
        }

        async function resetToMenu() {
            await leaveOnlineGame();

            winnerModal.style.display = 'none';
            gameModeSelect.style.display = 'flex';
            aiMenu.style.display = 'none';
            difficultySelect.style.display = 'none';
            onlineMenu.style.display = 'none';
            onlineGameSelect.style.display = 'none';
            waitingRoom.style.display = 'none';
            straightBallInstructions.style.display = 'none';
            pokerInstructions.style.display = 'none';

            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }

            gameState = 'menu';
            isOnlineGame = false;
            gameId = null;
            localPlayerId = null;
            currentTurnUid = null;
            isMyTurnOnline = false;
            turnInProgress = false; 
            
            playerTurn = true;
            
            colorsAssigned = false;
            playerChipsType = null;
            opponentChipsType = null;
            canMoveCueBall = false;
            chipsMoving = false;
            isBreakShot = false;
            
            playerHand = [];
            opponentHand = [];
            updateCardDisplay(); 
            
            playerInfo.innerHTML = 'You: ?';
            opponentInfo.innerHTML = 'Opponent: ?';
            
            chips = [];
            draw(); 
        }
        
        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', resizeCanvas);
            
            window.addEventListener('beforeunload', () => {
                if (isOnlineGame && gameId && localPlayerId) {
                    leaveOnlineGame();
                }
            });

            addClickAndTouchListener(fullscreenButton, toggleFullScreen);

            addClickAndTouchListener(vsAiButton, () => { 
                gameModeSelect.style.display = 'none'; 
                aiMenu.style.display = 'flex'; 
            });
            
            addClickAndTouchListener(aiStraightBallButton, () => { 
                selectedGameConfig.mode = 'ai-straight-ball'; 
                aiMenu.style.display = 'none'; 
                difficultySelect.style.display = 'flex'; 
            });
            addClickAndTouchListener(aiPokerButton, () => { 
                selectedGameConfig.mode = 'ai-poker'; 
                aiMenu.style.display = 'none'; 
                difficultySelect.style.display = 'flex'; 
            });

            difficultySelect.querySelectorAll('.menu-button[data-difficulty]').forEach(button => {
                addClickAndTouchListener(button, (e) => {
                    selectedGameConfig.difficulty = e.currentTarget.dataset.difficulty;
                    difficultySelect.style.display = 'none';
                    if (selectedGameConfig.mode === 'ai-straight-ball') {
                        straightBallInstructions.style.display = 'flex';
                    } else {
                        pokerInstructions.style.display = 'flex';
                    }
                });
            });

            addClickAndTouchListener(difficultyBackButton, () => {
                difficultySelect.style.display = 'none';
                aiMenu.style.display = 'flex';
            });

            addClickAndTouchListener(playStraightBallButton, () => { 
                straightBallInstructions.style.display = 'none'; 
                initAudio(); 
                startGame(selectedGameConfig.mode, selectedGameConfig.difficulty); 
            });
            addClickAndTouchListener(playPokerButton, () => { 
                pokerInstructions.style.display = 'none'; 
                initAudio(); 
                startGame(selectedGameConfig.mode, selectedGameConfig.difficulty); 
            });
            
            addClickAndTouchListener(aiBackButton, resetToMenu);
            addClickAndTouchListener(onlineSelectBackButton, resetToMenu);
            addClickAndTouchListener(exitButton, () => {
                confirmExitModal.style.display = 'flex';
            });
            addClickAndTouchListener(playAgainButton, resetToMenu);

            addClickAndTouchListener(confirmExitYes, async () => {
                confirmExitModal.style.display = 'none';
                if (isOnlineGame && gameState !== 'gameover') {
                    await leaveOnlineGame();
                    endGame("You Lose!");
                } else {
                    if (gameMode === 'ai-poker' && gameState !== 'menu') {
                        endGame("You Lose!");
                    } else {
                        resetToMenu();
                    }
                }
            });
            addClickAndTouchListener(confirmExitCancel, () => {
                confirmExitModal.style.display = 'none';
            });

            addClickAndTouchListener(onlineButton, () => {
                if (!firebaseInitialized) {
                    showMessage("Kailangan ng internet para sa Online Multiplayer.", 3000);
                    return;
                }
                gameModeSelect.style.display = 'none';
                onlineGameSelect.style.display = 'flex';
            });
            addClickAndTouchListener(onlinePokerButton, () => { selectedOnlineGameType = 'poker'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; });
            addClickAndTouchListener(onlineStraightBallButton, () => { selectedOnlineGameType = 'straight-ball'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; });
            addClickAndTouchListener(onlineBackButton, () => { onlineMenu.style.display = 'none'; onlineGameSelect.style.display = 'flex'; });

            addClickAndTouchListener(createGameButton, createOnlineGame);
            addClickAndTouchListener(joinGameButton, joinOnlineGame);
            addClickAndTouchListener(cancelGameButton, cancelOnlineGame);
            addClickAndTouchListener(gameIdDisplay, () => {
                if(navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(gameIdDisplay.textContent).then(() => {
                        showMessage("Game ID copied to clipboard!", 1500);
                    }, () => {
                        showMessage("Failed to copy Game ID.", 1500);
                    });
                } else {
                    const textArea = document.createElement("textarea");
                    textArea.value = gameIdDisplay.textContent;
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showMessage("Game ID copied to clipboard!", 1500);
                    } catch (err) {
                        showMessage("Failed to copy Game ID.", 1500);
                    }
                    document.body.removeChild(textArea);
                }
            });

            canvas.addEventListener('mousedown', handlePointerDown);
            canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
            powerControl.addEventListener('mousedown', handlePointerDown);
            powerControl.addEventListener('touchstart', handlePointerDown, { passive: false });
            
            pektusControl.addEventListener('mousedown', handlePointerDown);
            pektusControl.addEventListener('touchstart', handlePointerDown, { passive: false });
            
            leftArrow.addEventListener('mousedown', handlePointerDown);
            leftArrow.addEventListener('touchstart', handlePointerDown, { passive: false });
            rightArrow.addEventListener('mousedown', handlePointerDown);
            rightArrow.addEventListener('touchstart', handlePointerDown, { passive: false });

            window.addEventListener('mouseup', handlePointerUp);
            window.addEventListener('touchend', handlePointerUp);

            window.addEventListener('mousemove', handlePointerMove);
            window.addEventListener('touchmove', handlePointerMove, { passive: false });
        }

        // =========================================================================
        // UNIFIED EVENT HANDLERS (PC + MOBILE)
        // =========================================================================

        function handlePointerDown(e) {
            e.preventDefault();
            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
            if (!isMyTurn || turnInProgress) return;

            const targetId = e.currentTarget.id;

            if (targetId === 'game-canvas') {
                if (gameState === 'moving' && canMoveCueBall) {
                    isDraggingCueBall = true;
                    updateCueBallPosition(e);
                } else if (gameState === 'aiming') {
                    isAimingOnCanvas = true;
                    updateAimFromCanvas(e);
                }
            } else if (targetId === 'power-control') {
                if (gameState === 'aiming') isPoweringUp = true;
            } else if (targetId === 'pektus-control') {
                if (gameState === 'aiming') {
                    isDraggingPektusDot = true;
                    handlePektusInput(e);
                }
            } else if (targetId === 'left-arrow') {
                if (gameState === 'aiming') isRotatingLeft = true;
            } else if (targetId === 'right-arrow') {
                if (gameState === 'aiming') isRotatingRight = true;
            }
        }

        function handlePointerMove(e) {
            if (isPoweringUp) { e.preventDefault(); updatePower(e); }
            if (isAimingOnCanvas) { e.preventDefault(); updateAimFromCanvas(e); }
            if (isDraggingCueBall) { e.preventDefault(); updateCueBallPosition(e); }
            if (isDraggingPektusDot) {
                e.preventDefault();
                handlePektusInput(e);
            }
        }

        function handlePointerUp() {
            if (isPoweringUp) {
                isPoweringUp = false;
                shoot(cueStick.power * 30 + 5);
            }
            if (isAimingOnCanvas) {
                isAimingOnCanvas = false;
            }
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                canMoveCueBall = false;
                gameState = 'aiming';
                cueBallGuide.style.display = 'none';

                // **BUG FIX**: I-sync ang pwesto ng cue ball pagkatapos ilagay
                if (isOnlineGame && isMyTurnOnline) {
                    try {
                        const gameDocRef = doc(db, "games", gameId);
                        updateDoc(gameDocRef, {
                            chips: chips.map(c => ({...c})), // Ipadala ang bagong pwesto ng mga bola
                            canMoveCueBall: false // Sabihin na tapos na ang paglalagay
                        });
                    } catch (error) {
                        console.error("Error syncing cue ball placement:", error);
                    }
                }
            }
            isDraggingPektusDot = false;
            isRotatingLeft = false;
            isRotatingRight = false;
        }

        function getEventPos(e, relativeTo) {
            const rect = relativeTo.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function updatePower(e) {
            const pos = getEventPos(e, powerControl);
            let p = pos.y / powerControl.clientHeight;
            cueStick.power = Math.max(0, Math.min(1, p));
            powerBar.style.height = `${p * 100}%`;

            const MAX_PULLBACK = 150 * scale;
            cueStick.pullback = cueStick.power * MAX_PULLBACK;
        }
        
        function updateAimFromCanvas(e) {
            const cueChip = chips[0];
            if (!cueChip || !cueChip.inPlay) return;
            const pos = getEventPos(e, canvas);
            const dx = cueChip.x - pos.x;
            const dy = cueChip.y - pos.y;
            cueStick.angle = Math.atan2(dy, dx);
            updateOnlineCueState();
        }

        function updateCueBallPosition(e) {
            const pos = getEventPos(e, canvas);
            const cueChip = chips[0];

            const breakLineX = table.width * 0.25;

            if (isBreakShot) {
                cueChip.x = Math.max(cueChip.radius, Math.min(breakLineX - cueChip.radius, pos.x));
                cueChip.y = Math.max(cueChip.radius, Math.min(table.height - cueChip.radius, pos.y));
            } else {
                cueChip.x = Math.max(cueChip.radius, Math.min(table.width - cueChip.radius, pos.x));
                cueChip.y = Math.max(cueChip.radius, Math.min(table.height - cueChip.radius, pos.y));
            }
        }

        function handlePektusInput(e) {
            const rect = pektusControl.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            let dx = x - centerX;
            let dy = y - centerY;
            
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = rect.width / 2;

            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }

            pektusOffset.x = dx / maxDist;
            pektusOffset.y = Math.min(0, dy / maxDist);

            updatePektusUI();
        }

        // =========================================================================
        // FIREBASE MULTIPLAYER LOGIC
        // =========================================================================
        
        function initializeFirebase() {
            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyD0gZfJxpA_4fO-SEOjX9JNs0v7IzQ0iSc",
                    authDomain: "pinoy-pool-master.firebaseapp.com",
                    projectId: "pinoy-pool-master",
                    storageBucket: "pinoy-pool-master.appspot.com",
                    messagingSenderId: "1003592334290",
                    appId: "1:1003592334290:web:2982cdc8691e8ef7c6260b"
                };

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                signInPlayer();
                firebaseInitialized = true;
                console.log("Firebase initialized successfully.");
            } catch (error) {
                console.warn("Firebase initialization failed. Running in offline mode.", error);
                firebaseInitialized = false;
            }
        }

        function signInPlayer() {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    localPlayerUid = user.uid;
                    console.log("Player signed in anonymously:", localPlayerUid);
                } else {
                    signInAnonymously(auth).catch((error) => {
                        console.error("Anonymous sign-in failed:", error);
                    });
                }
            });
        }

        async function createOnlineGame() {
            if (!localPlayerUid) {
                showMessage("Authenticating... Please try again in a moment.");
                return;
            }
            
            onlineMenu.style.display = 'none';
            
            setupChips();

            const newGameId = Math.random().toString(36).substring(2, 7).toUpperCase();
            gameId = newGameId;
            localPlayerId = 'player1';

            if (selectedOnlineGameType === 'poker') {
                createDeck();
                dealCards();
            }

            const gameData = {
                gameId: newGameId,
                gameType: selectedOnlineGameType,
                gameState: 'waiting',
                players: {
                    player1: { uid: localPlayerUid, ready: true, status: 'online' },
                    player2: null
                },
                chips: chips.map(c => ({...c})),
                currentTurnUid: localPlayerUid,
                lastShot: null,
                cueState: { angle: cueStick.angle, uid: localPlayerUid },
                turnInProgress: false, 
                canMoveCueBall: true,
                isBreakShot: true,
                winner: null,
                createdAt: Date.now()
            };

            if (selectedOnlineGameType === 'poker') {
                gameData.player1Hand = playerHand;
                gameData.player2Hand = opponentHand;
                gameData.originalPlayer1Hand = originalPlayerHand;
                gameData.originalPlayer2Hand = originalOpponentHand;
            } else {
                gameData.colorsAssigned = false;
                gameData.player1ChipsType = null;
                gameData.player2ChipsType = null;
            }

            try {
                const gameDocRef = doc(db, "games", newGameId);
                await setDoc(gameDocRef, gameData);
                
                gameIdDisplay.textContent = newGameId;
                waitingRoom.style.display = 'flex';
                listenToGameUpdates(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Failed to create game. Please check your connection.", 3000);
                onlineMenu.style.display = 'flex';
            }
        }

        async function joinOnlineGame() {
            if (!localPlayerUid) {
                showMessage("Authenticating... Please try again in a moment.");
                return;
            }

            const inputId = gameIdInput.value.trim().toUpperCase();
            if (!inputId) {
                showMessage("Please enter a Game ID.");
                return;
            }
            
            const gameDocRef = doc(db, "games", inputId);
            
            try {
                const docSnap = await getDoc(gameDocRef);

                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    if (gameData.players.player2 && gameData.players.player2.uid !== localPlayerUid) {
                        showMessage("This game is already full.");
                        return;
                    }

                    onlineMenu.style.display = 'none';
                    showMessage("Joining game...");

                    listenToGameUpdates(inputId);

                    await updateDoc(gameDocRef, {
                        'players.player2': { uid: localPlayerUid, ready: true, status: 'online' },
                        'gameState': 'playing'
                    });

                    gameId = inputId;
                    localPlayerId = 'player2';

                } else {
                    showMessage("Game not found. Please check the ID.");
                }
            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Failed to join game. Please check the ID and your connection.", 3000);
            }
        }

        async function cancelOnlineGame() {
            if (gameId) {
                const gameDocRef = doc(db, "games", gameId);
                await deleteDoc(gameDocRef);
                gameId = null;
            }
            resetToMenu();
        }
        
        function animateReceivedShot(shotData) {
            cueStick.angle = shotData.angle;
            cueStick.visible = true;
            gameState = 'shooting_animation';
            
            let startTime = null;
            const animationDuration = 100;
            
            const MAX_PULLBACK = 150 * scale;
            const shotPowerNormalized = (shotData.power - 5) / 30;
            const startPullback = shotPowerNormalized * MAX_PULLBACK;
            const endPullback = -30 * scale; 

            function animateOpponentShot(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / animationDuration, 1);
                cueStick.pullback = startPullback + (endPullback - startPullback) * progress;

                if (progress < 1) {
                    requestAnimationFrame(animateOpponentShot);
                } else {
                    cueStick.visible = false;
                    cueStick.pullback = 0;
                    applyShot(shotData);
                }
            }
            requestAnimationFrame(animateOpponentShot);
        }

        function updateOnlineCueState() {
            if (isOnlineGame && isMyTurnOnline && gameId) {
                const now = Date.now();
                if (now - lastAimUpdateTime < AIM_UPDATE_THROTTLE) {
                    return;
                }
                lastAimUpdateTime = now;

                const gameDocRef = doc(db, "games", gameId);
                updateDoc(gameDocRef, { 
                    cueState: {
                        angle: cueStick.angle,
                        uid: localPlayerUid
                    }
                }).catch(err => console.error("Could not update cue state:", err));
            }
        }

        function listenToGameUpdates(gameId) {
            const gameDocRef = doc(db, "games", gameId);
            let lastShotTimestamp = 0;

            unsubscribeGameListener = onSnapshot(gameDocRef, (doc) => {
                if (!doc.exists()) {
                    showMessage("The game was cancelled by the host.", 3000);
                    resetToMenu();
                    return;
                }

                const gameData = doc.data();
                if (!gameData) return;

                if (gameData.cueState && gameData.cueState.uid !== localPlayerUid) {
                    if (!isMyTurnOnline && gameState === 'aiming') {
                        cueStick.angle = gameData.cueState.angle;
                    }
                }

                if (gameData.lastShot && gameData.lastShot.timestamp > lastShotTimestamp) {
                    if (gameData.lastShot.uid !== localPlayerUid) {
                        animateReceivedShot(gameData.lastShot);
                    }
                    lastShotTimestamp = gameData.lastShot.timestamp;
                }

                syncGameState(gameData);
            });
        }

        function syncGameState(data) {
            if (localPlayerId && data.players) {
                const opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
                const opponent = data.players[opponentId];

                if (opponent && opponent.status === 'disconnected' && gameState !== 'gameover') {
                    endGame("You Win!");
                    return;
                }
            }

            const isCurrentlyInMenu = (gameState === 'menu' || waitingRoom.style.display === 'flex');
            
            if (data.gameState === 'playing' && isCurrentlyInMenu) {
                isOnlineGame = true;
                gameMode = `online-${data.gameType}`;
                
                waitingRoom.style.display = 'none';
                onlineMenu.style.display = 'none';
                onlineGameSelect.style.display = 'none';
                gameModeSelect.style.display = 'none';
                
                initAudio();
                showMessage("Opponent connected! Game starting...");
            }
            
            turnInProgress = data.turnInProgress;

            if (!turnInProgress) {
                chipsMoving = false; 
                
                chips = data.chips.map(remoteChip => ({
                    ...remoteChip,
                    radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
                }));

                if (data.gameType === 'poker') {
                    playerHand = (localPlayerId === 'player1') ? data.player1Hand : data.player2Hand;
                    opponentHand = (localPlayerId === 'player1') ? data.player2Hand : data.player1Hand;
                    originalPlayerHand = (localPlayerId === 'player1') ? data.originalPlayer1Hand : data.originalPlayer2Hand;
                    originalOpponentHand = (localPlayerId === 'player1') ? data.originalPlayer2Hand : data.originalPlayer1Hand;
                } else {
                    colorsAssigned = data.colorsAssigned;
                    playerChipsType = (localPlayerId === 'player1') ? data.player1ChipsType : data.player2ChipsType;
                    opponentChipsType = (localPlayerId === 'player1') ? data.player2ChipsType : data.player1ChipsType;
                }
                updateCardDisplay();
                updateInfoBox();

                currentTurnUid = data.currentTurnUid;
                isMyTurnOnline = (currentTurnUid === localPlayerUid);
                canMoveCueBall = data.canMoveCueBall;
                isBreakShot = data.isBreakShot;
                
                resetPektus();

                if (canMoveCueBall && isMyTurnOnline) {
                    gameState = 'moving';
                    cueBallGuide.style.display = 'block';
                } else {
                    gameState = 'aiming';
                    cueStick.visible = true; 
                    cueBallGuide.style.display = 'none';
                }
                
                if (gameState !== 'gameover' && data.gameState === 'playing') {
                    const message = isMyTurnOnline ? "Your turn" : "Opponent's turn";
                    if (messageBox.textContent !== message || messageBox.style.display === 'none') {
                         showMessage(message, 1500);
                    }
                }
            }
            
            if (data.gameState === 'finished' && gameState !== 'gameover') {
                const winnerName = data.winner === localPlayerUid ? 'You Win!' : 'Opponent Wins!';
                endGame(winnerName);
                return;
            }
        }

        // =========================================================================
        // START THE GAME
        // =========================================================================
        init();
    </script>
</body>
</html>
