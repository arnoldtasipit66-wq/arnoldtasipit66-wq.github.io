<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pinoy Pool</title>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Nunito:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --felt-green: #006A4E;
            --wood-brown: #6B4226;
            --light-wood: #A0522D;
            --gold-accent: #FFD700;
            --dark-bg: rgba(0, 0, 0, 0.7);
            --light-text: #FFFFFF;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #2c3e50;
            background-image: url('https://www.transparenttextures.com/patterns/dark-denim-3.png');
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Nunito', sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #cue-stick-element {
            display: none;
            position: absolute;
            width: 500px;
            height: 150px;
            pointer-events: none;
            z-index: 30;
            transform-origin: 100% 50%;
            filter: drop-shadow(2px 2px 5px rgba(0,0,0,0.5));
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #table-frame {
            padding: 25px;
            background-color: var(--wood-brown);
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
            border-radius: 15px; 
            box-shadow: 
                0 15px 35px rgba(0,0,0,0.7), 
                inset 0 0 15px rgba(0,0,0,0.8),
                inset 3px 3px 6px rgba(255, 255, 255, 0.15),
                inset -3px -3px 6px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            display: flex;
        }

        #game-canvas {
            background-color: var(--felt-green);
            background-image: url('https://www.transparenttextures.com/patterns/felt.png');
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }

        #ghost-hand {
            display: none;
            position: absolute;
            width: 80px;
            height: auto;
            opacity: 0.7;
            z-index: 50;
            pointer-events: none;
            transform: translate(-25px, -15px);
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.4));
        }
        
        #non-interactive-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dark-bg);
            color: var(--gold-accent);
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 1.3em;
            display: none;
            text-align: center;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .info-box {
            position: absolute;
            color: var(--gold-accent);
            background-color: var(--dark-bg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px 7px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        #player-info { top: 0px; left: 120px; }
        #opponent-info { top: 0px; right: 120px; }
        
        .ui-button {
            position: absolute;
            padding: 10px 15px;
            font-size: 1em;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            z-index: 10;
        }

        #exit-button {
            bottom: 0px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 53, 69, 0.7);
            padding: 4px 16px;
            font-size: 0.8em;
            z-index: 100;
            transition: all 0.2s ease-in-out;
            border-radius: 8px;
        }
        #exit-button:hover {
            background-color: rgba(220, 53, 69, 1);
            transform: translateX(-50%) scale(1.05);
        }

        .icon-button {
            background-color: rgba(0, 0, 0, 0.6);
            width: 40px; 
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: all 0.2s ease-in-out;
        }
        .icon-button:hover {
            transform: scale(1.1);
            border-color: var(--gold-accent);
        }
        
        /* UPDATED: Fullscreen button is now fixed on the top right */
        #fullscreen-button {
            position: fixed;
            top: 100px;
            right: 10px;
            z-index: 1000; /* High z-index to always be on top */
        }

        #mute-button {
            top: 65%;
            right: 5px;
            transform: translateY(-50%);
            font-size: 1.2em;
        }
        
        #card-hand-container, #poker-foul-cards {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row; 
            gap: 8px; 
            pointer-events: all;
            z-index: 10;
        }

        #poker-foul-cards {
            top: auto; 
            position: relative;
            transform: none;
            left: auto;
            margin-top: 20px;
            justify-content: center;
        }
        
        .card {
            width: 40px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.9); 
            border: 1px solid rgba(0, 0, 0, 0.2); 
            border-radius: 4px; 
            display: flex;
            flex-direction: column; 
            justify-content: space-between;
            align-items: center;
            padding: 2px;
            font-weight: bold;
            color: #333;
            text-shadow: none;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
         #card-hand-container .card {
             width: 13px;
             height: 23px;
         }
        .card-rank { font-size: 1.0em; }
        .card-suit { font-size: 0.5em; align-self: flex-end; }
        #card-hand-container .card-rank { font-size: 0.6em; }
        #card-hand-container .card-suit { font-size: 0.6em; }

        .card.face-down {
            background-image: linear-gradient(135deg, #4a90e2 25%, #50e3c2 100%);
            cursor: pointer;
        }
        .card.face-down:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 8px 15px rgba(0,0,0,0.3);
        }

        .control-area {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            z-index: 20;
        }
        
        #power-control {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px; 
            height: 220px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            flex-direction: column;
            justify-content: flex-end;
            padding: 4px;
        }
        #power-bar {
            width: 100%;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
            border-radius: 10px;
            height: 0%;
        }

        #pektus-control {
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            width: 35px;
            height: 35px;
            background: var(--gold-accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
            border: 2px solid rgba(0,0,0,0.3);
        }
        
        #pektus-dot {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: transparent;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 1px solid #D32F2F;
            box-sizing: border-box;
        }

        #pektus-dot::before,
        #pektus-dot::after {
            content: '';
            position: absolute;
            background-color: #D32F2F;
        }

        #pektus-dot::before {
            top: 50%;
            left: 2px;
            right: 2px;
            height: 1px;
            transform: translateY(-50%);
        }

        #pektus-dot::after {
            left: 50%;
            top: 2px;
            bottom: 2px;
            width: 1px;
            transform: translateX(-50%);
        }
        
        .arrow-button {
            position: absolute;
            bottom: 0px;
            width: 70px;
            height: 33px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }
        .arrow-button:active {
            transform: scale(0.95);
            background-color: rgba(0,0,0,0.6);
        }
        #left-arrow {
            right: 50%;
            transform: translateX(-120px);
        }
        #right-arrow {
            left: 50%;
            transform: translateX(120px);
        }

        .modal-overlay {
            display: flex; 
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            flex-direction: column;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        #confirm-exit-modal {
            z-index: 300;
        }
        
        .modal-overlay h2 {
            font-family: 'Luckiest Guy', cursive;
            font-size: 3em;
            margin-bottom: 20px;
            color: var(--gold-accent);
            letter-spacing: 2px;
            text-shadow: 3px 3px 8px rgba(0,0,0,0.8);
        }
        .menu-button {
            font-size: 1.3em;
            padding: 15px 25px;
            margin: 10px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(76, 175, 80, 0.5);
            color: white;
            cursor: pointer;
            width: 320px;
            pointer-events: all;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
        }
        .menu-button:hover {
            transform: scale(1.05);
            background-color: rgba(76, 175, 80, 0.8);
            border-color: var(--gold-accent);
        }
        .menu-button:disabled {
            background-color: rgba(108, 117, 125, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .back-button {
            background-color: rgba(108, 117, 125, 0.5);
            margin-top: 20px;
        }
        .back-button:hover {
            background-color: rgba(108, 117, 125, 0.8);
        }
        
        #winner-modal h2 {
            margin-bottom: 0;
        }
        #winner-modal #play-again-button {
            font-size: 1.2em;
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
        }

        .winner-modal-content-wrapper {
            display: flex;
            flex-direction: row-reverse; 
            align-items: flex-start;
            justify-content: center;
            gap: 50px;
            background-color: rgba(30, 30, 30, 0.7);
            padding: 30px 40px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        .winner-text-and-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            text-align: center;
            min-width: 300px;
            padding-top: 20px;
            gap: 25px;
        }
        
        #opponent-hand-reveal {
            margin-top: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #rematch-button {
            display: none; 
            width: 250px; 
            margin: 0;
        }


        #online-menu input {
            font-family: 'Nunito', sans-serif;
            font-size: 1.1em;
            padding: 12px;
            margin: 10px;
            width: 280px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #opponent-hand-reveal .card {
            transform: scale(0.8);
        }

        .instruction-modal .content, #leaderboard-modal .content, #online-hall-modal .content {
            background-color: rgba(40, 40, 90, 0.85);
            padding: 20px 30px;
            border-radius: 15px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .instruction-modal .play-button-container {
            margin-bottom: 20px;
        }
        .instruction-modal p {
            font-style: italic;
            line-height: 1.6;
            font-size: 1.1em;
            text-align: left;
        }
        
        .guide-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 0, 0.8);
            color: black;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            display: none; 
            text-align: center;
        }
        
        #waiting-room p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        #waiting-room #game-id-display {
            background-color: rgba(0,0,0,0.4);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 2.5em;
            font-weight: bold;
            letter-spacing: 5px;
            border: 1px solid rgba(255,255,255,0.3);
            margin-bottom: 20px;
            cursor: pointer;
        }

        #confirm-exit-modal .button-group {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #confirm-exit-modal .confirm-button {
            width: 140px;
            pointer-events: all;
        }
        #confirm-exit-yes {
            background-color: rgba(220, 53, 69, 0.7);
        }
        #confirm-exit-cancel {
            background-color: rgba(108, 117, 125, 0.7);
        }

        #leaderboard-modal .content {
            width: 80%; 
            max-width: 500px;
        }
        #leaderboard-modal table {
            width: 100%; 
            text-align: left; 
            border-collapse: collapse;
        }
        #leaderboard-modal th, #leaderboard-modal td {
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
        }
        #chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 300px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: none; 
            flex-direction: column;
            z-index: 150;
            pointer-events: all;
            font-size: 0.9em;
            backdrop-filter: blur(5px);
        }
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 8px;
            display: flex;
            flex-direction: column-reverse;
        }
        #chat-messages p { margin: 2px 0; padding: 4px 8px; border-radius: 5px; color: white; word-wrap: break-word; }
        #chat-messages .my-message { background-color: #007bff; align-self: flex-end; text-align: right; }
        #chat-messages .opponent-message { background-color: #454d55; align-self: flex-start; text-align: left; }
        #chat-input-area { display: flex; padding: 5px; border-top: 1px solid rgba(255, 255, 255, 0.2); }
        #chat-input { flex-grow: 1; background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: white; padding: 5px; border-radius: 4px; }
        #chat-send-btn { margin-left: 5px; background-color: #28a745; border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; }
        
        #voice-toggle-button { position: absolute; top: 5px; left: 5px; z-index: 150; }

        .loader { width: 48px; height: 48px; border: 5px solid #FFF; border-bottom-color: var(--gold-accent); border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite; margin-bottom: 20px; }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #chat-toggle-button { top: 75% !important; left: 5px !important; }
        
        #credits-container {
            position: absolute;
            bottom: 0px;
            left: 0px;
            font-size: 0.5em;
            color: rgba(255, 255, 255, 0.6);
            text-align: left;
            z-index: 100;
            pointer-events: none;
        }
        
        /* START: Tutorial Styles */
        #tutorial-overlay {
            z-index: 500;
            background-color: transparent;
            backdrop-filter: none;
            pointer-events: none; 
        }

        #tutorial-highlight {
            position: absolute;
            border: 3px dashed var(--gold-accent);
            border-radius: 10px;
            box-shadow: none; 
            pointer-events: none;
            transition: all 0.4s ease-in-out;
            z-index: 501;
            box-sizing: border-box;
        }

        #tutorial-box {
            position: absolute;
            background-color: var(--dark-bg);
            color: var(--light-text);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--gold-accent);
            max-width: 350px;
            text-align: center;
            font-size: 1.1em;
            pointer-events: all;
            z-index: 502;
            line-height: 1.5;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            transition: all 0.4s ease-in-out;
        }

        #tutorial-box p {
            margin: 0 0 15px 0;
        }

        #tutorial-next-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: transform 0.2s;
        }

        #tutorial-next-btn:hover {
            transform: scale(1.05);
        }
        /* END: Tutorial Styles */

        /* STATS FEATURE: CSS for Stats Modal */
        #stats-modal .content {
            background-color: rgba(20, 20, 60, 0.9);
            padding: 30px 40px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(255,255,255,0.2);
            max-height: 90vh;
            overflow-y: auto;
        }
        #stats-modal .display-name {
            font-size: 2.5em;
            font-weight: bold;
            color: var(--gold-accent);
            margin-bottom: 20px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        .stat-card {
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .stat-card .label {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 5px;
        }
        .stat-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
        }
        .gamemode-wins h3 {
            font-size: 1.5em;
            color: var(--gold-accent);
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            padding-bottom: 5px;
        }
         .gamemode-wins p {
             font-size: 1.1em;
             margin: 5px 0;
             color: #eee;
         }
        
        /* NEW: Online Hall CSS */
        #online-hall-modal .content {
             width: 80%;
             max-width: 500px;
        }
        #online-players-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            max-height: 50vh;
            overflow-y: auto;
        }
        .player-list-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .no-players-online {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
        }
        .online-indicator {
            width: 12px;
            height: 12px;
            background-color: #28a745;
            border-radius: 50%;
            margin-right: 12px;
            box-shadow: 0 0 8px #28a745;
        }
        .player-name {
            flex-grow: 1;
            text-align: left;
            font-weight: bold;
            font-size: 1.1em;
        }
        .player-actions button {
            background-color: rgba(0, 123, 255, 0.6);
            color: white;
            border: none;
            padding: 6px 12px;
            margin-left: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .player-actions button:hover {
            background-color: rgba(0, 123, 255, 0.9);
        }
        .player-actions button:disabled {
             background-color: rgba(108, 117, 125, 0.4);
             cursor: not-allowed;
        }
        #challenge-received-modal p {
             font-size: 1.2em;
             margin: 15px 0;
        }
        #challenge-received-modal .button-group {
             display: flex;
             gap: 20px;
        }


    </style>
</head>
<body>
    <div id="start-overlay" class="modal-overlay show" style="cursor: pointer;">
        <h2>Pinoy Pool</h2>
        <p style="font-size: 1.5em; margin-top: -10px; color: rgba(255,255,255,0.8);">Click anywhere to start</p>
    </div>

    <!-- MOVED: Fullscreen button is now outside the game wrapper to be always visible -->
    <button id="fullscreen-button" class="ui-button icon-button" title="Toggle Fullscreen">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
    </button>

    <div id="game-wrapper">

        <button id="voice-toggle-button" class="ui-button icon-button" title="Toggle AI Voice">
            <svg id="voice-on-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;"><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-1.414 1.414A6.472 6.472 0 0 1 12.026 8a6.472 6.472 0 0 1-1.904 4.596l1.414 1.414zM10.121 12.596A6.48 6.48 0 0 0 12.026 8a6.48 6.48 0 0 0-1.905-4.596l-1.414 1.414A4.486 4.486 0 0 1 10.026 8a4.486 4.486 0 0 1-1.319 3.182l1.414 1.414zM8.707 11.182A2.482 2.482 0 0 0 9.026 8a2.482 2.482 0 0 0-.32-1.182L8 7.525v1.95l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10H1.5A.5.5 0 0 1 1 9.5v-3A.5.5 0 0 1 1.5 6h2.325l2.363-2.39a.5.5 0 0 1 .529-.06z"/></svg>
            <svg id="voice-off-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white; display: none;"><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-1.414 1.414A6.472 6.472 0 0 1 12.026 8c0 1.554-.54 2.97-.904 4.596l1.414 1.414zM10.121 12.596A6.48 6.48 0 0 0 12.026 8a6.48 6.48 0 0 0-1.905-4.596l-1.414 1.414A4.486 4.486 0 0 1 10.026 8c0 .93-.28 1.78-.752 2.582l1.414 1.414zM8.707 11.182A2.482 2.482 0 0 0 9.026 8a2.482 2.482 0 0 0-.32-1.182L8 7.525v1.95l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10H1.5A.5.5 0 0 1 1 9.5v-3A.5.5 0 0 1 1.5 6h2.325l2.363-2.39a.5.5 0 0 1 .529-.06zm-6.288-.31L1.5 2.5v11l-.288-.288a.5.5 0 0 1 0-.707l12-12a.5.5 0 0 1 .707.707L1.135 14.135a.5.5 0 0 1-.707 0L.139 13.849a.5.5 0 0 1 0-.707l12-12a.5.5 0 0 1 .707.707L.429 3.24z"/></svg>
        </button>

        <img id="cue-stick-element" src="https://i.imgur.com/FYXWKhr.png">

        <div id="table-frame">
            <canvas id="game-canvas"></canvas>
        </div>

        <button id="chat-toggle-button" class="icon-button" style="display: none; position: absolute; transform: translateY(-50%); z-index: 151; background: none; border: none; box-shadow: none; width: 30px; height: 30px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.5a1 1 0 0 0-.8.4l-1.9 2.533a1 1 0 0 1-1.6 0L5.3 12.4a1 1 0 0 0-.8-.4H2a2 2 0 0 1-2-2V2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h2.5a2 2 0 0 1 1.6.8L8 14.333 9.9 11.8a2 2 0 0 1 1.6-.8H14a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H2z"/></svg>
        </button>

        <img id="ghost-hand" src="https://i.imgur.com/ZPG3GhI.png">
        
        <div id="non-interactive-overlay">
            <div id="player-info" class="info-box">You: ?</div>
            <div id="opponent-info" class="info-box">Opponent: ?</div>
            <div id="message-box"></div>
            <div id="cue-ball-guide" class="guide-text"></div>
            <div id="chat-container">
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <input type="text" id="chat-input" placeholder="Type a message...">
                    <button id="chat-send-btn">Send</button>
                </div>
            </div>
            <div id="drag-guide-text" class="guide-text">Place the cue ball</div>
        </div>

        <button id="exit-button" class="ui-button">Exit</button>
        <div id="card-hand-container"></div>
        
        <button id="mute-button" class="ui-button icon-button" title="Toggle Music">🎵</button>
        
        <div id="power-control" class="control-area">
            <div id="power-bar"></div>
        </div>
        <div id="pektus-control" class="control-area">
            <div id="pektus-dot"></div>
        </div>
        <div id="left-arrow" class="arrow-button control-area">&lt;</div>
        <div id="right-arrow" class="arrow-button control-area">&gt;</div>
    </div>

    <!-- Modals -->
    <!-- NEW: Added online-hall-button -->
    <div id="game-mode-select" class="modal-overlay"> <h2>Select Game Mode</h2> <button class="menu-button" id="vs-ai-button">Player vs AI</button> <button class="menu-button" id="online-button">Online Multiplayer</button> <button class="menu-button" id="online-hall-button" style="background-color: rgba(23, 162, 184, 0.5);">Online Hall</button> <button class="menu-button" id="stats-button" style="background-color: rgba(0, 123, 255, 0.5);">Aking Stats</button> <button class="menu-button" id="leaderboard-button" style="background-color: rgba(255, 193, 7, 0.5);">Leaderboard</button> </div>
    <div id="ai-menu" class="modal-overlay"> <h2>Player vs AI</h2> <button class="menu-button" id="ai-straight-ball-button">STRAIGHT BALL</button> <button class="menu-button" id="ai-poker-button">POKER</button> <button class="menu-button" id="ai-61-button">61 BALL</button> <button class="menu-button back-button" id="ai-back-button">Back</button> </div>
    <div id="straight-ball-instructions" class="modal-overlay instruction-modal"> <div class="content"> <div class="play-button-container"> <button class="menu-button" id="play-straight-ball-button">Play</button> </div> <h2>Straight Ball Rules</h2> <p> - Continue your turn by legally pocketing your balls.<br> - The first color legally pocketed on an 'open table' becomes yours.<br> - <strong>Foul:</strong> Pocketing the cue ball returns one of your pocketed balls to the table.<br> - <strong>Foul:</strong> Hitting an opponent's ball first returns any of your balls pocketed on that shot.<br> - First to pocket all their balls wins! </p> </div> </div>
    <div id="poker-instructions" class="modal-overlay instruction-modal"> <div class="content"> <div class="play-button-container"> <button class="menu-button" id="play-poker-button">Play</button> </div> <h2>Poker Pool Rules</h2> <p> - You get 7 cards. Pocket balls matching your cards to win.<br> - A hand of all Kings is an automatic win.<br> - <strong>Cue Ball Foul:</strong> Pocketing the cue ball forces you to draw a penalty card.<br> - <strong>Last Ball Foul:</strong> If you scratch on your last ball, you draw a card. A King wins the game, otherwise, play continues with the new card.<br> - A penalty card matching a pocketed ball is discarded. </p> </div> </div>
    <div id="61-ball-instructions" class="modal-overlay instruction-modal"> <div class="content"> <div class="play-button-container"> <button class="menu-button" id="play-61-ball-button">Play</button> </div> <h2>61 Ball Rules</h2> <p> - The goal is to be the first to score 61 points.<br> - You must always hit the lowest numbered chip on the table first.<br> - Your score is the sum of the numbers on the chips you legally pocket.<br> - <strong>Example:</strong> Hit the 1-chip first, and the 15-chip is pocketed. You get 15 points.<br> - Your turn continues as long as you legally pocket a chip.<br> - <strong>Foul:</strong> Hitting the wrong chip first, or scratching the cue chip, ends your turn. Your opponent gets ball-in-hand. Any chips pocketed on a foul shot will be returned to the table. </p> </div> </div>
    <div id="poker-foul-card-pick-modal" class="modal-overlay"> <h2>Foul! Pick a card.</h2> <div id="poker-foul-cards"></div> </div>
    <div id="online-game-select" class="modal-overlay"> <h2>Online: Select Game Type</h2> <button class="menu-button" id="online-poker-button">POKER POOL</button> <button class="menu-button" id="online-straight-ball-button">STRAIGHT BALL</button> <button class="menu-button" id="online-61-button">61 BALL</button> <button class="menu-button back-button" id="online-select-back-button">Back</button> </div>
    <div id="online-menu" class="modal-overlay"> <h2>Online Multiplayer</h2> <button class="menu-button" id="find-match-button" style="background-color: rgba(23, 162, 184, 0.5);">Find Match</button> <p style="margin: 15px 0; font-size: 0.9em;">- OR -</p> <button class="menu-button" id="create-game-button">Create Game (Private)</button> <input type="text" id="game-id-input" placeholder="Enter Game ID"> <button class="menu-button" id="join-game-button">Join Game</button> <button class="menu-button back-button" id="online-back-button">Back</button> </div>
    <div id="waiting-room" class="modal-overlay"> <h2>Waiting for Opponent...</h2> <p>Share this Game ID with your friend:</p> <div id="game-id-display" title="Click to copy"></div> <button class="menu-button back-button" id="cancel-game-button">Cancel</button> </div>
    <div id="matchmaking-wait-modal" class="modal-overlay"> <h2>Searching for an opponent...</h2> <div class="loader"></div> <button id="cancel-matchmaking-button" class="menu-button back-button" style="width: 250px;">Cancel</button> </div>
    <div id="winner-modal" class="modal-overlay">
        <div class="winner-modal-content-wrapper">
            <div class="winner-text-and-buttons">
                <h2 id="winner-text"></h2>
                <button id="play-again-button">Play Again</button>
                <button id="rematch-button" class="menu-button">Rematch</button>
            </div>
            <div id="opponent-hand-reveal"></div>
        </div>
    </div>
    <div id="confirm-exit-modal" class="modal-overlay"> <h2>Are you sure you want to exit?</h2> <p>This will count as a loss if you are in an online game.</p> <div class="button-group"> <button id="confirm-exit-yes" class="menu-button confirm-button">Yes</button> <button id="confirm-exit-cancel" class="menu-button confirm-button">Cancel</button> </div> </div>
    <div id="leaderboard-modal" class="modal-overlay"> <div class="content"> <h2>Top Players</h2> <table> <thead> <tr> <th>Rank</th> <th>Name</th> <th>Wins</th> </tr> </thead> <tbody id="leaderboard-body"> <tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr> </tbody> </table> <button class="menu-button back-button" id="leaderboard-back-button">Back</button> </div> </div>
    
    <!-- STATS FEATURE: HTML for the Stats Modal -->
    <div id="stats-modal" class="modal-overlay">
        <div class="content">
            <h2>Aking Stats</h2>
            <p id="stats-displayName" class="display-name">Nagloload...</p>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="label">Kabuuang Laro</div>
                    <div id="stats-gamesPlayed" class="value">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">Panalo</div>
                    <div id="stats-wins" class="value">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">Talo</div>
                    <div id="stats-losses" class="value">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">Win Rate</div>
                    <div id="stats-winRate" class="value">0%</div>
                </div>
            </div>
            <div class="gamemode-wins">
                <h3>Panalo sa Bawat Laro</h3>
                <p>Poker Pool: <strong id="stats-pokerWins">0</strong></p>
                <p>Straight Ball: <strong id="stats-straightBallWins">0</strong></p>
                <p>61 Ball: <strong id="stats-61BallWins">0</strong></p>
            </div>
            <button class="menu-button back-button" id="stats-back-button">Balik</button>
        </div>
    </div>
    
    <!-- NEW: Online Hall Modal -->
    <div id="online-hall-modal" class="modal-overlay">
        <div class="content">
            <h2>Online Hall</h2>
            <ul id="online-players-list">
                <!-- Player items will be injected here by JS -->
            </ul>
            <button class="menu-button back-button" id="online-hall-back-button">Back</button>
        </div>
    </div>
    
    <!-- NEW: Challenge Received Modal -->
     <div id="challenge-received-modal" class="modal-overlay">
        <h2>You have a challenge!</h2>
        <p id="challenge-text">Player challenges you to a game.</p>
        <div class="button-group">
            <button id="accept-challenge-btn" class="menu-button" style="background-color: #28a745;">Accept</button>
            <button id="decline-challenge-btn" class="menu-button" style="background-color: #dc3545;">Decline</button>
        </div>
    </div>


    <div id="credits-container">
        <p style="margin: 2px;">Gawa ni: DugZHak</p>
        <p style="margin: 2px; font-size: 0.8em;">Music from GitHub</p>
    </div>

    <!-- START: Tutorial Elements -->
    <div id="tutorial-overlay" class="modal-overlay">
        <div id="tutorial-highlight"></div>
        <div id="tutorial-box">
            <p id="tutorial-text"></p>
            <button id="tutorial-next-btn">Next</button>
        </div>
    </div>
    <!-- END: Tutorial Elements -->

    <audio id="bg-music-reggae-1" src="https://arnoldtasipit66-wq.github.io/my-game-assets/mrbas-music-labs-roots-reggae-285790.mp3" crossorigin="anonymous" loop></audio>
    <audio id="bg-music-reggae-2" src="https://arnoldtasipit66-wq.github.io/my-game-assets/mrbas-music-labs-roots-reggae-285790.mp3" crossorigin="anonymous" loop></audio>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, deleteDoc, serverTimestamp, increment, collection, query, orderBy, limit, getDocs, addDoc, runTransaction, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let db, auth, firebaseInitialized = false, isAuthReady = false;
        const musicPlayer1 = document.getElementById('bg-music-reggae-1'), musicPlayer2 = document.getElementById('bg-music-reggae-2'), muteButton = document.getElementById('mute-button');
        const backgroundPlaylist = [musicPlayer1, musicPlayer2];
        let currentTrackIndex = Math.floor(Math.random() * backgroundPlaylist.length), musicHasStarted = false;
        const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d'), gameWrapper = document.getElementById('game-wrapper'), messageBox = document.getElementById('message-box'), winnerModal = document.getElementById('winner-modal'), winnerText = document.getElementById('winner-text'), playerInfo = document.getElementById('player-info'), opponentInfo = document.getElementById('opponent-info'), powerControl = document.getElementById('power-control'), powerBar = document.getElementById('power-bar'), gameModeSelect = document.getElementById('game-mode-select'), /*difficultySelect = document.getElementById('difficulty-select'),*/ onlineMenu = document.getElementById('online-menu'), exitButton = document.getElementById('exit-button'), vsAiButton = document.getElementById('vs-ai-button'), onlineButton = document.getElementById('online-button'), createGameButton = document.getElementById('create-game-button'), joinGameButton = document.getElementById('join-game-button'), gameIdInput = document.getElementById('game-id-input'), /*difficultyBackButton = document.getElementById('difficulty-back-button'),*/ onlineBackButton = document.getElementById('online-back-button'), cardHandContainer = document.getElementById('card-hand-container'), opponentHandReveal = document.getElementById('opponent-hand-reveal'), playAgainButton = document.getElementById('play-again-button'), aiMenu = document.getElementById('ai-menu'), aiStraightBallButton = document.getElementById('ai-straight-ball-button'), aiPokerButton = document.getElementById('ai-poker-button'), ai61Button = document.getElementById('ai-61-button'), aiBackButton = document.getElementById('ai-back-button'), straightBallInstructions = document.getElementById('straight-ball-instructions'), pokerInstructions = document.getElementById('poker-instructions'), sixtyOneInstructions = document.getElementById('61-ball-instructions'), playStraightBallButton = document.getElementById('play-straight-ball-button'), playPokerButton = document.getElementById('play-poker-button'), play61BallButton = document.getElementById('play-61-ball-button'), cueBallGuide = document.getElementById('cue-ball-guide'), waitingRoom = document.getElementById('waiting-room'), gameIdDisplay = document.getElementById('game-id-display'), cancelGameButton = document.getElementById('cancel-game-button'), onlineGameSelect = document.getElementById('online-game-select'), onlinePokerButton = document.getElementById('online-poker-button'), onlineStraightBallButton = document.getElementById('online-straight-ball-button'), online61Button = document.getElementById('online-61-button'), onlineSelectBackButton = document.getElementById('online-select-back-button'), confirmExitModal = document.getElementById('confirm-exit-modal'), confirmExitYes = document.getElementById('confirm-exit-yes'), confirmExitCancel = document.getElementById('confirm-exit-cancel'), pektusControl = document.getElementById('pektus-control'), pektusDot = document.getElementById('pektus-dot'), leftArrow = document.getElementById('left-arrow'), rightArrow = document.getElementById('right-arrow'), fullscreenButton = document.getElementById('fullscreen-button'), pokerFoulCardPickModal = document.getElementById('poker-foul-card-pick-modal'), pokerFoulCardsContainer = document.getElementById('poker-foul-cards'), leaderboardModal = document.getElementById('leaderboard-modal'), leaderboardButton = document.getElementById('leaderboard-button'), leaderboardBackButton = document.getElementById('leaderboard-back-button'), leaderboardBody = document.getElementById('leaderboard-body'), ghostHand = document.getElementById('ghost-hand'), dragGuideText = document.getElementById('drag-guide-text'), findMatchButton = document.getElementById('find-match-button'), matchmakingWaitModal = document.getElementById('matchmaking-wait-modal'), cancelMatchmakingButton = document.getElementById('cancel-matchmaking-button'), chatContainer = document.getElementById('chat-container'), chatMessages = document.getElementById('chat-messages'), chatInput = document.getElementById('chat-input'), chatSendBtn = document.getElementById('chat-send-btn'), cueStickElement = document.getElementById('cue-stick-element'); 
        
        // NEW: Online Hall element references
        const onlineHallButton = document.getElementById('online-hall-button');
        const onlineHallModal = document.getElementById('online-hall-modal');
        const onlinePlayersList = document.getElementById('online-players-list');
        const onlineHallBackButton = document.getElementById('online-hall-back-button');
        const challengeReceivedModal = document.getElementById('challenge-received-modal');
        const challengeText = document.getElementById('challenge-text');
        const acceptChallengeBtn = document.getElementById('accept-challenge-btn');
        const declineChallengeBtn = document.getElementById('decline-challenge-btn');


        // STATS FEATURE: Element references for the stats modal
        const statsModal = document.getElementById('stats-modal');
        const statsButton = document.getElementById('stats-button');
        const statsBackButton = document.getElementById('stats-back-button');
        const statsDisplayName = document.getElementById('stats-displayName');
        const statsGamesPlayed = document.getElementById('stats-gamesPlayed');
        const statsWins = document.getElementById('stats-wins');
        const statsLosses = document.getElementById('stats-losses');
        const statsWinRate = document.getElementById('stats-winRate');
        const statsPokerWins = document.getElementById('stats-pokerWins');
        const statsStraightBallWins = document.getElementById('stats-straightBallWins');
        const stats61BallWins = document.getElementById('stats-61BallWins');

        // START: Tutorial variables
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialHighlight = document.getElementById('tutorial-highlight');
        const tutorialBox = document.getElementById('tutorial-box');
        const tutorialText = document.getElementById('tutorial-text');
        const tutorialNextBtn = document.getElementById('tutorial-next-btn');
        let isTutorialActive = false;
        let tutorialStep = 0;
        let tutorialSteps = [];
        const interactiveElements = [canvas, powerControl, pektusControl, leftArrow, rightArrow];
        // END: Tutorial variables

        const TABLE_ASPECT_RATIO = 2, BALL_RADIUS = 16, CUE_BALL_RADIUS = 18, HOLE_RADIUS = 35, FRICTION = 0.98, MIN_VELOCITY = 0.05, ROTATION_SPEED = 0.001, TOUCH_AIM_SENSITIVITY = 0.00001;
        const aiChatter = { 'tl': { start: ["Good luck!", "Game na!", "Simulan na natin!"], goodShot: ["Ayos!", "chamba lang!", "Swabe!", "Pasok! 😎"], foul: ["Ay, sablay.😂", "Sayang.🥺", "Oops, mali.🤭"], playerGoodShot: ["Wow, nice shot!😲", "Ang galing naman!", "Ganda ng tira mo!", "Hanep, smooth! 👏"], playerFoul: ["Sayang 'yon.", "Nangyayari talaga 'yan.", "Bawi na lang.", "Ayy, malas."], winning: ["Isa na lang!", "Malapit na...", "Mukhang akin na 'to."], lose: ["Good game! Ang galing mo!", "GG! Rematch?"], win: ["Good game! Salamat sa laro.", "Panalo!"] } };
        let isAiVoiceEnabled = true, scale = 1, table = { width: 0, height: 0 }, chips = [], holes = [], cueStick = { angle: 0, length: 10000, visible: true, power: 0, pullback: 0 }, gameState = 'menu', gameMode = 'ai-classic', playerTurn = true, colorsAssigned = false, playerChipsType = null, opponentChipsType = null, canMoveCueBall = false, chipsMoving = false, chipsPocketedInTurn = [], firstChipHitInTurn = null, isPoweringUp = false, isAimingOnCanvas = false, isDraggingCueBall = false, difficulty = 'pro', deck = [], playerHand = [], opponentHand = [], originalPlayerHand = [], originalOpponentHand = [], selectedGameConfig = {}, isBreakShot = false, pektusOffset = { x: 0, y: 0 }, shotPektusOffset = { x: 0, y: 0 }, isDraggingPektusDot = false, isRotatingLeft = false, isRotatingRight = false, isInvalidPlacement = false, player61Score = 0, opponent61Score = 0, lowestChipNumber = 1, aiConsecutivePots = 0;
        let gameId = null, localPlayerId = null, localPlayerUid = null, currentTurnUid = null, unsubscribeGameListener, isOnlineGame = false, isMyTurnOnline = false, isProcessingTurnEnd = false, lastProcessedTurnId = -1, isSyncing = false, selectedOnlineGameType = 'poker', lastAimUpdateTime = 0;
        const AIM_UPDATE_INTERVAL = 50;
        let lastTurnControllerUid = null, unsubscribeFromQueue, matchmakingTimeoutId = null, isAiTakeoverActive = false;
        let audioInitialized = false, chipCollisionSynth, pocketSynth, uiSynth, cueHitSynth, cushionSynth, lastCollisionSoundTime = -1, lastCushionSoundTime = -1, buttonSoundPlaying = false;
        const cueStickImage = new Image();
        cueStickImage.src = 'https://i.imgur.com/FYXWKhr.png';
        let unsubscribeFromChat, isInitialChatLoad = true;
        
        // NEW: Presence and Challenge variables
        let unsubscribePlayerStatus, unsubscribeChallenges;
        let currentChallenge = null;

        // --- START OF FIX: Add missing Firebase functions and re-order ---

        async function initializeFirebase() { 
            try { 
                onlineButton.textContent = "Connecting..."; 
                onlineButton.disabled = true; 
                onlineHallButton.disabled = true; 
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                await signInPlayer();
                firebaseInitialized = true;
            } catch (error) { 
                console.warn("Firebase failed.", error); 
                firebaseInitialized = false; 
                onlineButton.textContent = "Offline"; 
                onlineButton.disabled = true; 
                onlineHallButton.disabled = true;
            } 
        }

        async function signInPlayer() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Sign-in failed:", error);
                isAuthReady = false;
                onlineButton.textContent = "Auth Failed";
                onlineButton.disabled = true;
                onlineHallButton.disabled = true;
                return; // Stop if auth fails
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    localPlayerUid = user.uid;
                    if (!isAuthReady) { // Prevent running this logic multiple times
                        isAuthReady = true;
                        onlineButton.disabled = false;
                        onlineButton.textContent = "Online Multiplayer";
                        onlineHallButton.disabled = false;
                        setOnlineStatus(true);
                        listenForChallenges();
                    }
                } else {
                    isAuthReady = false;
                    onlineButton.textContent = "Auth Failed";
                    onlineButton.disabled = true;
                    onlineHallButton.disabled = true;
                }
            });
        }
        
        async function setOnlineStatus(isOnline) {
             if (!localPlayerUid) return;
             const statusDocRef = doc(db, `/artifacts/${appId}/public/data/playerStatus`, localPlayerUid);
             const playerDataRef = doc(db, `/artifacts/${appId}/public/data/players`, localPlayerUid);
             try {
                const playerDoc = await getDoc(playerDataRef);
                const displayName = playerDoc.exists() && playerDoc.data().displayName ? playerDoc.data().displayName : (localStorage.getItem('pinoyPoolPlayerName') || 'Anonymous');
                
                if (isOnline) {
                     await setDoc(statusDocRef, {
                         online: true,
                         displayName: displayName,
                         last_seen: serverTimestamp()
                     });
                 } else {
                     await updateDoc(statusDocRef, { online: false });
                 }
             } catch (e) {
                 console.error("Error setting online status:", e);
             }
         }

        // --- END OF FIX ---


        async function init() { 
            resizeCanvas(); 
            setupEventListeners(); 
            await initializeFirebase(); 
            history.replaceState({ modal: 'start' }, 'Start', '#start'); 
            update(); 
        }
        
        function startGame(mode, difficultyLevel = 'pro') {
            const needsTutorial = !localStorage.getItem('pinoyPoolTutorialCompleted');
            // Tutorial triggers on any first AI game, regardless of (now removed) difficulty
            if (needsTutorial && mode.startsWith('ai-')) {
                startTutorial(mode, difficultyLevel);
                return;
            }

            resizeCanvas(); 
            const allModals = [gameModeSelect, aiMenu, /*difficultySelect,*/ straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, pokerFoulCardPickModal, leaderboardModal, statsModal, onlineHallModal]; 
            allModals.forEach(modal => modal.classList.remove('show')); 
            gameMode = mode; 
            isOnlineGame = false; 
            difficulty = difficultyLevel; // Will be 'pro'
            cueBallGuide.style.display = 'none'; 
            dragGuideText.style.display = 'none'; 
            playerTurn = Math.random() < 0.5; 
            canMoveCueBall = false; 
            chipsMoving = false; 
            colorsAssigned = false; 
            playerChipsType = null; 
            opponentChipsType = null; 
            setupChips(); 
            isBreakShot = true; 
            canMoveCueBall = true; 
            gameState = 'moving'; 
            cueStick.visible = true; 
            if (playerTurn) { 
                showMessage("It's your turn to break!", 4000); 
                dragGuideText.style.display = 'block'; 
            } else { 
                showMessage("Opponent will break the balls.", 4000); 
                placeCueChipForAI(); 
            } 
            resetPektus(); 
            if (gameMode.includes('poker')) { 
                createDeck(); 
                dealCards(); 
                updateCardDisplay(); 
            } else if (gameMode.includes('61-ball')) { 
                player61Score = 0; 
                opponent61Score = 0; 
                lowestChipNumber = 1; 
                cardHandContainer.style.display = 'none'; 
            } else {
                cardHandContainer.style.display = 'none'; 
            }
            updateInfoBox(); 
            history.pushState({ modal: 'game' }, 'Game', '#game'); 
            if (gameMode.startsWith('ai')) { 
                setTimeout(() => { aiDisplayMessage(getAiChatMessage('start')); }, 1500); 
            } 
        }
        
        function waitForCardPick() { return new Promise(resolve => { pokerFoulCardPickModal.classList.add('show'); pokerFoulCardsContainer.innerHTML = ''; const cardsToDraw = []; for (let i = 0; i < 5; i++) if (deck.length > 0) cardsToDraw.push(deck.splice(Math.floor(Math.random() * deck.length), 1)[0]); if (cardsToDraw.length === 0) { pokerFoulCardPickModal.classList.remove('show'); resolve(null); return; } cardsToDraw.forEach(card => { const cardDiv = document.createElement('div'); cardDiv.className = 'card face-down'; cardDiv.onclick = () => { playButtonSound(); cardDiv.classList.remove('face-down'); const color = (card.suit === '♥' || card.suit === '♦') ? '#ff5555' : 'white'; cardDiv.innerHTML = `<span class="card-rank" style="color: ${color};">${card.rank}</span><span class="card-suit" style="color: ${color};">${card.suit}</span>`; pokerFoulCardsContainer.querySelectorAll('.card').forEach(c => { c.onclick = null; c.style.cursor = 'default'; }); setTimeout(() => { pokerFoulCardPickModal.classList.remove('show'); cardsToDraw.forEach(c => { if (c !== card) deck.push(c); }); resolve(card); }, 1500); }; pokerFoulCardsContainer.appendChild(cardDiv); }); }); }
        
        async function endGame(winnerTextMessage, finalGameData = null) {
            if (gameState === 'gameover') return;
            gameState = 'gameover';
            
            let finalWinnerText = winnerTextMessage;
            if (gameMode.includes('61-ball')) {
                const mainMessage = winnerTextMessage.split('.')[0]; 
                finalWinnerText = `${mainMessage}`;
                winnerText.innerHTML = `${finalWinnerText}<br><span style="font-size: 0.6em; font-weight: normal; color: #eee;">Final Score: ${player61Score} - ${opponent61Score}</span>`;
            } else {
                winnerText.textContent = finalWinnerText;
            }

            const rematchButton = document.getElementById('rematch-button');
            const playerWon = winnerTextMessage.includes("You Win");
            const gameType = isOnlineGame ? (finalGameData?.gameType || selectedOnlineGameType) : gameMode.split('-')[1];

            if (isOnlineGame) {
                updatePlayerStats(localPlayerUid, playerWon, gameType);
                playAgainButton.style.display = 'none';
                rematchButton.style.display = 'block';
                rematchButton.disabled = false;
                rematchButton.textContent = 'Request Rematch';
            } else {
                updatePlayerStats(localPlayerUid, playerWon, gameType);
                playAgainButton.style.display = 'block';
                rematchButton.style.display = 'none';
            }
            
            if (gameMode.includes('poker')) {
                opponentHandReveal.innerHTML = '<h4>Opponent\'s Hand:</h4>';

                let opponentsOriginalHand, opponentsFinalHand;

                if (isOnlineGame) {
                    const gameData = finalGameData || (await getDoc(doc(db, `/artifacts/${appId}/public/data/games`, gameId))).data();
                    if (gameData) {
                         opponentsOriginalHand = localPlayerId === 'player1' ? gameData.originalPlayer2Hand : gameData.originalPlayer1Hand;
                         opponentsFinalHand = localPlayerId === 'player1' ? gameData.player2Hand : gameData.player1Hand;
                    } else {
                        opponentsOriginalHand = [];
                        opponentsFinalHand = [];
                    }
                } else {
                    opponentsOriginalHand = originalOpponentHand;
                    opponentsFinalHand = opponentHand;
                }

                if(!opponentsOriginalHand || !opponentsFinalHand) return;

                const pocketedCards = opponentsOriginalHand.filter(originalCard => 
                    !opponentsFinalHand.some(finalCard => 
                        finalCard.rank === originalCard.rank && finalCard.suit === originalCard.suit
                    )
                );

                const createCardElement = (card) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    const color = (card.suit === '♥' || card.suit === '♦') ? '#D32F2F' : '#212121';
                    cardDiv.innerHTML = `<span class="card-rank" style="color: ${color};">${card.rank}</span><span class="card-suit" style="color: ${color};">${card.suit}</span>`;
                    return cardDiv;
                };

                if (pocketedCards.length > 0) {
                    const pocketedContainer = document.createElement('div');
                    pocketedContainer.innerHTML = '<p style="margin: 10px 0 5px 0;">Pocketed:</p>';
                    const pocketedCardsDiv = document.createElement('div');
                    pocketedCardsDiv.style.cssText = 'display: flex; gap: 5px; justify-content: center; flex-wrap: wrap;';
                    pocketedCards.forEach(card => pocketedCardsDiv.appendChild(createCardElement(card)));
                    pocketedContainer.appendChild(pocketedCardsDiv);
                    opponentHandReveal.appendChild(pocketedContainer);
                }

                if (opponentsFinalHand.length > 0) {
                    const remainingContainer = document.createElement('div');
                    remainingContainer.innerHTML = '<p style="margin: 10px 0 5px 0;">Remaining:</p>';
                    const remainingCardsDiv = document.createElement('div');
                    remainingCardsDiv.style.cssText = 'display: flex; gap: 5px; justify-content: center; flex-wrap: wrap;';
                    remainingCardsDiv.forEach(card => remainingCardsDiv.appendChild(createCardElement(card)));
                    remainingContainer.appendChild(remainingCardsDiv);
                    opponentHandReveal.appendChild(remainingContainer);
                }

                opponentHandReveal.style.display = 'flex';
            } else if (gameMode.includes('61-ball')) {
                opponentHandReveal.innerHTML = `
                    <div style="text-align: center;">
                        <h4>Final Score</h4>
                        <p style="font-size: 1.4em; margin: 10px 0; color: white;">You: <span style="font-weight: bold; color: var(--gold-accent);">${player61Score}</span></p>
                        <p style="font-size: 1.4em; margin: 10px 0; color: white;">Opponent: <span style="font-weight: bold; color: var(--gold-accent);">${opponent61Score}</span></p>
                    </div>
                `;
                opponentHandReveal.style.display = 'flex';
            } else {
                opponentHandReveal.innerHTML = '';
                opponentHandReveal.style.display = 'none';
            }
            
            winnerModal.classList.add('show');
            history.pushState({ modal: 'winner' }, 'Winner', '#winner');
        }

        async function resetToMenu() { 
            playButtonSound(); 
            document.getElementById('chat-toggle-button').style.display = 'none'; 
            chatContainer.style.display = 'none'; 
            if (unsubscribeFromChat) unsubscribeFromChat(); 
            if (isOnlineGame) await leaveOnlineGame(false); 
            [winnerModal, gameModeSelect, aiMenu, /*difficultySelect,*/ onlineMenu, onlineGameSelect, waitingRoom, straightBallInstructions, pokerInstructions, sixtyOneInstructions, confirmExitModal, leaderboardModal, statsModal, onlineHallModal].forEach(m => m.classList.remove('show')); 
            gameModeSelect.classList.add('show'); 
            if (unsubscribeGameListener) { 
                unsubscribeGameListener(); 
                unsubscribeGameListener = null; 
            } 
            gameState = 'menu'; 
            isOnlineGame = false; 
            gameId = null; 
            localPlayerId = null; 
            isAiTakeoverActive = false; 
            updateCardDisplay(); 
            playerInfo.innerHTML = 'You: ?'; 
            opponentInfo.innerHTML = 'Opponent: ?'; 
            chips = []; 
            draw(); 
            history.pushState({ modal: 'gameModeSelect' }, 'Main Menu', '#main'); 
        }
        window.onpopstate = (event) => { if (gameState !== 'menu' && gameState !== 'gameover' && !Array.from(document.querySelectorAll('.modal-overlay')).some(m => m.classList.contains('show'))) { showExitConfirmation(); history.pushState({ modal: 'game' }, 'Game', '#game'); return; } const state = event.state || { modal: 'gameModeSelect' }; const allModals = { gameModeSelect, aiMenu, /*difficultySelect,*/ straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, pokerFoulCardPickModal, leaderboardModal, statsModal, onlineHallModal }; Object.values(allModals).forEach(modal => modal.classList.remove('show')); if (allModals[state.modal]) { allModals[state.modal].classList.add('show'); } else if (!state.modal || state.modal === 'gameModeSelect') { gameModeSelect.classList.add('show'); } };
        function showExitConfirmation() { playButtonSound(); if (gameState !== 'menu' && gameState !== 'gameover' && !confirmExitModal.classList.contains('show')) { confirmExitModal.classList.add('show'); } }
        
        async function forfeitOnlineGame() {
            if (!isOnlineGame || !gameId) {
                endGame("You Forfeited. Opponent Wins!"); // Fallback for safety
                return;
            }

            const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId);
            try {
                const gameData = (await getDoc(gameDocRef)).data();
                if (gameData && gameData.gameState !== 'finished') {
                    // NEW STATS FEATURE: Update stats on forfeit
                    updatePlayerStats(localPlayerUid, false, gameData.gameType);

                    const opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
                    const winnerUid = gameData.players[opponentId]?.uid;

                    if (winnerUid) {
                        await updateDoc(gameDocRef, {
                            gameState: 'finished',
                            winner: winnerUid,
                            [`players.${localPlayerId}.status`]: 'forfeited' 
                        });
                    }
                }
            } catch (error) {
                console.error("Error forfeiting game:", error);
            } finally {
                endGame("You Forfeited. Opponent Wins!"); 
            }
        }

        function setupEventListeners() { 
            const startOverlay = document.getElementById('start-overlay'); 
            startOverlay.addEventListener('click', async () => { 
                await initAudio(); 
                playBackgroundMusic(); 
                startOverlay.classList.remove('show'); 
                gameModeSelect.classList.add('show'); 
                history.replaceState({ modal: 'gameModeSelect' }, 'Main Menu', '#main'); 
            }, { once: true }); 

            muteButton.addEventListener('click', toggleMusic); 
            chatSendBtn.addEventListener('click', function() { sendMessage(); }); 
            chatInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { sendMessage(); } }); 
            const chatToggleButton = document.getElementById('chat-toggle-button'); 
            chatToggleButton.addEventListener('click', () => { if (chatContainer.style.display === 'flex') { chatContainer.style.display = 'none'; } else { chatContainer.style.display = 'flex'; } }); 
            window.addEventListener('resize', resizeCanvas); 
            window.addEventListener('orientationchange', resizeCanvas); 
            window.addEventListener('beforeunload', () => { 
                setOnlineStatus(false); // NEW: Set offline on unload
                if (isOnlineGame) leaveOnlineGame(true); 
            }); 
            document.querySelectorAll('.menu-button, .ui-button, .icon-button').forEach(button => button.addEventListener('click', playButtonSound)); 
            fullscreenButton.addEventListener('click', toggleFullScreen); 
            vsAiButton.addEventListener('click', () => { gameModeSelect.classList.remove('show'); aiMenu.classList.add('show'); history.pushState({ modal: 'aiMenu' }, 'AI Menu', '#ai'); }); 
            
            // UPDATED: AI buttons now go directly to instructions
            aiStraightBallButton.addEventListener('click', () => { 
                selectedGameConfig.mode = 'ai-straight-ball'; 
                aiMenu.classList.remove('show'); 
                straightBallInstructions.classList.add('show'); 
                history.pushState({ modal: 'straightBallInstructions' }, 'Rules', '#rules'); 
            }); 
            aiPokerButton.addEventListener('click', () => { 
                selectedGameConfig.mode = 'ai-poker'; 
                aiMenu.classList.remove('show'); 
                pokerInstructions.classList.add('show'); 
                history.pushState({ modal: 'pokerInstructions' }, 'Rules', '#rules'); 
            }); 
            ai61Button.addEventListener('click', () => { 
                selectedGameConfig.mode = 'ai-61-ball'; 
                aiMenu.classList.remove('show'); 
                sixtyOneInstructions.classList.add('show'); 
                history.pushState({ modal: 'sixtyOneInstructions' }, 'Rules', '#rules'); 
            }); 
            
            // NEW: Online Hall Listeners
            onlineHallButton.addEventListener('click', showOnlineHall);
            onlineHallBackButton.addEventListener('click', () => history.back());
            acceptChallengeBtn.addEventListener('click', acceptChallenge);
            declineChallengeBtn.addEventListener('click', declineChallenge);

            // STATS FEATURE: Add event listeners for the stats modal
            statsButton.addEventListener('click', showStatsModal);
            statsBackButton.addEventListener('click', () => history.back());
            
            [/*difficultyBackButton,*/ aiBackButton, onlineSelectBackButton, onlineBackButton, cancelGameButton, leaderboardBackButton].forEach(btn => btn && btn.addEventListener('click', () => history.back())); 
            
            // UPDATED: Play buttons now start the game with 'pro' difficulty
            playStraightBallButton.addEventListener('click', () => startGame(selectedGameConfig.mode, 'pro')); 
            playPokerButton.addEventListener('click', () => startGame(selectedGameConfig.mode, 'pro')); 
            play61BallButton.addEventListener('click', () => startGame(selectedGameConfig.mode, 'pro')); 

            exitButton.addEventListener('click', showExitConfirmation); 
            playAgainButton.addEventListener('click', resetToMenu); 
            document.getElementById('rematch-button').addEventListener('click', handleRematchRequest); 
            
            confirmExitYes.addEventListener('click', async () => {
                confirmExitModal.classList.remove('show');
                if (gameState === 'gameover' || gameState === 'menu') {
                    resetToMenu();
                    return;
                }
                if (isOnlineGame) {
                    await forfeitOnlineGame();
                } else {
                    // NEW STATS FEATURE: Update stats on local forfeit
                    updatePlayerStats(localPlayerUid, false, gameMode.split('-')[1]);
                    await endGame("You Forfeited. Opponent Wins!");
                }
            });

            confirmExitCancel.addEventListener('click', () => { playButtonSound(); confirmExitModal.classList.remove('show'); }); 
            onlineButton.addEventListener('click', () => { if (!isAuthReady) { showMessage("Connecting... Please wait.", 2000); return; } if (!firebaseInitialized) { showMessage("An internet connection is required for online mode.", 3000); return; } gameModeSelect.classList.remove('show'); onlineGameSelect.classList.add('show'); history.pushState({ modal: 'onlineGameSelect' }, 'Online', '#online'); }); 
            onlinePokerButton.addEventListener('click', () => { selectedOnlineGameType = 'poker'; onlineGameSelect.classList.remove('show'); onlineMenu.classList.add('show'); history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); }); 
            onlineStraightBallButton.addEventListener('click', () => { selectedOnlineGameType = 'straight-ball'; onlineGameSelect.classList.remove('show'); onlineMenu.classList.add('show'); history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); }); 
            online61Button.addEventListener('click', () => { selectedOnlineGameType = '61-ball'; onlineGameSelect.classList.remove('show'); onlineMenu.classList.add('show'); history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); }); 
            createGameButton.addEventListener('click', () => createOnlineGame(false)); 
            joinGameButton.addEventListener('click', joinOnlineGame); 
            gameIdDisplay.addEventListener('click', () => { navigator.clipboard?.writeText(gameIdDisplay.textContent).then(() => showMessage("Game ID copied!", 1500)); }); 
            findMatchButton.addEventListener('click', findMatch); 
            cancelMatchmakingButton.addEventListener('click', cancelMatchmaking); 
            leaderboardButton.addEventListener('click', showLeaderboard); 
            interactiveElements.forEach(el => { el.addEventListener('mousedown', handlePointerDown); el.addEventListener('touchstart', handlePointerDown, { passive: false }); }); 
            window.addEventListener('mouseup', handlePointerUp); 
            window.addEventListener('touchend', handlePointerUp); 
            window.addEventListener('mousemove', handlePointerMove); 
            window.addEventListener('touchmove', handlePointerMove, { passive: false }); 
            const voiceToggleButton = document.getElementById('voice-toggle-button'); 
            voiceToggleButton.addEventListener('click', toggleAiVoice); 
            const savedVoiceSetting = localStorage.getItem('pinoyPoolAiVoice'); 
            if (savedVoiceSetting !== null) { isAiVoiceEnabled = (savedVoiceSetting === 'true'); } 
            updateVoiceButtonIcon(); 
            tutorialNextBtn.addEventListener('click', nextTutorialStep);
        }
        function setupChatListener(gameIdForChat) { if (unsubscribeFromChat) { unsubscribeFromChat(); } chatMessages.innerHTML = ''; isInitialChatLoad = true; const chatToggleButton = document.getElementById('chat-toggle-button'); if(chatToggleButton) chatToggleButton.style.display = 'flex'; const messagesRef = collection(db, `/artifacts/${appId}/public/data/games`, gameIdForChat, "messages"); const q = query(messagesRef, orderBy("timestamp"), limit(200)); unsubscribeFromChat = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach(change => { if (change.type === 'added' && !isInitialChatLoad) { const messageData = change.doc.data(); if (messageData.senderId !== localPlayerUid && messageData.text) { showMessage(`Opponent: ${messageData.text}`, 5000); } } }); const allMessages = []; snapshot.docs.forEach(doc => allMessages.push(doc.data())); chatMessages.innerHTML = ''; allMessages.reverse().forEach(messageData => { const messageP = document.createElement('p'); messageP.textContent = messageData.text; if (messageData.senderId === localPlayerUid) { messageP.className = 'my-message'; } else { messageP.className = 'opponent-message'; } chatMessages.appendChild(messageP); }); isInitialChatLoad = false; }); }
        async function sendMessage() { const messageText = chatInput.value.trim(); if (messageText === '') { showMessage("ERROR: Hindi pwedeng walang laman ang message!", 3000); return; } if (isOnlineGame) { if (!gameId) { console.error("Cannot send message, no game ID."); return; } const messagesRef = collection(db, `/artifacts/${appId}/public/data/games`, gameId, "messages"); try { await addDoc(messagesRef, { text: messageText, senderId: localPlayerUid, timestamp: serverTimestamp() }); } catch (error) { showMessage("FIREBASE ERROR: Tingnan ang console.", 4000); console.error("Ang Firebase error ay:", error); } } else { const messageP = document.createElement('p'); messageP.textContent = messageText; messageP.className = 'my-message'; chatMessages.insertBefore(messageP, chatMessages.firstChild); } chatInput.value = ''; chatContainer.style.display = 'none'; }
        function initAudio() { if (audioInitialized || typeof Tone === 'undefined') { return Promise.resolve(); } return Tone.start().then(() => { chipCollisionSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 5, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1, attackCurve: "exponential", }, }).toDestination(); chipCollisionSynth.volume.value = -4; cueHitSynth = new Tone.PluckSynth({ attackNoise: 1, dampening: 2000, resonance: 0.5, }).toDestination(); cueHitSynth.volume.value = -1; cushionSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(); cushionSynth.volume.value = -10; pocketSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.1 } }).toDestination(); pocketSynth.volume.value = -5; uiSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.8 }).toDestination(); uiSynth.volume.value = -4; audioInitialized = true; }).catch(e => { console.error("Could not start Tone.js audio context:", e); audioInitialized = false; }); }
        async function playButtonSound() { if (buttonSoundPlaying) return; if (!audioInitialized) await initAudio(); if (!audioInitialized) return; buttonSoundPlaying = true; uiSynth.triggerAttackRelease("C5", "8n"); setTimeout(() => { buttonSoundPlaying = false; }, 50); }
        async function playCollisionSound(speed) { if (!audioInitialized) await initAudio(); if (!audioInitialized) return; const now = Tone.now(); if (now <= lastCollisionSoundTime) return; lastCollisionSoundTime = now + 0.04; const volume = -12 + Math.min(1, speed / 25) * 14; const note = speed > 15 ? 'C3' : (speed > 5 ? 'A2' : 'G2'); chipCollisionSynth.volume.value = volume; chipCollisionSynth.triggerAttackRelease(note, "32n", now); }
        async function playCushionSound(speed) { if (!audioInitialized) await initAudio(); if (!audioInitialized) return; const now = Tone.now(); if (now <= lastCushionSoundTime) return; lastCushionSoundTime = now + 0.03; const volume = -12 + Math.min(1, speed / 15) * 8; const note = speed > 10 ? 'C2' : 'D1'; cushionSynth.volume.value = volume; cushionSynth.triggerAttackRelease(note, '16n', now); }
        async function playCueHitSound(power) { if (!audioInitialized) await initAudio(); if (!audioInitialized) return; const now = Tone.now(); const volume = -6 + (power * 6); const note = 'C4'; cueHitSynth.volume.value = volume; cueHitSynth.triggerAttack(note, now); }
        async function playPocketSound() { if (!audioInitialized) await initAudio(); if (!audioInitialized) return; pocketSynth.triggerAttackRelease("0.2"); }
        function update() { if (isRotatingLeft || isRotatingRight) { if (isRotatingLeft) cueStick.angle -= ROTATION_SPEED; if (isRotatingRight) cueStick.angle += ROTATION_SPEED; if (!isTutorialActive) sendLiveAimData(); } if (chipsMoving) { updateChipPositions(); } draw(); requestAnimationFrame(update); }
        function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawTable(); drawChips(); const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn; if (isMyTurn && gameState === 'aiming' && !isTutorialActive) { drawGuidelines(); } if ((gameState === 'aiming' || gameState === 'shooting_animation' || (isOnlineGame && !isMyTurnOnline)) && cueStick.visible) { drawCueStick(); } }
        function toggleMusic() { const isMuted = backgroundPlaylist[0].muted; backgroundPlaylist.forEach(player => { player.muted = !isMuted; }); muteButton.textContent = isMuted ? "🎵" : "🔇"; }
        function resizeCanvas() { const oldCanvasWidth = canvas.width; const oldCanvasHeight = canvas.height; let chipRatios; if (!isBreakShot && chips.length > 0 && oldCanvasWidth > 0 && oldCanvasHeight > 0) { chipRatios = chips.map(c => ({ x: c.x / oldCanvasWidth, y: c.y / oldCanvasHeight })); } const containerWidth = window.innerWidth; const containerHeight = window.innerHeight; const screenAspectRatio = containerWidth / containerHeight; const tableFrame = document.getElementById('table-frame'); let frameWidth, frameHeight; if (screenAspectRatio > TABLE_ASPECT_RATIO) { frameHeight = containerHeight; frameWidth = frameHeight * TABLE_ASPECT_RATIO; } else { frameWidth = containerWidth; frameHeight = frameWidth / TABLE_ASPECT_RATIO; } tableFrame.style.width = `${frameWidth}px`; tableFrame.style.height = `${frameHeight}px`; const framePadding = 25 * 2; canvas.width = frameWidth - framePadding; canvas.height = frameHeight - framePadding; table.width = canvas.width; table.height = canvas.height; scale = frameWidth / 1000; setupHoles(); if (isBreakShot || !chipRatios) { setupChips(); } else if (chipRatios) { chips.forEach((chip, i) => { const radiusConstant = chip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS; if (chipRatios[i]) { chip.x = chipRatios[i].x * canvas.width; chip.y = chipRatios[i].y * canvas.height; } chip.radius = radiusConstant * scale; }); } }
        function setupHoles() { const hr = HOLE_RADIUS * scale; holes = [ { x: 0, y: 0, radius: hr }, { x: canvas.width, y: 0, radius: hr }, { x: 0, y: canvas.height, radius: hr }, { x: canvas.width, y: canvas.height, radius: hr } ]; }
        function setupChips() { chips = []; const newCueChip = { id: 0, value: 0, x: canvas.width * 0.25, y: canvas.height / 2, vx: 0, vy: 0, radius: CUE_BALL_RADIUS * scale, inPlay: true, color: '#1a1a1a', type: 'cue', isPocketing: false, pocketingProgress: 0, pocketingHole: null, rotation: 0, rotationSpeed: 0 }; chips.push(newCueChip); const objectChipRadius = BALL_RADIUS * scale; if (gameMode.includes('straight-ball') || gameMode.includes('poker')) { const redChipsSource = []; const blueChipsSource = []; for (let i = 1; i <= 12; i++) { if (i <= 6) { redChipsSource.push({ id: i, color: '#C8102E', type: 'red', value: i }); } else { blueChipsSource.push({ id: i, color: '#0033A0', type: 'blue', value: i }); } } const startX = canvas.width * 0.7; const startY = canvas.height / 2; const colSpacing = objectChipRadius * 2.1; const rowSpacing = objectChipRadius * 1.8; const positions = []; const rows = 4; const cols = 3; const totalHeight = (rows - 1) * rowSpacing; const initialY = startY - totalHeight / 2; for (let row = 0; row < rows; row++) { for (let col = 0; col < cols; col++) { positions.push({ x: startX + col * colSpacing, y: initialY + row * rowSpacing }); } } const chipDataOrder = [ ...redChipsSource, ...blueChipsSource ]; for (let i = 0; i < positions.length; i++) { let chipData = chipDataOrder[i]; if (chipData) { const newObjectChip = { id: chipData.id, value: chipData.value, x: positions[i].x, y: positions[i].y, vx: 0, vy: 0, radius: objectChipRadius, inPlay: true, color: chipData.color, type: chipData.type, isPocketing: false, pocketingProgress: 0, pocketingHole: null, rotation: 0, rotationSpeed: 0 }; chips.push(newObjectChip); } } } else if (gameMode.includes('61-ball')) { const chipColors = [ null, '#FFD700', '#0000FF', '#FF0000', '#800080', '#FFA500', '#008000', '#964B00', '#212121', '#FFC107', '#03A9F4', '#F44336', '#9C27B0', '#FF9800', '#4CAF50', '#795548' ]; let chipIds = Array.from({length: 15}, (_, i) => i + 1); const startX = canvas.width * 0.75; const startY = canvas.height / 2; const rowSpacing = objectChipRadius * 1.8; const rackPositions = []; for (let row = 0; row < 5; row++) { for (let col = 0; col <= row; col++) { rackPositions.push({ x: startX + row * rowSpacing, y: startY + (col * objectChipRadius * 2.1) - (row * objectChipRadius * 1.05) }); } } for (let i = 0; i < 15; i++) { const chipId = chipIds[i]; const newObjectChip = { id: chipId, value: chipId, x: rackPositions[i].x, y: rackPositions[i].y, vx: 0, vy: 0, radius: objectChipRadius, inPlay: true, color: chipColors[chipId], type: 'numbered', isPocketing: false, pocketingProgress: 0, pocketingHole: null, rotation: 0, rotationSpeed: 0 }; chips.push(newObjectChip); } } }
        function drawTable() { ctx.fillStyle = '#1a1a1a'; holes.forEach(hole => { ctx.beginPath(); ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2); ctx.fill(); }); if (canvas.width > 0) { const fontSize = 60 * scale; ctx.font = `italic bold ${fontSize}px Georgia`; ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; ctx.textBaseline = 'middle'; const spotX = canvas.width * (gameMode.includes('61-ball') ? 0.75 : 0.7); const spotY = canvas.height / 2; const spotRadius = BALL_RADIUS * scale; ctx.lineWidth = 3.5 * scale; ctx.beginPath(); ctx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2); ctx.stroke(); const textPart1 = "P"; const textPart2 = "ker"; const spacing = 8 * scale; ctx.textAlign = 'right'; ctx.fillText(textPart1, spotX - spotRadius - spacing, spotY); ctx.textAlign = 'left'; ctx.fillText(textPart2, spotX + spotRadius + spacing, spotY); const pMetrics = ctx.measureText(textPart1); const kerMetrics = ctx.measureText(textPart2); const pokerWidth = pMetrics.width + (spacing * 2) + (spotRadius * 2) + kerMetrics.width; const pokerCenterX = (spotX - spotRadius - spacing - pMetrics.width) + (pokerWidth / 2); ctx.font = `italic bold ${fontSize}px Georgia`; ctx.textAlign = 'center'; ctx.fillText("Pinoy Pool", (canvas.width / 2) - (60 * scale), 216 * scale); } }
        function drawChips() { ctx.shadowColor = 'rgba(0, 0, 0, 0.4)'; ctx.shadowBlur = 6 * scale; ctx.shadowOffsetX = 3 * scale; ctx.shadowOffsetY = 4 * scale; chips.forEach(chip => { if (chip.inPlay) { let displayRadius = chip.radius; if (chip.isPocketing) { displayRadius *= (1 - chip.pocketingProgress); } ctx.save(); ctx.translate(chip.x, chip.y); if (chip.id === 0) { ctx.beginPath(); ctx.arc(0, 0, displayRadius, 0, Math.PI * 2); ctx.fillStyle = '#FFD700'; ctx.fill(); ctx.strokeStyle = '#444444'; ctx.lineWidth = 2 * scale; ctx.beginPath(); ctx.arc(0, 0, displayRadius * 0.8, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, displayRadius * 0.5, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, displayRadius * 0.2, 0, Math.PI * 2); ctx.fillStyle = '#000000'; ctx.fill(); } else { ctx.beginPath(); ctx.arc(0, 0, displayRadius, 0, Math.PI * 2); ctx.fillStyle = '#FFD700'; ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)'; ctx.lineWidth = 1 * scale; ctx.fill(); ctx.stroke(); const innerRadius = displayRadius * 0.85; ctx.beginPath(); ctx.arc(0, 0, innerRadius, 0, Math.PI * 2); ctx.fillStyle = chip.color; ctx.fill(); if(chip.id) { ctx.fillStyle = 'white'; ctx.font = `bold ${innerRadius * 1.7}px Arial, sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 2 * scale; ctx.shadowOffsetX = 1 * scale; ctx.shadowOffsetY = 1 * scale; ctx.fillText(chip.id, 0, 2 * scale); } } ctx.restore(); } }); ctx.shadowColor = 'transparent'; }
        function drawCueStick() { if (!cueStick.visible || !chips[0] || !chips[0].inPlay || !cueStickElement) return; const cueChip = chips[0]; const canvasRect = canvas.getBoundingClientRect(); const wrapperRect = gameWrapper.getBoundingClientRect(); const stickWidth = cueStickElement.offsetWidth; const stickHeight = cueStickElement.offsetHeight; const cueBallCenterX = canvasRect.left - wrapperRect.left + cueChip.x; const cueBallCenterY = canvasRect.top - wrapperRect.top + cueChip.y; cueStickElement.style.left = `${cueBallCenterX - stickWidth}px`; cueStickElement.style.top = `${cueBallCenterY - (stickHeight / 2)}px`; const pullbackPixels = -cueStick.pullback; cueStickElement.style.transform = `rotate(${cueStick.angle}rad) translateX(${pullbackPixels - 15}px)`; }
        function drawGuidelines() { if (gameState !== 'aiming' || chipsMoving) return; const cueChip = chips[0]; if (!cueChip || !cueChip.inPlay) return; const angle = cueStick.angle; const shotVector = { x: Math.cos(angle), y: Math.sin(angle) }; let firstHit = null; let minCollisionDist = Infinity; for (const targetChip of chips) { if (targetChip.id === 0 || !targetChip.inPlay) continue; const cueToTarget = { x: targetChip.x - cueChip.x, y: targetChip.y - cueChip.y }; const projDist = cueToTarget.x * shotVector.x + cueToTarget.y * shotVector.y; if (projDist <= 0) continue; const closestPointOnPath = { x: cueChip.x + projDist * shotVector.x, y: cueChip.y + projDist * shotVector.y }; const perpDistSq = (closestPointOnPath.x - targetChip.x)**2 + (closestPointOnPath.y - targetChip.y)**2; const combinedRadiusSq = (cueChip.radius + targetChip.radius)**2; if (perpDistSq >= combinedRadiusSq) continue; const travelDist = projDist - Math.sqrt(combinedRadiusSq - perpDistSq); if (travelDist < minCollisionDist) { minCollisionDist = travelDist; firstHit = { chip: targetChip, travelDist: travelDist }; } } ctx.setLineDash([5 * scale, 5 * scale]); ctx.lineWidth = 2.0 * scale; if (firstHit) { const impactPoint = { x: cueChip.x + firstHit.travelDist * shotVector.x, y: cueChip.y + firstHit.travelDist * shotVector.y }; ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.beginPath(); ctx.moveTo(cueChip.x, cueChip.y); ctx.lineTo(impactPoint.x, impactPoint.y); ctx.stroke(); ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(impactPoint.x, impactPoint.y, cueChip.radius, 0, Math.PI * 2); ctx.fillStyle = '#FFD700'; ctx.fill(); ctx.strokeStyle = '#333333'; ctx.lineWidth = 2 * scale; ctx.setLineDash([]); ctx.stroke(); ctx.globalAlpha = 1.0; const objectChip = firstHit.chip; const collisionNormal = { x: objectChip.x - impactPoint.x, y: objectChip.y - impactPoint.y }; const normMag = Math.sqrt(collisionNormal.x**2 + collisionNormal.y**2); const unitNormal = { x: collisionNormal.x / normMag, y: collisionNormal.y / normMag }; ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)'; ctx.setLineDash([5 * scale, 5 * scale]); ctx.beginPath(); ctx.moveTo(objectChip.x, objectChip.y); ctx.lineTo(objectChip.x + unitNormal.x * 41, objectChip.y + unitNormal.y * 41); ctx.stroke(); const tangentVector = { x: -unitNormal.y, y: unitNormal.x }; if (tangentVector.x * shotVector.x + tangentVector.y * shotVector.y < 0) { tangentVector.x *= -1; tangentVector.y *= -1; } const sideSpinAngle = pektusOffset.x * 1.5; const followFactor = 1 - (pektusOffset.y * 0.8); const deflectedCueVector = { x: tangentVector.x * Math.cos(sideSpinAngle) - tangentVector.y * Math.sin(sideSpinAngle), y: tangentVector.x * Math.sin(sideSpinAngle) + tangentVector.y * Math.cos(sideSpinAngle) }; const finalCueVector = { x: (deflectedCueVector.x * 0.7 + shotVector.x * 0.3) * followFactor, y: (deflectedCueVector.y * 0.7 + shotVector.y * 0.3) * followFactor }; ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; ctx.beginPath(); ctx.moveTo(impactPoint.x, impactPoint.y); ctx.lineTo(impactPoint.x + finalCueVector.x * 2000, impactPoint.y + finalCueVector.y * 2000); ctx.stroke(); let isWrongTarget = false; const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn; if (isMyTurn) { if (gameMode.includes('straight-ball') && colorsAssigned && playerChipsType) { if (firstHit.chip.type !== playerChipsType) { isWrongTarget = true; } } else if (gameMode.includes('61-ball') && lowestChipNumber > 0) { if (firstHit.chip.id !== lowestChipNumber) { isWrongTarget = true; } } } if (isWrongTarget) { ctx.save(); ctx.font = `bold ${firstHit.chip.radius * 2}px Arial`; ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5 * scale; ctx.fillText('🚫', firstHit.chip.x, firstHit.chip.y); ctx.restore(); } } else { ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.beginPath(); ctx.moveTo(cueChip.x, cueChip.y); ctx.lineTo(cueChip.x + shotVector.x * 2000, cueChip.y + shotVector.y * 2000); ctx.stroke(); } ctx.setLineDash([]); }
        function updateChipPositions() { const subSteps = 8; for (let i = 0; i < subSteps; i++) { chips.forEach(chip => { if (chip.inPlay && !chip.isPocketing) { chip.x += chip.vx/subSteps; chip.y += chip.vy/subSteps; }}); for (let j = 0; j < chips.length; j++) { const chip1 = chips[j]; if (!chip1.inPlay || chip1.isPocketing) continue; if (chip1.x + chip1.radius > canvas.width) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = canvas.width - chip1.radius; } if (chip1.x - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = chip1.radius; } if (chip1.y + chip1.radius > canvas.height) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = canvas.height - chip1.radius; } if (chip1.y - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = chip1.radius; } for (let k = j + 1; k < chips.length; k++) { const chip2 = chips[k]; if (chip2.inPlay && !chip2.isPocketing) handleChipCollision(chip1, chip2); } } } let stillMoving = false; chips.forEach(chip => { if (chip.inPlay) { if (chip.isPocketing) { chip.pocketingProgress += 0.05; chip.rotation += chip.rotationSpeed; chip.x += (chip.pocketingHole.x - chip.x) * 0.1; chip.y += (chip.pocketingHole.y - chip.y) * 0.1; if (chip.pocketingProgress >= 1) { chip.inPlay = false; chip.isPocketing = false; } } else { chip.vx *= FRICTION; chip.vy *= FRICTION; if (Math.abs(chip.vx) < MIN_VELOCITY) chip.vx = 0; if (Math.abs(chip.vy) < MIN_VELOCITY) chip.vy = 0; holes.forEach(hole => { if (Math.sqrt((hole.x - chip.x)**2 + (hole.y - chip.y)**2) < hole.radius) { playPocketSound(); chip.isPocketing = true; chip.pocketingHole = hole; chip.rotationSpeed = (Math.random() - 0.5) * 0.2; chip.vx = 0; chip.vy = 0; if (!chipsPocketedInTurn.find(p => p.id === chip.id)) chipsPocketedInTurn.push(chip); } }); } if (chip.vx !== 0 || chip.vy !== 0 || chip.isPocketing) stillMoving = true; } }); chipsMoving = stillMoving; if (!chipsMoving) { if (gameState === 'shooting') { gameState = 'evaluating'; if (isTutorialActive) { setTimeout(nextTutorialStep, 500); } else if (!isOnlineGame || localPlayerUid === lastTurnControllerUid) { setTimeout(handleTurnEnd, 200); } } } }
        function handleChipCollision(chip1, chip2) { const dx = chip2.x - chip1.x, dy = chip2.y - chip1.y; const dist = Math.sqrt(dx*dx + dy*dy); const combinedRadius = chip1.radius + chip2.radius; if (dist < combinedRadius) { const impactSpeed = Math.sqrt((chip1.vx - chip2.vx)**2 + (chip1.vy - chip2.vy)**2); if (impactSpeed > 0.1) playCollisionSound(impactSpeed); if (firstChipHitInTurn === null) { if (chip1.id === 0) firstChipHitInTurn = chip2; else if (chip2.id === 0) firstChipHitInTurn = chip1; } const angle = Math.atan2(dy, dx), sin = Math.sin(angle), cos = Math.cos(angle); let vel1 = { x: chip1.vx * cos + chip1.vy * sin, y: chip1.vy * cos - chip1.vx * sin }; let vel2 = { x: chip2.vx * cos + chip2.vy * sin, y: chip2.vy * cos - chip2.vx * sin }; const vxTotal = vel1.x - vel2.x; vel1.x = ((chip1.radius - chip2.radius) * vel1.x + 2 * chip2.radius * vel2.x) / combinedRadius; vel2.x = vxTotal + vel1.x; const overlap = combinedRadius - dist; chip1.x -= (overlap / 2) * cos; chip1.y -= (overlap / 2) * sin; chip2.x += (overlap / 2) * cos; chip2.y += (overlap / 2) * sin; if (chip1.id === 0 || chip2.id === 0) { const sideSpin = shotPektusOffset.x * 0.5; vel1.y += sideSpin * Math.abs(vxTotal); if (shotPektusOffset.y < 0) { const followEnergy = Math.abs(vel1.x * shotPektusOffset.y * 0.2); vel1.x += followEnergy; vel2.x -= followEnergy; } } chip1.vx = vel1.x * cos - vel1.y * sin; chip1.vy = vel1.y * cos + vel1.x * sin; chip2.vx = vel2.x * cos - vel2.y * sin; chip2.vy = vel2.y * cos + vel2.x * sin; } }
        function showMessage(msg, duration = 2000) { messageBox.textContent = msg; messageBox.style.display = 'block'; setTimeout(() => { if (messageBox.textContent === msg) messageBox.style.display = 'none'; }, duration); }
        function resetChipStateForReturn(chip) { if (!chip) return; chip.inPlay = true; chip.isPocketing = false; chip.pocketingProgress = 0; chip.pocketingHole = null; chip.vx = 0; chip.vy = 0; }
        async function handleTurnEnd() { if (isOnlineGame && lastTurnControllerUid !== localPlayerUid) { return; } if (isProcessingTurnEnd) return; isProcessingTurnEnd = true; if (gameMode.includes('poker')) await handlePokerTurnEnd(); else if (gameMode.includes('straight-ball')) await handleStraightBallTurnEnd(); else if (gameMode.includes('61-ball')) await handle61BallTurnEnd(); isProcessingTurnEnd = false; }
        async function handle61BallTurnEnd() { let foul = false; let switchTurn = true; const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn; const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0); const lowestChipOnTable = lowestChipNumber; const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0); const didHitWrongBallFirst = !isBreakShot && firstChipHitInTurn && firstChipHitInTurn.id !== lowestChipOnTable; const didNotHitAnyBall = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0); if (wasCueBallPocketed || didHitWrongBallFirst || didNotHitAnyBall) { foul = true; } if (foul) { if (isMyTurn && !isOnlineGame) { setTimeout(() => aiDisplayMessage(getAiChatMessage('playerFoul')), 800); } switchTurn = true; canMoveCueBall = true; if (wasCueBallPocketed) { const cueChip = chips.find(c => c.id === 0); if (cueChip) { resetChipStateForReturn(cueChip); cueChip.x = canvas.width * 0.25; cueChip.y = canvas.height / 2; } } if (pocketedObjectChips.length > 0) { pocketedObjectChips.forEach(chip => { const chipToReturn = chips.find(c => c.id === chip.id); if (chipToReturn) { resetChipStateForReturn(chipToReturn); placeChipOnSpot(chipToReturn); } }); } if (isMyTurn) showMessage("Foul! Chips returned.", 2500); } else { if (pocketedObjectChips.length > 0) { const pointsThisTurn = pocketedObjectChips.reduce((sum, chip) => sum + chip.value, 0); if (isMyTurn) player61Score += pointsThisTurn; else opponent61Score += pointsThisTurn; switchTurn = false; if (isMyTurn && !isOnlineGame) { setTimeout(() => aiDisplayMessage(getAiChatMessage('playerGoodShot')), 800); } } else { switchTurn = true; } } const newRemainingChips = chips.filter(c => c.inPlay && c.id !== 0); lowestChipNumber = newRemainingChips.length > 0 ? Math.min(...newRemainingChips.map(c => c.id)) : 0; const winner = checkWinCondition(); if (winner) { const winnerText = (winner === 'player') ? 'You Win!' : (winner === 'opponent' ? 'You Lose!' : "It's a Draw! 60-60"); await endGame(winnerText); return; } isBreakShot = false; if (isOnlineGame) await updateOnlineGameState(switchTurn); else updateLocalGameState(switchTurn); }
        async function handlePokerTurnEnd() { const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn; const currentHand = isMyTurn ? playerHand : opponentHand; const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0); const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0); const didHitNothing = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0); const legallyPocketedOwnChips = pocketedObjectChips.filter(chip => currentHand.some(card => card.value === chip.id)); const illegallyPocketedChips = pocketedObjectChips.filter(chip => !currentHand.some(card => card.value === chip.id)); let switchTurn = true; let foul = wasCueBallPocketed || didHitNothing; if (legallyPocketedOwnChips.length > 0 && illegallyPocketedChips.length === 0 && !foul) { switchTurn = false; if (isMyTurn && !isOnlineGame) { setTimeout(() => aiDisplayMessage(getAiChatMessage('playerGoodShot')), 800); } } if (pocketedObjectChips.length > 0) { const pocketedIds = pocketedObjectChips.map(c => c.id); playerHand = playerHand.filter(card => !pocketedIds.includes(card.value)); opponentHand = opponentHand.filter(card => !pocketedIds.includes(card.value)); } if (foul) { if (isMyTurn && !isOnlineGame) { setTimeout(() => aiDisplayMessage(getAiChatMessage('playerFoul')), 800); } canMoveCueBall = true; if (wasCueBallPocketed) { const cueChip = chips.find(c => c.id === 0); if (cueChip) { resetChipStateForReturn(cueChip); cueChip.x = canvas.width * 0.25; cueChip.y = canvas.height / 2; } if(isMyTurn) showMessage("Foul! You scratched.", 3000); let newCard = isMyTurn ? await waitForCardPick() : (deck.length > 0 ? deck.splice(Math.floor(Math.random() * deck.length), 1)[0] : null); if (newCard) { const cardName = `${newCard.rank}${newCard.suit}`; const correspondingChip = chips.find(c => c.id === newCard.value); if (correspondingChip && !correspondingChip.inPlay) { if (isMyTurn) showMessage(`You picked ${cardName}, but it was pocketed. Card discarded.`, 3000); } else { (isMyTurn ? playerHand : opponentHand).push(newCard); if (isMyTurn) showMessage(`Foul! You picked ${cardName}.`, 3000); } if (playerHand.length === 1 && newCard.rank === 'K' && wasCueBallPocketed && legallyPocketedOwnChips.length > 0) { await endGame('You Win on a Lucky Scratch!'); return; } } } } const winner = checkWinCondition(); if (winner) { if (isOnlineGame) { const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId); const winnerUid = (winner === 'player') ? localPlayerUid : opponentUid; const hands = (localPlayerId === 'player1') ? { player1Hand: playerHand, player2Hand: opponentHand } : { player1Hand: opponentHand, player2Hand: playerHand }; await updateDoc(gameDocRef, { gameState: 'finished', winner: winnerUid, ...hands }); } else { const winnerText = (winner === 'player') ? 'You Win!' : 'You Lose!'; await endGame(winnerText); } return; } isBreakShot = false; if (isOnlineGame) await updateOnlineGameState(switchTurn); else updateLocalGameState(switchTurn); }
        async function handleStraightBallTurnEnd() { let foul = false, switchTurn = true, foulReason = ""; const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn; const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0); const currentPlayerColor = isMyTurn ? playerChipsType : opponentChipsType; const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0); const didHitWrongBallFirst = !isBreakShot && colorsAssigned && firstChipHitInTurn && firstChipHitInTurn.type !== currentPlayerColor; const didNotHitAnyBall = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0); if (wasCueBallPocketed || didHitWrongBallFirst || didNotHitAnyBall) { foul = true; } if (pocketedObjectChips.length > 0) { if (!colorsAssigned && !foul) { const firstPocketed = pocketedObjectChips[0]; if (isMyTurn) { playerChipsType = firstPocketed.type; opponentChipsType = firstPocketed.type === 'red' ? 'blue' : 'red'; } else { opponentChipsType = firstPocketed.type; playerChipsType = firstPocketed.type === 'red' ? 'blue' : 'red'; } colorsAssigned = true; if (isMyTurn) showMessage(`Colors assigned! You are ${playerChipsType}.`, 3000); } const myPocketedCount = pocketedObjectChips.filter(c => c.type === (isMyTurn ? playerChipsType : opponentChipsType)).length; const opponentPocketedCount = pocketedObjectChips.filter(c => c.type === (isMyTurn ? opponentChipsType : playerChipsType)).length; if (!foul && myPocketedCount > 0 && opponentPocketedCount === 0) { switchTurn = false; if (isMyTurn && !isOnlineGame) { setTimeout(() => aiDisplayMessage(getAiChatMessage('playerGoodShot')), 800); } } } if (foul) { if (isMyTurn && !isOnlineGame) { setTimeout(() => aiDisplayMessage(getAiChatMessage('playerFoul')), 800); } switchTurn = true; canMoveCueBall = true; if (wasCueBallPocketed) { foulReason += "Cue ball pocketed! "; const cueChip = chips.find(c => c.id === 0); if (cueChip) { resetChipStateForReturn(cueChip); cueChip.x = canvas.width * 0.25; cueChip.y = canvas.height / 2; } const foulingPlayerColor = isMyTurn ? playerChipsType : opponentChipsType; if (foulingPlayerColor) { const chipToReturn = chips.find(c => c.type === foulingPlayerColor && !c.inPlay && !chipsPocketedInTurn.some(p => p.id === c.id)); if (chipToReturn) { resetChipStateForReturn(chipToReturn); placeChipOnSpot(chipToReturn); foulReason += "One of your balls was returned."; } } } if (didHitWrongBallFirst) { foulReason += "Hit opponent's ball first. "; const myPocketedInFoul = pocketedObjectChips.filter(c => c.type === currentPlayerColor); if (myPocketedInFoul.length > 0) { foulReason += "Your pocketed balls are returned."; myPocketedInFoul.forEach(pc => { const foundChip = chips.find(c => c.id === pc.id); if (foundChip) { resetChipStateForReturn(foundChip); placeChipOnSpot(foundChip); } }); } } if (didNotHitAnyBall) foulReason += "No object ball was hit. "; } if (foulReason && isMyTurn) showMessage("Foul! " + foulReason.trim(), 4000); const winner = checkWinCondition(); if (winner) { await endGame((winner === 'player') ? 'You Win!' : 'You Lose!'); return; } isBreakShot = false; if (isOnlineGame) await updateOnlineGameState(switchTurn); else updateLocalGameState(switchTurn); }
        async function updateOnlineGameState(switchTurn) { try { const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId); const docSnap = await getDoc(gameDocRef); if (!docSnap.exists() || docSnap.data().gameState === 'finished') return; let nextTurnUid = docSnap.data().currentTurnUid; if (switchTurn) { nextTurnUid = (nextTurnUid === docSnap.data().players.player1.uid) ? docSnap.data().players.player2.uid : docSnap.data().players.player1.uid; } const chipsToSend = chips.map(c => ({...c, x: c.x / canvas.width, y: c.y / canvas.height })); const newTurnId = (docSnap.data().turnId || 0) + 1; const updatedData = { chips: chipsToSend, currentTurnUid: nextTurnUid, canMoveCueBall, isBreakShot: false, turnInProgress: false, turnId: newTurnId, liveAimData: null }; if (gameMode.includes('poker')) { const hands = (localPlayerId === 'player1') ? { player1Hand: playerHand, player2Hand: opponentHand } : { player1Hand: opponentHand, player2Hand: playerHand }; Object.assign(updatedData, { deck }, hands); } else if (gameMode.includes('straight-ball')) { const types = (localPlayerId === 'player1') ? { player1ChipsType: playerChipsType, player2ChipsType: opponentChipsType } : { player1ChipsType: opponentChipsType, player2ChipsType: playerChipsType }; Object.assign(updatedData, { colorsAssigned }, types); } else if (gameMode.includes('61-ball')) { const scores = (localPlayerId === 'player1') ? { player1_61Score: player61Score, player2_61Score: opponent61Score } : { player1_61Score: opponent61Score, player2_61Score: player61Score }; Object.assign(updatedData, { lowestChipNumber }, scores); } await updateDoc(gameDocRef, updatedData); } catch (error) { console.error("Error updating game state:", error); showMessage("Connection error.", 3000); } }
        function updateLocalGameState(switchTurn) {
            if (switchTurn) {
                if (!playerTurn && chipsPocketedInTurn.length > 0) { setTimeout(() => { aiDisplayMessage(getAiChatMessage('playerGoodShot')); }, 700); }
                playerTurn = !playerTurn;
                if (playerTurn) { aiConsecutivePots = 0; }
                showMessage(`${playerTurn ? 'Your' : 'Opponent'}'s turn`, 1500);
            } else {
                if (playerTurn) { showMessage("You shoot again!", 1500); } else {
                    aiConsecutivePots++;
                    showMessage("AI shoots again!", 1500);
                    setTimeout(() => { aiDisplayMessage(getAiChatMessage('goodShot')); }, 700);
                }
            }
            chipsPocketedInTurn = [];
            firstChipHitInTurn = null;
            resetPektus();
            updateCardDisplay();
            updateInfoBox();
            if (gameState !== 'gameover') {
                if (canMoveCueBall) {
                    gameState = 'moving';
                    if (gameMode.includes('ai') && !playerTurn) {
                        placeCueChipForAI();
                    } else if (playerTurn) {
                        dragGuideText.style.display = 'block';
                    }
                } else {
                    gameState = 'aiming';
                    dragGuideText.style.display = 'none';
                    cueStick.visible = true;
                    if (cueStickElement) cueStickElement.style.display = 'block';
                    if (gameMode.includes('ai') && !playerTurn) {
                        setTimeout(aiTurn, 1000);
                    }
                }
            }
        }
        function checkWinCondition() { if (gameState === 'gameover') return null; let winner = null; if (gameMode.includes('poker')) { if (playerHand.length === 0 || (playerHand.length > 0 && playerHand.every(card => card.rank === 'K'))) winner = 'player'; else if (opponentHand.length === 0 || (opponentHand.length > 0 && opponentHand.every(card => card.rank === 'K'))) winner = 'opponent'; } else if (gameMode.includes('straight-ball') && colorsAssigned) { if (!chips.some(c => c.inPlay && c.type === playerChipsType) && playerChipsType) winner = 'player'; else if (!chips.some(c => c.inPlay && c.type === opponentChipsType) && opponentChipsType) winner = 'opponent'; } else if (gameMode.includes('61-ball')) { if (player61Score >= 61) winner = 'player'; else if (opponent61Score >= 61) winner = 'opponent'; else if (!chips.some(c => c.inPlay && c.id !== 0) && player61Score === 60 && opponent61Score === 60) winner = 'draw'; } return winner; }
        async function shoot(shotPower) { if (gameState !== 'aiming' || chipsMoving) return; playCueHitSound((shotPower - 5) / 30); chipsPocketedInTurn = []; firstChipHitInTurn = null; shotPektusOffset = { ...pektusOffset }; const shotData = { uid: localPlayerUid, angle: cueStick.angle, power: shotPower, pektus: shotPektusOffset, timestamp: Date.now() }; cueStick.power = 0; powerBar.style.height = '0%'; gameState = 'shooting_animation'; let startTime = null; const animationDuration = 100; const startPullback = cueStick.pullback; const endPullback = -30 * scale; function animateLocalShot(timestamp) { if (!startTime) startTime = timestamp; const progress = Math.min((timestamp - startTime) / animationDuration, 1); cueStick.pullback = startPullback + (endPullback - startPullback) * progress; if (progress < 1) { requestAnimationFrame(animateLocalShot); } else { cueStick.pullback = 0; cueStick.visible = false; cueStickElement.style.display = 'none'; if (isOnlineGame) { try { lastTurnControllerUid = localPlayerUid; updateDoc(doc(db, `/artifacts/${appId}/public/data/games`, gameId), { lastShot: shotData, turnInProgress: true, lastTurnController: localPlayerUid }); } catch (error) { console.error("Error sending shot data:", error); gameState = 'aiming'; cueStick.visible = true; } } else { applyShot(shotData); } } } requestAnimationFrame(animateLocalShot); }
        function applyShot(shotData) { if (chipsMoving) return; const cueChip = chips[0]; if (!cueChip || !cueChip.inPlay) return; shotPektusOffset = shotData.pektus || { x: 0, y: 0 }; cueChip.vx = Math.cos(shotData.angle) * shotData.power * scale; cueChip.vy = Math.sin(shotData.angle) * shotData.power * scale; chipsMoving = true; gameState = 'shooting'; if (isOnlineGame) { lastTurnControllerUid = shotData.uid; } }
        async function handleRematchRequest() { if (!isOnlineGame || !gameId) return; const rematchButton = document.getElementById('rematch-button'); rematchButton.disabled = true; rematchButton.textContent = 'Waiting for Opponent...'; const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId); try { await updateDoc(gameDocRef, { [`rematchRequest.${localPlayerUid}`]: true }); } catch (error) { console.error("Error sending rematch request:", error); rematchButton.textContent = 'Error! Try Again'; rematchButton.disabled = false; } }
        
        // STATS FEATURE: Updated this function to track more stats
        async function updatePlayerStats(uid, didWin = false, gameModeType = 'unknown') {
            if (!uid) return;
            const playerDocRef = doc(db, `/artifacts/${appId}/public/data/players`, uid);
            try {
                const playerDoc = await getDoc(playerDocRef);
                const statsUpdate = {
                    wins: increment(didWin ? 1 : 0),
                    losses: increment(didWin ? 0 : 1),
                    lastPlayed: serverTimestamp()
                };

                if (didWin) {
                    if (gameModeType.includes('poker')) {
                        statsUpdate.pokerWins = increment(1);
                    } else if (gameModeType.includes('straight-ball')) {
                        statsUpdate.straightBallWins = increment(1);
                    } else if (gameModeType.includes('61-ball')) {
                        statsUpdate.sixtyOneWins = increment(1);
                    }
                }

                if (!playerDoc.exists() || !playerDoc.data().displayName) {
                    let displayName = localStorage.getItem('pinoyPoolPlayerName');
                    if (!displayName) {
                        displayName = prompt("Congratulations! Enter your name for the leaderboard:", "Player" + Math.floor(Math.random() * 1000));
                        if (!displayName || displayName.trim() === "") displayName = "Anonymous";
                        localStorage.setItem('pinoyPoolPlayerName', displayName);
                    }
                    statsUpdate.displayName = displayName;
                    // Initialize other stats if document is new
                    statsUpdate.pokerWins = increment(statsUpdate.pokerWins ? 1 : 0);
                    statsUpdate.straightBallWins = increment(statsUpdate.straightBallWins ? 1 : 0);
                    statsUpdate.sixtyOneWins = increment(statsUpdate.sixtyOneWins ? 1 : 0);

                    await setDoc(playerDocRef, statsUpdate, { merge: true });
                } else {
                    await updateDoc(playerDocRef, statsUpdate);
                }
            } catch (error) {
                console.error("Error updating player stats:", error);
            }
        }

        async function cleanupMatchmakingEntry() { if (unsubscribeFromQueue) { unsubscribeFromQueue(); unsubscribeFromQueue = null; } const queueCollection = collection(db, `/artifacts/${appId}/public/data/matchmakingQueue`); const q = query(queueCollection, where("uid", "==", localPlayerUid)); const snapshot = await getDocs(q); if (!snapshot.empty) { const myDocRef = snapshot.docs[0].ref; await deleteDoc(myDocRef); } }
        async function cancelMatchmaking() { if (matchmakingTimeoutId) { clearTimeout(matchmakingTimeoutId); matchmakingTimeoutId = null; } await cleanupMatchmakingEntry(); matchmakingWaitModal.classList.remove('show'); onlineMenu.classList.add('show'); history.back(); showMessage("Matchmaking cancelled."); }
        async function findMatch() { if (!isAuthReady || !localPlayerUid) { showMessage("Connecting... Please wait."); return; } onlineMenu.classList.remove('show'); matchmakingWaitModal.classList.add('show'); history.pushState({ modal: 'matchmaking' }, 'Matchmaking', '#matchmaking'); matchmakingTimeoutId = setTimeout(async () => { if (gameId) { clearTimeout(matchmakingTimeoutId); return; } console.log("Matchmaking timed out. Falling back to AI."); await cleanupMatchmakingEntry(); matchmakingWaitModal.classList.remove('show'); showMessage("No opponents found. Starting game vs AI...", 2500); setTimeout(() => { const fallbackGameMode = `ai-${selectedOnlineGameType}`; startGame(fallbackGameMode, 'pro'); }, 1000); }, 15000); const queueCollection = collection(db, `/artifacts/${appId}/public/data/matchmakingQueue`); const myQueueDocRef = await addDoc(queueCollection, { uid: localPlayerUid, gameType: selectedOnlineGameType, status: 'waiting', timestamp: serverTimestamp() }); unsubscribeFromQueue = onSnapshot(myQueueDocRef, (doc) => { const data = doc.data(); if (data && data.status === 'matched' && data.gameId) { clearTimeout(matchmakingTimeoutId); if (unsubscribeFromQueue) unsubscribeFromQueue(); matchmakingWaitModal.classList.remove('show'); showMessage("Opponent found! Joining game..."); gameId = data.gameId; localPlayerId = 'player2'; listenToGameUpdates(gameId); } }); const q = query( queueCollection, where("status", "==", "waiting"), where("gameType", "==", selectedOnlineGameType), where("uid", "!=", localPlayerUid), limit(1) ); const availableOpponents = await getDocs(q); if (!availableOpponents.empty) { clearTimeout(matchmakingTimeoutId); const opponentDoc = availableOpponents.docs[0]; const opponentDocRef = opponentDoc.ref; const opponentUid = opponentDoc.data().uid; try { await runTransaction(db, async (transaction) => { const freshOpponentDoc = await transaction.get(opponentDocRef); if (!freshOpponentDoc.exists() || freshOpponentDoc.data().status !== 'waiting') { throw "Opponent is no longer available."; } gameId = Math.random().toString(36).substring(2, 7).toUpperCase(); localPlayerId = 'player1'; gameMode = `online-${selectedOnlineGameType}`; resizeCanvas(); setupChips(); const initialChipsToSend = chips.map(c => ({...c, x: c.x/canvas.width, y: c.y/canvas.height })); const startingPlayerUid = Math.random() < 0.5 ? localPlayerUid : opponentUid; let gameData = { gameId, gameType: selectedOnlineGameType, gameState: 'playing', turnId: 1, players: { player1: { uid: localPlayerUid, status: 'online' }, player2: { uid: opponentUid, status: 'online' } }, chips: initialChipsToSend, currentTurnUid: startingPlayerUid, lastShot: null, liveAimData: null, turnInProgress: false, canMoveCueBall: true, isBreakShot: true, winner: null }; if (selectedOnlineGameType === 'poker') { createDeck(); dealCards(); Object.assign(gameData, { deck, player1Hand: playerHand, player2Hand: opponentHand, originalPlayer1Hand: originalPlayerHand, originalPlayer2Hand: originalOpponentHand }); } else if (selectedOnlineGameType === 'straight-ball') { Object.assign(gameData, { colorsAssigned: false, player1ChipsType: null, player2ChipsType: null }); } else if (selectedOnlineGameType === '61-ball') { Object.assign(gameData, { player1_61Score: 0, player2_61Score: 0, lowestChipNumber: 1 }); } const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId); transaction.set(gameDocRef, gameData); transaction.update(opponentDocRef, { status: 'matched', gameId: gameId }); transaction.update(myQueueDocRef, { status: 'matched', gameId: gameId }); }); if (unsubscribeFromQueue) unsubscribeFromQueue(); matchmakingWaitModal.classList.remove('show'); showMessage("Opponent found! Starting game..."); listenToGameUpdates(gameId); } catch (e) { console.error("Matchmaking failed: ", e); showMessage("Matchmaking failed. Trying again..."); if (matchmakingTimeoutId) clearTimeout(matchmakingTimeoutId); await cancelMatchmaking(); } } }
        function animateAndApplyShot(shotData) { cueStick.angle = shotData.angle; cueStick.visible = true; if (cueStickElement) cueStickElement.style.display = 'block'; gameState = 'shooting_animation'; let startTime = null; const animationDuration = 100; const shotPowerNormalized = (shotData.power - 5) / 40; const startPullback = shotPowerNormalized * (150 * scale); const endPullback = -30 * scale; function animate(timestamp) { if (!startTime) startTime = timestamp; const progress = Math.min((timestamp - startTime) / animationDuration, 1); cueStick.pullback = startPullback + (endPullback - startPullback) * progress; if (progress < 1) { requestAnimationFrame(animate); } else { cueStick.visible = false; cueStick.pullback = 0; if (cueStickElement) cueStickElement.style.display = 'none'; applyShot(shotData); } } requestAnimationFrame(animate); }
        function syncGameState(data) {
            if (isSyncing || !data) return;
            isSyncing = true;
            let opponentId = null;
            let opponentStatus = null;
            if (localPlayerId && data.players) {
                opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
                if (data.players[opponentId]) {
                    opponentStatus = data.players[opponentId].status;
                }
            }
            if (data.gameState === 'playing' && gameState !== 'playing') {
                gameState = 'playing';
                isOnlineGame = true;
                gameMode = `online-${data.gameType}`;
                lastProcessedTurnId = -1;
                winnerModal.classList.remove('show');
                waitingRoom.classList.remove('show');
                onlineMenu.classList.remove('show');
                gameModeSelect.classList.remove('show');
                history.pushState({
                    modal: 'game'
                }, 'Game', '#game');
                if (canvas.width === 0) resizeCanvas();
                if (data.chips) {
                    chips = data.chips.map(remoteChip => ({ ...remoteChip,
                        x: remoteChip.x * canvas.width,
                        y: remoteChip.y * canvas.height,
                        radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
                    }));
                }
                if (data.gameType === 'poker') {
                    deck = data.deck || [];
                    playerHand = (localPlayerId === 'player1') ? data.player1Hand : data.player2Hand;
                    opponentHand = (localPlayerId === 'player1') ? data.player2Hand : data.player1Hand;
                    originalPlayerHand = (localPlayerId === 'player1') ? data.originalPlayer1Hand : data.originalPlayer2Hand;
                    originalOpponentHand = (localPlayerId === 'player1') ? data.originalPlayer2Hand : data.originalPlayer1Hand;
                } else if (data.gameType === '61-ball') {
                    player61Score = (localPlayerId === 'player1') ? data.player1_61Score : data.player2_61Score;
                    opponent61Score = (localPlayerId === 'player1') ? data.player2_61Score : data.player1_61Score;
                    lowestChipNumber = data.lowestChipNumber;
                } else if (data.gameType === 'straight-ball') {
                    colorsAssigned = data.colorsAssigned;
                    playerChipsType = (localPlayerId === 'player1') ? data.player1ChipsType : data.player2ChipsType;
                    opponentChipsType = (localPlayerId === 'player1') ? data.player2ChipsType : data.player1ChipsType;
                }
            }
            if (data.gameState === 'finished' && gameState !== 'gameover') {
                const playerWon = data.winner === localPlayerUid;
                updatePlayerStats(localPlayerUid, playerWon, data.gameType);
                endGame(playerWon ? 'You Win!' : 'You Lose!', data);
                isSyncing = false;
                return;
            }
            if (gameState === 'playing') {
                if (opponentStatus === 'disconnected' && !isAiTakeoverActive) {
                    isAiTakeoverActive = true;
                    showMessage("Opponent disconnected. AI will take over.", 4000);
                } else if (opponentStatus === 'online' && isAiTakeoverActive) {
                    isAiTakeoverActive = false;
                    showMessage("Opponent has reconnected!", 4000);
                }
                isMyTurnOnline = (data.currentTurnUid === localPlayerUid);
                if (!isMyTurnOnline && data.liveAimData && data.liveAimData.sender !== localPlayerUid) {
                    cueStick.visible = true;
                    if (cueStickElement) cueStickElement.style.display = 'block';
                    const liveAim = data.liveAimData;
                    const cueChip = chips.find(c => c.id === 0);
                    if (data.canMoveCueBall && cueChip) {
                        cueChip.x = liveAim.cueBallX * canvas.width;
                        cueChip.y = liveAim.cueBallY * canvas.height;
                    }
                    cueStick.angle = liveAim.angle;
                    cueStick.pullback = liveAim.pullback || 0;
                    pektusOffset.x = liveAim.pektusX || 0;
                    pektusOffset.y = liveAim.pektusY || 0;
                    updatePektusUI();
                }
                if (data.turnId > lastProcessedTurnId) {
                    lastProcessedTurnId = data.turnId;
                    chipsMoving = false;
                    if (data.chips && canvas.width > 0) {
                        chips = data.chips.map(remoteChip => ({ ...remoteChip,
                            x: remoteChip.x * canvas.width,
                            y: remoteChip.y * canvas.height,
                            radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
                        }));
                    }
                    if (data.gameType === 'poker') {
                        playerHand = (localPlayerId === 'player1') ? data.player1Hand : data.player2Hand;
                        opponentHand = (localPlayerId === 'player1') ? data.player2Hand : data.player1Hand;
                        originalPlayerHand = (localPlayerId === 'player1') ? data.originalPlayer1Hand : data.originalPlayer2Hand;
                        originalOpponentHand = (localPlayerId === 'player1') ? data.originalPlayer2Hand : data.originalPlayer1Hand;
                    } else if (data.gameType === '61-ball') {
                        player61Score = (localPlayerId === 'player1') ? data.player1_61Score : data.player2_61Score;
                        opponent61Score = (localPlayerId === 'player1') ? data.player2_61Score : data.player1_61Score;
                        lowestChipNumber = data.lowestChipNumber;
                    } else if (data.gameType === 'straight-ball') {
                        colorsAssigned = data.colorsAssigned;
                        playerChipsType = (localPlayerId === 'player1') ? data.player1ChipsType : data.player2ChipsType;
                        opponentChipsType = (localPlayerId === 'player1') ? data.player2ChipsType : data.player1ChipsType;
                    }
                    canMoveCueBall = data.canMoveCueBall;
                    isBreakShot = data.isBreakShot;
                    updateCardDisplay();
                    updateInfoBox();
                    const message = data.isBreakShot ? (isMyTurnOnline ? "You break!" : "Opponent's break!") : (isMyTurnOnline ? "Your turn" : "Opponent's turn");
                    if (isMyTurnOnline && canMoveCueBall) {
                        showMessage(message, 3000);
                        dragGuideText.style.display = 'block';
                    } else if (!canMoveCueBall) {
                        showMessage(message, 2000);
                    }
                }
                if (isMyTurnOnline) {
                    gameState = canMoveCueBall ? 'moving' : 'aiming';
                    if (gameState === 'aiming') {
                        dragGuideText.style.display = 'none';
                        cueStick.visible = true;
                        if (cueStickElement) cueStickElement.style.display = 'block';
                    }
                } else {
                    gameState = 'aiming';
                    dragGuideText.style.display = 'none';
                }
                if (isAiTakeoverActive && !isMyTurnOnline && !chipsMoving && !data.turnInProgress) {
                    showMessage("AI is playing for your opponent...", 2000);
                    setTimeout(() => {
                        if (isAiTakeoverActive && !isMyTurnOnline && !chipsMoving) aiTurn();
                    }, 1500);
                }
            }
            isSyncing = false;
        }
        function getAiChatMessage(event, lang = 'tl') { const messages = aiChatter[lang]?.[event]; if (!messages || messages.length === 0) { return ""; } return messages[Math.floor(Math.random() * messages.length)]; }
        function aiDisplayMessage(message) { if (message === "") return; const aiMessageBox = document.createElement('div'); aiMessageBox.style.position = 'absolute'; aiMessageBox.style.bottom = '80px'; aiMessageBox.style.right = '20px'; aiMessageBox.style.backgroundColor = 'rgba(0, 0, 0, 0.8)'; aiMessageBox.style.color = '#00FF00'; aiMessageBox.style.padding = '8px 15px'; aiMessageBox.style.borderRadius = '15px'; aiMessageBox.style.border = '1px solid rgba(0, 255, 0, 0.5)'; aiMessageBox.style.fontSize = '0.9em'; aiMessageBox.style.maxWidth = '200px'; aiMessageBox.style.textAlign = 'center'; aiMessageBox.style.zIndex = '250'; aiMessageBox.style.fontFamily = 'monospace'; aiMessageBox.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.3)'; aiMessageBox.textContent = `AI: "${message}"`; document.getElementById('game-wrapper').appendChild(aiMessageBox); setTimeout(() => { if (aiMessageBox) { aiMessageBox.remove(); } }, 4000); if (isAiVoiceEnabled) { if ('speechSynthesis' in window) { try { const utterance = new SpeechSynthesisUtterance(message); setTimeout(() => { window.speechSynthesis.cancel(); const voices = window.speechSynthesis.getVoices(); const filipinoVoice = voices.find(voice => voice.lang === 'fil-PH'); if (filipinoVoice) { utterance.voice = filipinoVoice; } utterance.pitch = 0.8; utterance.rate = 1.1; window.speechSynthesis.speak(utterance); }, 100); } catch (error) { console.error("AI Voice Error:", error); } } } }
        function toggleAiVoice() { isAiVoiceEnabled = !isAiVoiceEnabled; localStorage.setItem('pinoyPoolAiVoice', isAiVoiceEnabled); if (!isAiVoiceEnabled) { window.speechSynthesis.cancel(); } updateVoiceButtonIcon(); }
        function updateVoiceButtonIcon() { const voiceOnIcon = document.getElementById('voice-on-icon'); const voiceOffIcon = document.getElementById('voice-off-icon'); if (isAiVoiceEnabled) { voiceOnIcon.style.display = 'block'; voiceOffIcon.style.display = 'none'; } else { voiceOnIcon.style.display = 'none'; voiceOffIcon.style.display = 'block'; } }
        function playBackgroundMusic() { if (musicHasStarted) return; const playNextTrack = () => { currentTrackIndex = (currentTrackIndex + 1) % backgroundPlaylist.length; const nextPlayer = backgroundPlaylist[currentTrackIndex]; nextPlayer.currentTime = 0; nextPlayer.play(); }; backgroundPlaylist.forEach(player => { player.volume = 0.25; player.onended = playNextTrack; }); const initialPlayer = backgroundPlaylist[currentTrackIndex]; initialPlayer.play().catch(error => { console.log("Music play was prevented by the browser."); }); musicHasStarted = true; }
        
        // STATS FEATURE: This function shows the stats modal
        async function showStatsModal() {
            if (!isAuthReady || !localPlayerUid) {
                showMessage("Nagi-intay kumonekta sa server...", 2000);
                return;
            }
            gameModeSelect.classList.remove('show');
            statsModal.classList.add('show');
            history.pushState({ modal: 'statsModal' }, 'My Stats', '#stats');

            // Show loading state
            statsDisplayName.textContent = 'Nagloload...';
            ['stats-gamesPlayed', 'stats-wins', 'stats-losses', 'stats-winRate', 'stats-pokerWins', 'stats-straightBallWins', 'stats-61BallWins'].forEach(id => {
                document.getElementById(id).textContent = '...';
            });

            try {
                const playerDocRef = doc(db, `/artifacts/${appId}/public/data/players`, localPlayerUid);
                const playerDoc = await getDoc(playerDocRef);

                if (playerDoc.exists()) {
                    const data = playerDoc.data();
                    const wins = data.wins || 0;
                    const losses = data.losses || 0;
                    const gamesPlayed = wins + losses;
                    const winRate = gamesPlayed > 0 ? ((wins / gamesPlayed) * 100).toFixed(1) + '%' : '0%';

                    statsDisplayName.textContent = data.displayName || 'Anonymous';
                    statsGamesPlayed.textContent = gamesPlayed;
                    statsWins.textContent = wins;
                    statsLosses.textContent = losses;
                    statsWinRate.textContent = winRate;
                    statsPokerWins.textContent = data.pokerWins || 0;
                    statsStraightBallWins.textContent = data.straightBallWins || 0;
                    stats61BallWins.textContent = data.sixtyOneWins || 0;
                } else {
                    // Player has no stats yet
                    statsDisplayName.textContent = localStorage.getItem('pinoyPoolPlayerName') || 'Bagong Player';
                    statsGamesPlayed.textContent = 0;
                    statsWins.textContent = 0;
                    statsLosses.textContent = 0;
                    statsWinRate.textContent = '0%';
                    statsPokerWins.textContent = 0;
                    statsStraightBallWins.textContent = 0;
                    stats61BallWins.textContent = 0;
                }
            } catch (error) {
                console.error("Error fetching player stats:", error);
                statsDisplayName.textContent = 'Error';
            }
        }

        async function showLeaderboard() { leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr>'; gameModeSelect.classList.remove('show'); leaderboardModal.classList.add('show'); history.pushState({ modal: 'leaderboardModal' }, 'Leaderboard', '#leaderboard'); try { const playersRef = collection(db, `/artifacts/${appId}/public/data/players`); const q = query(playersRef, orderBy("wins", "desc"), limit(100)); const querySnapshot = await getDocs(q); leaderboardBody.innerHTML = ''; if (querySnapshot.empty) { leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">No players yet. Be the first!</td></tr>'; return; } let rank = 1; querySnapshot.forEach((doc) => { const playerData = doc.data(); const row = document.createElement('tr'); row.innerHTML = ` <td style="padding: 8px;">#${rank}</td> <td style="padding: 8px;">${playerData.displayName}</td> <td style="padding: 8px;">${playerData.wins || 0}</td> `; leaderboardBody.appendChild(row); rank++; }); } catch (error) { console.error("Error fetching leaderboard: ", error); leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Could not load leaderboard. Check console for errors.</td></tr>'; showMessage("Error: You may need to create a Firestore index. Check the console (F12) for a link.", 5000); } }
        
        // NEW: Presence System
        
        
        // NEW: Online Hall Logic
        async function showOnlineHall() {
            if (!isAuthReady) { showMessage("Connecting... Please wait.", 2000); return; }
            gameModeSelect.classList.remove('show');
            onlineHallModal.classList.add('show');
            history.pushState({ modal: 'onlineHallModal' }, 'Online Hall', '#hall');

            onlinePlayersList.innerHTML = '<li>Loading...</li>';

            if (unsubscribePlayerStatus) unsubscribePlayerStatus();

            const statusQuery = query(collection(db, `/artifacts/${appId}/public/data/playerStatus`), where("online", "==", true));
            unsubscribePlayerStatus = onSnapshot(statusQuery, (snapshot) => {
                onlinePlayersList.innerHTML = '';
                if (snapshot.docs.length <= 1 && snapshot.docs.every(d => d.id === localPlayerUid)) { // Check if only self is online
                    onlinePlayersList.innerHTML = '<li class="no-players-online">No one else is online right now.</li>';
                    return;
                }
                snapshot.forEach(doc => {
                    const playerData = doc.data();
                    const playerUid = doc.id;

                    if (playerUid === localPlayerUid) return; // Don't show self

                    const li = document.createElement('li');
                    li.className = 'player-list-item';

                    li.innerHTML = `
                        <span class="online-indicator"></span>
                        <span class="player-name">${playerData.displayName || 'Anonymous'}</span>
                        <div class="player-actions">
                            <button class="challenge-btn" data-uid="${playerUid}" data-name="${playerData.displayName || 'Anonymous'}">Challenge</button>
                        </div>
                    `;
                    onlinePlayersList.appendChild(li);
                });
                
                // Add event listeners to the new buttons
                document.querySelectorAll('.challenge-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const opponentUid = e.target.getAttribute('data-uid');
                        const opponentName = e.target.getAttribute('data-name');
                        e.target.disabled = true;
                        e.target.textContent = 'Sent!';
                        sendChallenge(opponentUid, opponentName);
                    });
                });
            });
        }
        
        // NEW: Challenge Logic
        async function sendChallenge(opponentUid, opponentName) {
            playButtonSound();
            const challengeDocRef = doc(collection(db, `/artifacts/${appId}/public/data/challenges`));
            
            const playerDoc = await getDoc(doc(db, `/artifacts/${appId}/public/data/players`, localPlayerUid));
            const challengerName = playerDoc.exists() && playerDoc.data().displayName ? playerDoc.data().displayName : (localStorage.getItem('pinoyPoolPlayerName') || 'Anonymous');

            await setDoc(challengeDocRef, {
                challengerUid: localPlayerUid,
                challengerName: challengerName,
                challengedUid: opponentUid,
                status: 'pending', // pending, accepted, declined, expired
                createdAt: serverTimestamp()
            });
            showMessage(`Challenge sent to ${opponentName}!`);
        }

        function listenForChallenges() {
            if (unsubscribeChallenges) unsubscribeChallenges();
            const q = query(collection(db, `/artifacts/${appId}/public/data/challenges`), where('challengedUid', '==', localPlayerUid), where('status', '==', 'pending'));
            
            unsubscribeChallenges = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const challengeDoc = change.doc;
                        // Avoid processing the same challenge if already showing one
                        if (currentChallenge && currentChallenge.id === challengeDoc.id) return;
                        
                        currentChallenge = { id: challengeDoc.id, ...challengeDoc.data() };
                        
                        challengeText.textContent = `${currentChallenge.challengerName} challenges you to a game!`;
                        challengeReceivedModal.classList.add('show');
                    }
                });
            });
        }
        
        async function acceptChallenge() {
            if (!currentChallenge) return;
            challengeReceivedModal.classList.remove('show');
            const challengeDocRef = doc(db, `/artifacts/${appId}/public/data/challenges`, currentChallenge.id);
            
            // Create a game and get the ID
            const newGameId = await createOnlineGame(true); // true = silent creation
            
            await updateDoc(challengeDocRef, {
                status: 'accepted',
                gameId: newGameId
            });

            // Join the game you just created
            gameId = newGameId;
            localPlayerId = 'player1'; // The challenged player (accepter) creates the game
            listenToGameUpdates(gameId);

            currentChallenge = null;
        }

        async function declineChallenge() {
             if (!currentChallenge) return;
             await updateDoc(doc(db, `/artifacts/${appId}/public/data/challenges`, currentChallenge.id), { status: 'declined' });
             challengeReceivedModal.classList.remove('show');
             currentChallenge = null;
        }


        async function createOnlineGame(isSilent = false) { 
            if (!isAuthReady || !localPlayerUid) { showMessage("Authenticating... Please wait."); return; } 
            if(!isSilent) onlineMenu.classList.remove('show'); 
            resizeCanvas(); 
            gameMode = `online-${selectedOnlineGameType}`; 
            setupChips(); 
            const newGameId = Math.random().toString(36).substring(2, 7).toUpperCase(); 
            localPlayerId = 'player1'; 
            lastProcessedTurnId = -1; 
            const initialChipsToSend = chips.map(c => ({...c, x: c.x/canvas.width, y: c.y/canvas.height })); 
            const gameData = { gameId: newGameId, gameType: selectedOnlineGameType, gameState: 'waiting', turnId: 0, players: { player1: { uid: localPlayerUid, status: 'online' }, player2: null }, chips: initialChipsToSend, currentTurnUid: null, lastShot: null, liveAimData: null, turnInProgress: false, canMoveCueBall: true, isBreakShot: true, winner: null }; 
            if (selectedOnlineGameType === 'poker') { createDeck(); dealCards(); Object.assign(gameData, { deck, player1Hand: playerHand, player2Hand: opponentHand, originalPlayer1Hand: originalPlayerHand, originalPlayer2Hand: originalOpponentHand }); } else if (selectedOnlineGameType === 'straight-ball') { Object.assign(gameData, { colorsAssigned: false, player1ChipsType: null, player2ChipsType: null }); } else if (selectedOnlineGameType === '61-ball') { Object.assign(gameData, { player1_61Score: 0, player2_61Score: 0, lowestChipNumber: 1 }); } 
            try { 
                await setDoc(doc(db, `/artifacts/${appId}/public/data/games`, newGameId), gameData); 
                if (!isSilent) {
                    gameId = newGameId;
                    gameIdDisplay.textContent = gameId; 
                    waitingRoom.classList.add('show'); 
                    history.pushState({ modal: 'waitingRoom' }, 'Waiting Room', '#wait'); 
                    listenToGameUpdates(gameId); 
                }
                return newGameId; // Return ID for challenges
            } catch (error) { 
                if (!isSilent) {
                    showMessage("Failed to create game.", 3000); 
                    console.error("Firebase setDoc error:", error); 
                    onlineMenu.classList.add('show'); 
                    history.back(); 
                }
                return null;
            } 
        }

        async function joinOnlineGame() { 
            if (!isAuthReady || !localPlayerUid) { showMessage("Authenticating... Please wait."); return; } 
            const inputId = gameIdInput.value.trim().toUpperCase(); 
            if (!inputId) { showMessage("Please enter a Game ID."); return; } 
            const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, inputId); 
            try { 
                const docSnap = await getDoc(gameDocRef); 
                if (docSnap.exists()) { 
                    if (docSnap.data().gameState !== 'waiting') { showMessage("Game is full."); return; } 
                    onlineMenu.classList.remove('show'); 
                    showMessage("Joining game..."); 
                    const startingPlayerUid = Math.random() < 0.5 ? docSnap.data().players.player1.uid : localPlayerUid; 
                    await updateDoc(gameDocRef, { 'players.player2': { uid: localPlayerUid, status: 'online' }, 'gameState': 'playing', 'currentTurnUid': startingPlayerUid, 'turnId': 1 }); 
                    gameId = inputId; 
                    localPlayerId = 'player2'; 
                    listenToGameUpdates(inputId); 
                } else { 
                    showMessage("Game not found."); 
                } 
            } catch (error) { 
                showMessage("Failed to join game.", 3000); 
            } 
        }

        async function cancelOnlineGame() { if (gameId) { try { await deleteDoc(doc(db, `/artifacts/${appId}/public/data/games`, gameId)); gameId = null; } catch (e) { console.error("Error cancelling", e); } } resetToMenu(); }
        async function resetOnlineGameForRematch(gameData) { if (unsubscribeGameListener) unsubscribeGameListener(); gameMode = `online-${gameData.gameType}`; resizeCanvas(); setupChips(); const newChipsState = chips.map(c => ({...c, x: c.x / canvas.width, y: c.y / canvas.height })); const startingPlayerUid = Math.random() < 0.5 ? gameData.players.player1.uid : gameData.players.player2.uid; const resetData = { gameState: 'playing', chips: newChipsState, currentTurnUid: startingPlayerUid, canMoveCueBall: true, isBreakShot: true, winner: null, rematchRequest: null, turnId: (gameData.turnId || 0) + 10, lastShot: null }; if (gameData.gameType === 'poker') { createDeck(); dealCards(); Object.assign(resetData, { deck, player1Hand: localPlayerId === 'player1' ? playerHand : opponentHand, player2Hand: localPlayerId === 'player1' ? opponentHand : playerHand, originalPlayer1Hand: localPlayerId === 'player1' ? originalPlayerHand : originalOpponentHand, originalPlayer2Hand: localPlayerId === 'player1' ? originalOpponentHand : originalPlayerHand, }); } else if (gameData.gameType === '61-ball') { Object.assign(resetData, { player1_61Score: 0, player2_61Score: 0, lowestChipNumber: 1 }); } else if (gameData.gameType === 'straight-ball') { Object.assign(resetData, { colorsAssigned: false, player1ChipsType: null, player2ChipsType: null }); } try { await updateDoc(doc(db, `/artifacts/${appId}/public/data/games`, gameId), resetData); } catch (error) { console.error("Failed to reset game for rematch:", error); } finally { listenToGameUpdates(gameId); } }
        function sendLiveAimData() { if (!isOnlineGame || !isMyTurnOnline || !gameId || table.width === 0) return; const now = Date.now(); if (now - lastAimUpdateTime < AIM_UPDATE_INTERVAL) return; lastAimUpdateTime = now; const cueChip = chips.find(c => c.id === 0); if (!cueChip) return; const dataToSend = { angle: cueStick.angle, cueBallX: cueChip.x/canvas.width, cueBallY: cueChip.y/canvas.height, pektusX: pektusOffset.x, pektusY: pektusOffset.y, sender: localPlayerUid }; updateDoc(doc(db, `/artifacts/${appId}/public/data/games`, gameId), { liveAimData: dataToSend }).catch(() => {}); }
        function listenToGameUpdates(gameId) { 
            let lastShotTimestamp = 0; 
            setupChatListener(gameId); 
            // NEW: Also listen for challenges being accepted
            if (unsubscribeChallenges) unsubscribeChallenges();
            const challengeQuery = query(collection(db, `/artifacts/${appId}/public/data/challenges`), where('challengerUid', '==', localPlayerUid), where('status', '==', 'accepted'));
            unsubscribeChallenges = onSnapshot(challengeQuery, async (snapshot) => {
                 snapshot.docChanges().forEach(async (change) => {
                     if (change.type === "added") {
                         const acceptedChallenge = change.doc.data();
                         const acceptedGameId = acceptedChallenge.gameId;
                         onlineHallModal.classList.remove('show');
                         showMessage("Challenge accepted! Joining game...");
                         gameId = acceptedGameId;
                         localPlayerId = 'player2';
                         listenToGameUpdates(gameId);
                         await deleteDoc(doc(db, `/artifacts/${appId}/public/data/challenges`, change.doc.id));
                     }
                 });
            });


            unsubscribeGameListener = onSnapshot(doc(db, `/artifacts/${appId}/public/data/games`, gameId), (doc) => { 
                if (!doc.exists()) { 
                    if (gameState !== 'menu' && gameState !== 'gameover') { showMessage("Game ended by host.", 3000); resetToMenu(); } return; 
                } 
                const gameData = doc.data(); 
                if (!gameData) return; 
                if (gameData.lastShot && gameData.lastShot.timestamp > lastShotTimestamp && !chipsMoving) { 
                    lastShotTimestamp = gameData.lastShot.timestamp; 
                    animateAndApplyShot(gameData.lastShot); 
                } 
                if (gameData.gameState === 'finished' && gameData.rematchRequest) { 
                    const players = Object.keys(gameData.players).filter(p => gameData.players[p] !== null); 
                    if (players.length === 2) { 
                        const playerUIDs = players.map(p => gameData.players[p].uid); 
                        const player1_uid = playerUIDs[0]; 
                        const player2_uid = playerUIDs[1]; 
                        const iWantRematch = gameData.rematchRequest[localPlayerUid]; 
                        const opponentUid = localPlayerUid === player1_uid ? player2_uid : player1_uid; 
                        const opponentWantsRematch = gameData.rematchRequest[opponentUid]; 
                        const rematchButton = document.getElementById('rematch-button'); 
                        if (iWantRematch && opponentWantsRematch) { 
                            if (localPlayerId === 'player1') { resetOnlineGameForRematch(gameData); } 
                        } else if (opponentWantsRematch && !iWantRematch) { 
                            rematchButton.textContent = 'Accept Rematch'; 
                        } 
                    } 
                } 
                syncGameState(gameData); 
            }); 
        }
        async function leaveOnlineGame(isForfeit) { if (!isOnlineGame || !gameId || !localPlayerId) return; const gameDocRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId); try { const docSnap = await getDoc(gameDocRef); if (docSnap.exists() && docSnap.data().gameState !== 'finished') { const opponentId = localPlayerId === 'player1' ? 'player2' : 'player1'; const winnerUid = docSnap.data().players[opponentId]?.uid; if (isForfeit && winnerUid) { await updateDoc(gameDocRef, { gameState: 'finished', winner: winnerUid, [`players.${localPlayerId}.status`]: 'disconnected' }); } else { await updateDoc(gameDocRef, { [`players.${localPlayerId}.status`]: 'disconnected' }); } } } catch (error) { console.error("Error leaving/forfeiting game:", error); } }
        function isPathObstructed(startObj, endObj, ignoreChipIds = []) { const allObstacles = chips.filter(c => c.inPlay && !ignoreChipIds.includes(c.id)); for (const obstacle of allObstacles) { const dist = Math.abs((endObj.y - startObj.y) * obstacle.x - (endObj.x - startObj.x) * obstacle.y + endObj.x * startObj.y - endObj.y * startObj.x) / Math.hypot(endObj.y - startObj.y, endObj.x - startObj.x); const safetyMargin = 4 * scale; const effectiveRadius = obstacle.radius + (startObj.radius || 0) + safetyMargin; if (dist < effectiveRadius) { const dotProduct = (obstacle.x - startObj.x) * (endObj.x - startObj.x) + (obstacle.y - startObj.y) * (endObj.y - startObj.y); const squaredLength = Math.pow(Math.hypot(endObj.x - startObj.x, endObj.y - startObj.y), 2); if (dotProduct > 0 && dotProduct < squaredLength) { return true; } } } return false; }
        function isAnyDirectPathClear(cueChip, legalTargets) { if (!legalTargets || legalTargets.length === 0) return false; for (const target of legalTargets) { if (!isPathObstructed(cueChip, target, [])) return true; } return false; }
        function evaluateShot(cueChip, targetChip, hole, allLegalTargets, difficulty, isCombination = false) { let firstContactTarget = isCombination ? allLegalTargets[0] : targetChip; if (!firstContactTarget) return null; const aiTargetHole = { x: hole.x, y: hole.y }; let shotAngle; if (isCombination) { const impactAngle1 = Math.atan2(aiTargetHole.y - targetChip.y, aiTargetHole.x - targetChip.x); const pfm = { x: targetChip.x - Math.cos(impactAngle1) * (firstContactTarget.radius + targetChip.radius), y: targetChip.y - Math.sin(impactAngle1) * (firstContactTarget.radius + targetChip.radius) }; const impactAngle2 = Math.atan2(pfm.y - firstContactTarget.y, pfm.x - firstContactTarget.x); const gbfc = { x: firstContactTarget.x - Math.cos(impactAngle2) * (cueChip.radius + firstContactTarget.radius), y: firstContactTarget.y - Math.sin(impactAngle2) * (cueChip.radius + firstContactTarget.radius) }; shotAngle = Math.atan2(gbfc.y - cueChip.y, gbfc.x - cueChip.y); } else { const targetToHoleAngle = Math.atan2(aiTargetHole.y - targetChip.y, aiTargetHole.x - targetChip.x); const ghostBall = { x: targetChip.x - Math.cos(targetToHoleAngle) * (cueChip.radius + targetChip.radius), y: targetChip.y - Math.sin(targetToHoleAngle) * (cueChip.radius + targetChip.radius) }; shotAngle = Math.atan2(ghostBall.y - cueChip.y, ghostBall.x - cueChip.y); } const path1Clear = !isPathObstructed(cueChip, firstContactTarget, [targetChip.id]); const path2Clear = !isPathObstructed(targetChip, hole, [cueChip.id, firstContactTarget.id]); let path3Clear = !isCombination || !isPathObstructed(firstContactTarget, targetChip, [cueChip.id]); if (!path1Clear || !path2Clear || !path3Clear) return null; const distance = Math.hypot(firstContactTarget.x - cueChip.x, firstContactTarget.y - cueChip.y); const lineToTargetCenterAngle = Math.atan2(firstContactTarget.y - cueChip.y, firstContactTarget.x - cueChip.x); const cutAngle = shotAngle - lineToTargetCenterAngle; const anglePenalty = (Math.abs(cutAngle) / (Math.PI / 2)) * 0.7; const distancePenalty = (distance / canvas.width) * 0.5; let probability = 1.0 - distancePenalty - anglePenalty; if (isCombination) probability *= 0.6; let pocketingScore = 1000; if (gameMode.includes('61-ball')) { pocketingScore += targetChip.value * 20; } const power = Math.min(1.2, (distance / (canvas.width * 0.5)) + 0.3); const predictedCuePos = predictSimpleCuePos(cueChip, firstContactTarget, shotAngle, power); let positionalScore = calculatePositionalScore(predictedCuePos, targetChip.id, allLegalTargets); let positionalMultiplier = 1.0; if (difficulty === 'easy') positionalMultiplier = 0.2; else if (difficulty === 'hard') positionalMultiplier = 0.6; const totalScore = (pocketingScore + (positionalScore * positionalMultiplier)) * Math.max(0, probability); return { angle: shotAngle, power, score: totalScore, probability: Math.max(0, probability), target: targetChip, hole: hole, firstContactTarget: firstContactTarget, isCombination }; }
        
        // AI BEHAVIOR - START
        function aiTurn() {
            if (gameState !== 'aiming' || chipsMoving || !chips[0]?.inPlay) return;
            const cueChip = chips[0];
            let allLegalTargets = [], allPocketableChips = [];

            if (gameMode.includes('poker')) {
                allLegalTargets = chips.filter(c => c.inPlay && opponentHand.some(card => card.value === c.id));
                allPocketableChips = allLegalTargets;
            } else if (gameMode.includes('61-ball')) {
                const lowestChip = chips.find(c => c.id === lowestChipNumber);
                if (!lowestChip) {
                    setTimeout(handleTurnEnd, 500);
                    return;
                }
                allLegalTargets = [lowestChip];
                allPocketableChips = chips.filter(c => c.inPlay && c.id !== 0);
            } else {
                if (colorsAssigned && opponentChipsType) allLegalTargets = chips.filter(c => c.inPlay && c.type === opponentChipsType);
                else allLegalTargets = chips.filter(c => c.inPlay && (c.type === 'red' || c.type === 'blue'));
                allPocketableChips = allLegalTargets;
            }

            let simplePots = [];
            let complexShots = [];

            for (const target of allLegalTargets) {
                for (const hole of holes) {
                    const evaluation = evaluateShot(cueChip, target, hole, allLegalTargets, difficulty, false);
                    if (evaluation) simplePots.push(evaluation);
                }
            }
            if (gameMode.includes('61-ball')) {
                for (const target of allPocketableChips.filter(c => c.id !== allLegalTargets[0].id)) {
                    for (const hole of holes) {
                        const evaluation = evaluateShot(cueChip, target, hole, allLegalTargets, difficulty, true);
                        if (evaluation) complexShots.push(evaluation);
                    }
                }
            }

            const allPossibleShots = [...simplePots, ...complexShots];
            let bestShot;
            let isKickShot = false;
            let isDefensiveShot = false;

            if (allPossibleShots.length > 0) {
                allPossibleShots.sort((a, b) => b.score - a.score);
                let shotIndex = 0;
                const randomFactor = Math.random();
                
                if (randomFactor < 0.20 && allPossibleShots.length > 1) {
                    shotIndex = 1;
                } else if (randomFactor < 0.05 && allPossibleShots.length > 2) {
                    shotIndex = 2;
                }
                
                bestShot = allPossibleShots[shotIndex];

                const chanceToPlaySafe = (aiConsecutivePots === 0) ? 0.3 : 0.05;
                if (bestShot.probability < 0.6 && Math.random() < chanceToPlaySafe) {
                    const defensiveShot = findBestDefensiveShot(cueChip, allLegalTargets);
                    if (defensiveShot && defensiveShot.score > (bestShot.score * 0.5)) {
                        bestShot = { ...defensiveShot, isDefensive: true };
                        isDefensiveShot = true;
                        showMessage("AI is playing safe...", 2000);
                    }
                }
            } else {
                showMessage("AI is calculating a kick shot...", 2000);
                bestShot = findBestKickShot(cueChip, allLegalTargets);
                isKickShot = true;

                if (!bestShot) {
                    bestShot = findBestDefensiveShot(cueChip, allLegalTargets);
                    isDefensiveShot = true;
                }
                if (!bestShot) {
                    const finalTarget = allLegalTargets[0] || allPocketableChips[0];
                    if (finalTarget) {
                        bestShot = { angle: Math.atan2(finalTarget.y - cueChip.y, finalTarget.x - cueChip.x), power: 0.4, probability: 0.5 };
                    } else {
                        setTimeout(handleTurnEnd, 500);
                        return;
                    }
                }
            }

            let pacing = {};
            const shotProbability = bestShot.probability || 1.0;

            if (isKickShot || isDefensiveShot) {
                pacing = { DURATION_ALIGN: 1500, DURATION_FEATHER: 3000, DURATION_PAUSE: 500 };
            } else if (shotProbability < 0.7) {
                pacing = { DURATION_ALIGN: 1000, DURATION_FEATHER: 2500, DURATION_PAUSE: 200 };
            } else if (shotProbability > 0.95) {
                pacing = { DURATION_ALIGN: 500, DURATION_FEATHER: 1500, DURATION_PAUSE: 0 };
            }
            
            animateAiAiming(bestShot.angle, bestShot.power, pacing);
        }
                
        function findBestKickShot(cueChip, legalTargets) { let bestKickShot = { score: -Infinity }; const cushions = [ { type: 'y', val: 0 }, { type: 'y', val: canvas.height }, { type: 'x', val: 0 }, { type: 'x', val: canvas.width } ]; for (const target of legalTargets) { for (const cushion of cushions) { let virtualCue = (cushion.type === 'y') ? { x: cueChip.x, y: cushion.val * 2 - cueChip.y } : { x: cushion.val * 2 - cueChip.x, y: cueChip.y }; const angleToVirtual = Math.atan2(target.y - virtualCue.y, target.x - virtualCue.x); const impactPoint = (cushion.type === 'y') ? { y: cushion.val, x: cueChip.x + (cushion.val - cueChip.y) / Math.tan(angleToVirtual) } : { x: cushion.val, y: cueChip.y + (cushion.val - cueChip.x) * Math.tan(angleToVirtual) }; const pathToCushionClear = !isPathObstructed(cueChip, impactPoint, [target.id]); const pathFromCushionClear = !isPathObstructed(impactPoint, target, [cueChip.id]); if (pathToCushionClear && pathFromCushionClear) { const finalShotAngle = Math.atan2(impactPoint.y - cueChip.y, impactPoint.x - cueChip.x); const distance = Math.hypot(impactPoint.x - cueChip.x, impactPoint.y - cueChip.y) + Math.hypot(target.x - impactPoint.x, target.y - impactPoint.y); const power = Math.min(1.0, (distance / canvas.width) * 1.5) + 0.3; const score = 500 - distance; if (score > bestKickShot.score) { bestKickShot = { score, angle: finalShotAngle, power, probability: 0.7 }; } } } } return bestKickShot.score > -Infinity ? bestKickShot : null; }
        function predictSimpleCuePos(cueChip,targetChip,shotAngle,power){const distance=Math.hypot(targetChip.x-cueChip.x,targetChip.y-cueChip.y);const followDistance=(power*power)*(distance*0.4);return{id:0,x:targetChip.x+Math.cos(shotAngle)*followDistance,y:targetChip.y+Math.sin(shotAngle)*followDistance,radius:cueChip.radius};}
        function calculatePositionalScore(predictedCuePos,justPocketedId,allLegalTargets){let nextTargets=[];if(gameMode.includes('poker'))nextTargets=allLegalTargets.filter(t=>t.id!==justPocketedId);else if(gameMode.includes('61-ball')){const remaining=chips.filter(c=>c.inPlay&&c.id!==0&&c.id!==justPocketedId);if(remaining.length>0)nextTargets=[remaining.sort((a,b)=>a.id-b.id)[0]];}else nextTargets=allLegalTargets.filter(t=>t.id!==justPocketedId);if(nextTargets.length===0)return 800;const nextBestTarget=nextTargets.sort((a,b)=>Math.hypot(a.x-predictedCuePos.x,a.y-predictedCuePos.y)-Math.hypot(b.x-predictedCuePos.x,b.y-predictedCuePos.y))[0];let score=600-Math.hypot(nextBestTarget.x-predictedCuePos.x,nextBestTarget.y-predictedCuePos.y);if(isPathObstructed(predictedCuePos,nextBestTarget,[]))score-=400;let bestAngleScore=-200;for(const hole of holes){if(!isPathObstructed(nextBestTarget,hole,[predictedCuePos.id])){const angleToHole=Math.atan2(hole.y-nextBestTarget.y,hole.x-nextBestTarget.y);const shotLine=Math.atan2(nextBestTarget.y-predictedCuePos.y,nextBestTarget.x-predictedCuePos.x);const cutAngle=Math.abs(angleToHole-shotLine);const angleBonus=200*(1-cutAngle/(Math.PI/2));if(angleBonus>bestAngleScore)bestAngleScore=angleBonus;}}score+=bestAngleScore;return score;}
        function findBestDefensiveShot(cueChip,legalTargets){if(!legalTargets||legalTargets.length===0)return null;let bestSafety={score:-Infinity,angle:0,power:0};const primaryTarget=legalTargets[0];const opponentNextTarget=primaryTarget;for(let i=0;i < 32;i++){const angleOffset=(Math.random()-0.5)*(Math.PI/4);const shotAngle=Math.atan2(primaryTarget.y-cueChip.y,primaryTarget.x-cueChip.x)+angleOffset;const power=0.25+Math.random()*0.2;const predictedCuePos=predictSimpleCuePos(cueChip,primaryTarget,shotAngle,power);if(holes.some(h=>Math.hypot(h.x-predictedCuePos.x,h.y-predictedCuePos.y)<h.radius*1.2))continue;let safetyScore=0;safetyScore+=Math.hypot(predictedCuePos.x-opponentNextTarget.x,predictedCuePos.y-opponentNextTarget.y);const distToCushion=Math.min(predictedCuePos.x,canvas.width-predictedCuePos.x,predictedCuePos.y,canvas.height-predictedCuePos.y);if(distToCushion<cueChip.radius*3)safetyScore+=300;let blockingBallsCount=0;for(const chip of chips){if(chip.inPlay&&chip.id!==cueChip.id&&chip.id!==opponentNextTarget.id){const distToLine=Math.abs((opponentNextTarget.y-predictedCuePos.y)*chip.x-(opponentNextTarget.x-predictedCuePos.x)*chip.y+opponentNextTarget.x*predictedCuePos.y-opponentNextTarget.y*predictedCuePos.x)/Math.hypot(opponentNextTarget.y-predictedCuePos.y,opponentNextTarget.x-predictedCuePos.x);if(distToLine<chip.radius*2)blockingBallsCount++;}}safetyScore+=blockingBallsCount*400;if(safetyScore>bestSafety.score)bestSafety={score:safetyScore,angle:shotAngle,power:power,probability:0.9};}return bestSafety.score>-Infinity?bestSafety:null;}
        function placeCueChipForAI() { cueBallGuide.style.display = 'none'; dragGuideText.style.display = 'none'; const cueChip = chips[0]; gameState = 'ai_placing'; if (isBreakShot) { const breakLineX = canvas.width * 0.25; const offsetFromCenter = canvas.height * 0.1; const headsOrTails = Math.random(); cueChip.x = breakLineX; cueChip.y = (headsOrTails < 0.5) ? (canvas.height / 2) + offsetFromCenter : (canvas.height / 2) - offsetFromCenter; } else { const breakLineX = canvas.width * 0.25; let bestPlacement = { score: -Infinity, x: 0, y: 0 }; for (let i = 0; i < 40; i++) { const safeMargin = cueChip.radius + (5 * scale); const placementWidth = canvas.width - (safeMargin * 2); const proposedX = (Math.random() * placementWidth) + safeMargin; const proposedY = (Math.random() * (canvas.height - safeMargin * 2)) + safeMargin; if (isPositionOccupied(proposedX, proposedY, cueChip)) continue; const tempCueChip = { ...cueChip, x: proposedX, y: proposedY }; let legalTargets = chips.filter(c => c.inPlay && c.id !== 0); let bestScoreFromPos = -Infinity; for (const target of legalTargets) { for (const hole of holes) { const evalShot = evaluateShot(tempCueChip, target, hole, legalTargets, 'hard'); if (evalShot && evalShot.score > bestScoreFromPos) bestScoreFromPos = evalShot.score; } } if (bestScoreFromPos > bestPlacement.score) { bestPlacement = { score: bestScoreFromPos, x: proposedX, y: proposedY }; } } if (bestPlacement.score > -Infinity) { cueChip.x = bestPlacement.x; cueChip.y = bestPlacement.y; } else { cueChip.x = canvas.width * 0.25; cueChip.y = canvas.height / 2; } } setTimeout(() => { canMoveCueBall = false; gameState = 'aiming'; cueStick.visible = true; if (cueStickElement) cueStickElement.style.display = 'block'; setTimeout(aiTurn, 500); }, 700); }
        
        function animateAiAiming(targetAngle, finalPower, pacingOptions = {}) {
            const startTime = performance.now();
            const startAngle = cueStick.angle;

            const defaults = {
                DURATION_ALIGN: 800,
                DURATION_FEATHER: 2500,
                DURATION_PAUSE: 0
            };

            const { DURATION_ALIGN, DURATION_FEATHER, DURATION_PAUSE } = { ...defaults, ...pacingOptions };

            const FEATHER_COUNT = 1.5;
            const FEATHER_DISTANCE = 60 * scale;
            const TOTAL_DURATION = DURATION_ALIGN + DURATION_FEATHER + DURATION_PAUSE;

            function animate(currentTime) {
                const elapsedTime = currentTime - startTime;
                if (elapsedTime < DURATION_ALIGN) {
                    const alignProgress = elapsedTime / DURATION_ALIGN;
                    const easeOut = 1 - Math.pow(1 - alignProgress, 4);
                    cueStick.angle = startAngle + (targetAngle - startAngle) * easeOut;
                    cueStick.pullback = 0;
                } else if (elapsedTime < DURATION_ALIGN + DURATION_FEATHER) {
                    cueStick.angle = targetAngle;
                    const featherTime = elapsedTime - DURATION_ALIGN;
                    const featherProgress = featherTime / DURATION_FEATHER;
                    cueStick.pullback = Math.abs(Math.sin(featherProgress * Math.PI * (FEATHER_COUNT * 2))) * FEATHER_DISTANCE;
                } else if (elapsedTime < TOTAL_DURATION) {
                    cueStick.angle = targetAngle;
                    cueStick.pullback = 0;
                } else {
                    cueStick.angle = targetAngle;
                    shoot(finalPower * 40 + 2);
                    return;
                }
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }
        // AI BEHAVIOR - END
                
        function placeChipOnSpot(chipToPlace){ const spotX = canvas.width * (gameMode.includes('61-ball') ? 0.75 : 0.7); const spotY = canvas.height / 2; let finalX = spotX, finalY = spotY, attempts = 0; while(attempts < 100){ if(!chips.some(c => c.inPlay && c.id !== chipToPlace.id && (finalX - c.x)**2 + (finalY - c.y)**2 < (c.radius + chipToPlace.radius)**2)) break; const angle = attempts * 0.5, radius = chipToPlace.radius * 1.2 * Math.sqrt(attempts + 1); finalX = spotX + Math.cos(angle) * radius; finalY = spotY + Math.sin(angle) * radius; attempts++; } chipToPlace.x = finalX; chipToPlace.y = finalY; }
        function createDeck() { deck = []; const suits = ['♥', '♦', '♣', '♠'], ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']; for (const suit of suits) for (const rank of ranks) { let value = parseInt(rank); if(rank==='A') value=1; else if(rank==='J') value=11; else if(rank==='Q') value=12; else if(rank==='K') value=13; deck.push({ suit, rank, value }); }}
        function dealCards() { playerHand = []; opponentHand = []; for (let i = deck.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [deck[i], deck[j]]=[deck[j], deck[i]]; } for (let i = 0; i < 7; i++) { if(deck.length > 0) playerHand.push(deck.pop()); if(deck.length > 0) opponentHand.push(deck.pop()); } originalPlayerHand = [...playerHand]; originalOpponentHand = [...opponentHand]; }
        function toggleFullScreen() { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => showMessage(`Could not activate full-screen mode.`, 2000)); else if (document.exitFullscreen) document.exitFullscreen(); }
        
        function handlePointerDown(e) { 
            e.preventDefault(); 

            if (isTutorialActive) {
                const currentStep = tutorialSteps[tutorialStep];
                if (currentStep && currentStep.trigger === 'drag') {
                    // This is handled in pointerMove to detect the start of the drag
                }
            }

            const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn; 
            if (!isMyTurn || (isOnlineGame && isSyncing)) return; 
            const targetId = e.currentTarget.id; 
            if (gameState === 'moving' && canMoveCueBall && targetId === 'game-canvas') { 
                isDraggingCueBall = true; 
                cueStick.visible = false; 
                ghostHand.style.display = 'block'; 
                dragGuideText.style.display = 'none'; 
                updateCueBallPosition(e); 
            } else if (gameState === 'aiming') { 
                if (targetId === 'game-canvas') { 
                    isAimingOnCanvas = true; 
                    updateAimFromCanvas(e); 
                } else if (targetId === 'power-control') {
                    isPoweringUp = true;
                } else if (targetId === 'pektus-control') { 
                    isDraggingPektusDot = true; 
                    handlePektusInput(e); 
                } else if (targetId === 'left-arrow') {
                    isRotatingLeft = true; 
                } else if (targetId === 'right-arrow') {
                    isRotatingRight = true; 
                }
            } 
        }

        function handlePointerMove(e) { 
            if (isTutorialActive) {
                const currentStep = tutorialSteps[tutorialStep];
                if (currentStep) {
                    if (isDraggingCueBall && currentStep.key === 'place') {
                        // Position is updated by the main logic below
                    } else if (isAimingOnCanvas && currentStep.key === 'aim') {
                        nextTutorialStep();
                    } else if (isDraggingPektusDot && currentStep.key === 'pektus') {
                        nextTutorialStep();
                    } else if (isPoweringUp && currentStep.key === 'power' && cueStick.power > 0.5) {
                        nextTutorialStep();
                    }
                }
            }

            if (isDraggingCueBall) { 
                e.preventDefault(); 
                const clientX = e.touches ? e.touches[0].clientX : e.clientX; 
                const clientY = e.touches ? e.touches[0].clientY : e.clientY; 
                ghostHand.style.left = `${clientX}px`; 
                ghostHand.style.top = `${clientY}px`; 
                updateCueBallPosition(e); 
            } else if (isPoweringUp) { 
                e.preventDefault(); 
                updatePower(e); 
            } else if (isAimingOnCanvas) { 
                e.preventDefault(); 
                updateAimFromCanvas(e); 
            } else if (isDraggingPektusDot) { 
                e.preventDefault(); 
                handlePektusInput(e); 
            } 
        }

        function handlePointerUp(e) {
            if (isTutorialActive) {
                const currentStep = tutorialSteps[tutorialStep];
                if (currentStep) {
                     if (isDraggingCueBall && currentStep.key === 'place') {
                         if (!isInvalidPlacement) nextTutorialStep();
                    }
                }
            }

            if (isPoweringUp) {
                isPoweringUp = false;
                if (cueStick.power > 0.05) {
                    shoot(cueStick.power * 40 + 2);
                } else {
                    cueStick.power = 0;
                    powerBar.style.height = '0%';
                    cueStick.pullback = 0;
                }
            }
            isAimingOnCanvas = false;
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                ghostHand.style.display = 'none';
                dragGuideText.style.display = 'none';
                if (!isInvalidPlacement) {
                    canMoveCueBall = false;
                    gameState = 'aiming';
                    cueStick.visible = true;
                    if (cueStickElement) cueStickElement.style.display = 'block';
                    if (isOnlineGame && !isTutorialActive) {
                        const chipsToSend = chips.map(c => ({...c, x: c.x / canvas.width, y: c.y / canvas.height }));
                        updateDoc(doc(db, `/artifacts/${appId}/public/data/games`, gameId), { canMoveCueBall: false, chips: chipsToSend, liveAimData: null, currentTurnUid: localPlayerUid });
                    }
                } else {
                    cueStick.visible = true; 
                }
            }
            isDraggingPektusDot = false;
            isRotatingLeft = false;
            isRotatingRight = false;
            if (e.currentTarget.id === 'left-arrow' || e.currentTarget.id === 'right-arrow') {
                e.currentTarget.style.transform = '';
            }
        }
        function getEventPos(e, relativeTo) { const rect = relativeTo.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
        
        // UPDATED: Power control is now inverted (slide down for more power)
        function updatePower(e) { 
            const pos = getEventPos(e, powerControl); 
            let p = pos.y / powerControl.clientHeight; 
            cueStick.power = Math.max(0, Math.min(1, p)); 
            powerBar.style.height = `${cueStick.power * 100}%`; 
            cueStick.pullback = cueStick.power * (150 * scale); 
        }

        function updateAimFromCanvas(e) { const cueChip = chips[0]; if (!cueChip || !cueChip.inPlay) return; const pos = getEventPos(e, canvas); cueStick.angle = Math.atan2(pos.y - cueChip.y, pos.x - cueChip.x); if(!isTutorialActive) sendLiveAimData(); }
        function updateCueBallPosition(e) { const pos = getEventPos(e, canvas); const cueChip = chips[0]; const breakLineX = canvas.width * 0.25; let proposedX, proposedY; if (isBreakShot) { proposedX = Math.max(cueChip.radius, Math.min(breakLineX - cueChip.radius, pos.x)); proposedY = Math.max(cueChip.radius, Math.min(canvas.height - cueChip.radius, pos.y)); } else { proposedX = Math.max(cueChip.radius, Math.min(canvas.width - cueChip.radius, pos.x)); proposedY = Math.max(cueChip.radius, Math.min(canvas.height - cueChip.radius, pos.y)); } if (!isPositionOccupied(proposedX, proposedY, cueChip)) { cueChip.x = proposedX; cueChip.y = proposedY; isInvalidPlacement = false; if(!isTutorialActive) sendLiveAimData(); } else isInvalidPlacement = true; }
        function handlePektusInput(e) { const rect = pektusControl.getBoundingClientRect(); const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left, y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top; const centerX = rect.width / 2, centerY = rect.height / 2; let dx = x - centerX, dy = y - centerY; const dist = Math.sqrt(dx * dx + dy * dy), maxDist = rect.width / 2; if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; } pektusOffset.x = dx / maxDist; pektusOffset.y = dy / maxDist; updatePektusUI(); if(!isTutorialActive) sendLiveAimData(); }
        function isPositionOccupied(x, y, draggedChip) { for (const chip of chips) { if (chip.id === draggedChip.id || !chip.inPlay) continue; if ((x-chip.x)**2 + (y-chip.y)**2 < (draggedChip.radius + chip.radius)**2) return true; } return false; }
        function updateCardDisplay() { if (gameMode.includes('poker')) { cardHandContainer.style.display = 'flex'; cardHandContainer.innerHTML = ''; let currentHand = playerHand; if (!currentHand) return; currentHand.forEach(card => { const cardDiv = document.createElement('div'); cardDiv.className = 'card'; const rankSpan = document.createElement('span'); rankSpan.className = 'card-rank'; rankSpan.textContent = card.rank; const suitSpan = document.createElement('span'); suitSpan.className = 'card-suit'; suitSpan.textContent = card.suit; if (card.suit === '♥' || card.suit === '♦') { rankSpan.style.color = '#D32F2F'; suitSpan.style.color = '#D32F2F'; } else { rankSpan.style.color = '#212121'; suitSpan.style.color = '#212121'; } cardDiv.appendChild(rankSpan); cardDiv.appendChild(suitSpan); cardHandContainer.appendChild(cardDiv); }); } else { cardHandContainer.style.display = 'none'; } updateInfoBox(); }
        function updateInfoBox() { const player1Name = 'You', player2Name = 'Opponent'; if (gameMode.includes('poker')) { playerInfo.innerHTML = `${player1Name}: <span style="color: #FFD700;">${playerHand?.length || 0} cards</span>`; opponentInfo.innerHTML = `${player2Name}: <span style="color: #FFD700;">${opponentHand?.length || 0} cards</span>`; } else if (gameMode.includes('straight-ball')) { const vibrantRed = '#ff6b6b', vibrantBlue = '#54a0ff'; const myColorName = playerChipsType ? playerChipsType.toUpperCase() : '?'; const theirColorName = opponentChipsType ? opponentChipsType.toUpperCase() : '?'; const myDisplayColor = playerChipsType === 'red' ? vibrantRed : (playerChipsType === 'blue' ? vibrantBlue : '#FFD700'); const theirDisplayColor = opponentChipsType === 'red' ? vibrantRed : (opponentChipsType === 'blue' ? vibrantBlue : '#FFD700'); playerInfo.innerHTML = `${player1Name}: <span style="color: ${myDisplayColor};">${myColorName}</span>`; opponentInfo.innerHTML = `${player2Name}: <span style="color: ${theirDisplayColor};">${theirColorName}</span>`; } else if (gameMode.includes('61-ball')) { playerInfo.innerHTML = `${player1Name}: <span style="color: #FFD700; font-weight: bold;">${player61Score} pts</span>`; opponentInfo.innerHTML = `${player2Name}: <span style="color: #FFD700; font-weight: bold;">${opponent61Score} pts</span>`; if(lowestChipNumber > 0 && gameState === 'aiming') { cueBallGuide.innerHTML = `Target: Chip #${lowestChipNumber}`; cueBallGuide.style.display = 'block'; } else { cueBallGuide.style.display = 'none'; } } }
        function resetPektus() { pektusOffset = { x: 0, y: 0 }; updatePektusUI(); }
        function updatePektusUI() { const controlSize = pektusControl.offsetWidth; if (controlSize === 0) return; const dotSize = pektusDot.offsetWidth; const maxOffset = (controlSize / 2) - (dotSize / 2); const dotX = (pektusOffset.x * maxOffset) + (controlSize / 2); const dotY = (pektusOffset.y * maxOffset) + (controlSize / 2); pektusDot.style.left = `${dotX}px`; pektusDot.style.top = `${dotY}px`; }
        
        // START: Tutorial Functions
        function startTutorial(mode, difficultyLevel) {
            resizeCanvas(); 
            const allModals = [gameModeSelect, aiMenu, /*difficultySelect,*/ straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, pokerFoulCardPickModal, leaderboardModal]; 
            allModals.forEach(modal => modal.classList.remove('show')); 
            gameMode = mode; 
            isOnlineGame = false; 
            difficulty = difficultyLevel; 
            playerTurn = true; 
            canMoveCueBall = true; 
            chipsMoving = false; 
            colorsAssigned = false;
            playerChipsType = null;
            opponentChipsType = null;
            setupChips();
            isBreakShot = true;
            gameState = 'moving';
            cueStick.visible = true;
            resetPektus();
            updateInfoBox();
            
            isTutorialActive = true;
            tutorialStep = -1;

            tutorialSteps = [
                {
                    key: 'welcome',
                    elementId: null,
                    text: "Welcome sa Pinoy Pool! Turuan kita ng basics.",
                    trigger: 'button'
                },
                {
                    key: 'place',
                    elementId: 'game-canvas',
                    text: "Unang hakbang: i-drag ang cue ball (puting bola) sa kahit saang pwesto sa likod ng invisible line.",
                    trigger: 'release-cue-ball'
                },
                {
                    key: 'aim',
                    elementId: 'game-canvas',
                    text: "Kita mo ang tako? I-drag mo ang iyong mouse o daliri sa mesa para umasinta.",
                    trigger: 'drag'
                },
                 {
                    key: 'pektus',
                    elementId: 'pektus-control',
                    text: "Gusto mo ng spin? I-drag ang pulang tuldok dito para sa 'pektus'!",
                    trigger: 'drag'
                },
                {
                    key: 'power',
                    elementId: 'power-control',
                    text: "Ito naman ang power bar. I-drag ito pababa para i-set ang lakas ng tira mo.",
                    trigger: 'drag'
                },
                {
                    key: 'shoot',
                    elementId: 'power-control',
                    text: "Ayos! Bitawan mo na ang power bar para tumira.",
                    trigger: 'release-power'
                },
                {
                    key: 'finish',
                    elementId: null,
                    text: "Nice shot! Ganyan lang kadali. Ikaw na ang bahala sa laro. Good luck!",
                    trigger: 'button'
                }
            ];
            
            nextTutorialStep();
        }

        function updateTutorialStep(index) {
    const step = tutorialSteps[index];
    if (!step) {
        endTutorial();
        return;
    }

    interactiveElements.forEach(el => el.style.pointerEvents = 'none');
    
    tutorialOverlay.classList.add('show');
    tutorialText.textContent = step.text;

    if (step.elementId) {
        const targetElement = document.getElementById(step.elementId);
        targetElement.style.pointerEvents = 'all';

        const rect = targetElement.getBoundingClientRect();
        
        tutorialHighlight.style.display = 'block';
        tutorialHighlight.style.left = `${rect.left}px`;
        tutorialHighlight.style.top = `${rect.top}px`;
        tutorialHighlight.style.width = `${rect.width}px`;
        tutorialHighlight.style.height = `${rect.height}px`;

        setTimeout(() => {
            const boxHeight = tutorialBox.offsetHeight;
            let boxTopPosition = rect.bottom + 20;

            if (boxTopPosition + boxHeight > window.innerHeight) {
                boxTopPosition = rect.top - boxHeight - 20;
            }

            if (boxTopPosition < 0) {
                tutorialBox.style.top = '50%';
                tutorialBox.style.left = '50%';
                tutorialBox.style.transform = 'translate(-50%, -50%)';
            } else {
                tutorialBox.style.top = `${boxTopPosition}px`;
                tutorialBox.style.left = '50%';
                tutorialBox.style.transform = 'translateX(-50%)';
            }
        }, 0);

    } else {
        tutorialHighlight.style.display = 'none';
        tutorialBox.style.top = '50%';
        tutorialBox.style.left = '50%';
        tutorialBox.style.transform = 'translate(-50%, -50%)';
    }

    if (step.trigger === 'button') {
        tutorialNextBtn.style.display = 'block';
        tutorialNextBtn.textContent = (step.key === 'finish') ? 'Tapusin ang Tutorial' : 'Sige';
    } else {
        tutorialNextBtn.style.display = 'none';
    }
}


        function nextTutorialStep() {
            if (!isTutorialActive) return;
            
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                updateTutorialStep(tutorialStep);
            } else {
                endTutorial();
            }
        }

        function resetControlInteractivity() {
            interactiveElements.forEach(el => el.style.pointerEvents = 'all');
        }

        function endTutorial() {
            isTutorialActive = false;
            tutorialOverlay.classList.remove('show');
            resetControlInteractivity();
            localStorage.setItem('pinoyPoolTutorialCompleted', 'true');
            showMessage("Tutorial finished. Good luck!", 3000);
            
            if (playerTurn) {
                updateLocalGameState(true);
            }
        }
        // END: Tutorial Functions

        init();
    </script>
</body>
</html>

